<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  
  <title>Effective Java 中文版(item:31-35) | 员外在减肥</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="31. 使用限定通配符来增加API的灵活性如条目 28所述，参数化类型是不变的。换句话说，对于任何两个不同类型的Type1和Type，List &amp;lt;Type1&amp;gt;既不是List &amp;lt;Type2&amp;gt;子类型也不是其父类型。尽管List &amp;lt;String&amp;gt;不是List &amp;lt;Object&amp;gt;的子类型是违反直觉的，但它确实是有道理的。 可以将任何对象放入List &amp;lt;O">
<meta property="og:type" content="article">
<meta property="og:title" content="Effective Java 中文版(item:31-35)">
<meta property="og:url" content="http://luxiangdong.com/2018/05/09/effective-java-cn-31-35/index.html">
<meta property="og:site_name" content="员外在减肥">
<meta property="og:description" content="31. 使用限定通配符来增加API的灵活性如条目 28所述，参数化类型是不变的。换句话说，对于任何两个不同类型的Type1和Type，List &amp;lt;Type1&amp;gt;既不是List &amp;lt;Type2&amp;gt;子类型也不是其父类型。尽管List &amp;lt;String&amp;gt;不是List &amp;lt;Object&amp;gt;的子类型是违反直觉的，但它确实是有道理的。 可以将任何对象放入List &amp;lt;O">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2018-05-09T03:08:52.760Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Effective Java 中文版(item:31-35)">
<meta name="twitter:description" content="31. 使用限定通配符来增加API的灵活性如条目 28所述，参数化类型是不变的。换句话说，对于任何两个不同类型的Type1和Type，List &amp;lt;Type1&amp;gt;既不是List &amp;lt;Type2&amp;gt;子类型也不是其父类型。尽管List &amp;lt;String&amp;gt;不是List &amp;lt;Object&amp;gt;的子类型是违反直觉的，但它确实是有道理的。 可以将任何对象放入List &amp;lt;O">
  
  
    <link rel="icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/typing.css">
  <link rel="stylesheet" href="/css/donate.css">
  
</head>

  
    
      <body>
    
  
      <div id="container" class="container">
        <article id="post-effective-java-cn-31-35" class="article article-type-post" itemscope itemprop="blogPost">
  <header id="header" class="header">
    <div class="mobile-nav">
      <h1 class="nickname">员外在减肥</h1>
      <a id="menu">
        &#9776; Menu
      </a>
    </div>
    
        <nav id="main-nav" class="main-nav">
    
    
      <a class="main-nav-link" href="/">首页</a>
    
      <a class="main-nav-link" href="/archives">文章</a>
    
      <a class="main-nav-link" href="/categories">分类</a>
    
      <a class="main-nav-link" href="/about">关于</a>
    
  </nav>
</header>

  <hr/>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Effective Java 中文版(item:31-35)
    </h1>
  

      </header>
    
    <div class="article-entry typo" itemprop="articleBody">
      
        <h2 id="31-使用限定通配符来增加API的灵活性"><a href="#31-使用限定通配符来增加API的灵活性" class="headerlink" title="31. 使用限定通配符来增加API的灵活性"></a>31. 使用限定通配符来增加API的灵活性</h2><p>如条目 28所述，参数化类型是不变的。换句话说，对于任何两个不同类型的<code>Type1</code>和<code>Type</code>，<code>List &lt;Type1&gt;</code>既不是<code>List &lt;Type2&gt;</code>子类型也不是其父类型。尽管<code>List &lt;String&gt;</code>不是<code>List &lt;Object&gt;</code>的子类型是违反直觉的，但它确实是有道理的。 可以将任何对象放入<code>List &lt;Object&gt;</code>中，但是只能将字符串放入<code>List &lt;String&gt;</code>中。 由于<code>List &lt;String&gt;</code>不能做<code>List &lt;Object&gt;</code>所能做的所有事情，所以它不是一个子类型（条目 10 中的里氏替代原则）。</p>
<p>相对于提供的不可变的类型，有时你需要比此更多的灵活性。 考虑条目 29中的<code>Stack</code>类。下面是它的公共API：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Stack&lt;E&gt; &#123;</span><br><span class="line"></span><br><span class="line">    public Stack();</span><br><span class="line"></span><br><span class="line">    public void push(E e);</span><br><span class="line"></span><br><span class="line">    public E pop();</span><br><span class="line"></span><br><span class="line">    public boolean isEmpty();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设我们想要添加一个方法来获取一系列元素，并将它们全部推送到栈上。 以下是第一种尝试：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// pushAll method without wildcard type - deficient!</span><br><span class="line"></span><br><span class="line">public void pushAll(Iterable&lt;E&gt; src) &#123;</span><br><span class="line">    for (E e : src)</span><br><span class="line">        push(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方法可以干净地编译，但不完全令人满意。 如果可遍历的<code>src</code>元素类型与栈的元素类型完全匹配，那么它工作正常。 但是，假设有一个<code>Stack &lt;Number&gt;</code>，并调用<code>push(intVal)</code>，其中<code>intVal</code>的类型是<code>Integer</code>。 这是因为<code>Integer</code>是<code>Number</code>的子类型。 从逻辑上看，这似乎也应该起作用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;Number&gt; numberStack = new Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">Iterable&lt;Integer&gt; integers = ... ;</span><br><span class="line"></span><br><span class="line">numberStack.pushAll(integers);</span><br></pre></td></tr></table></figure>
<p>但是，如果你尝试了，会得到这个错误消息，因为参数化类型是不变的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">StackTest.java:7: error: incompatible types: Iterable&lt;Integer&gt;</span><br><span class="line"></span><br><span class="line">cannot be converted to Iterable&lt;Number&gt;</span><br><span class="line"></span><br><span class="line">        numberStack.pushAll(integers);</span><br><span class="line"></span><br><span class="line">                            ^</span><br></pre></td></tr></table></figure>
<p>幸运的是，有对应的解决方法。 该语言提供了一种特殊的参数化类型来调用一个限定通配符类型来处理这种情况。 <code>pushAll</code>的输入参数的类型不应该是“E的Iterable接口”，而应该是“E的某个子类型的Iterable接口”，并且有一个通配符类型，这意味着：<code>Iterable &lt;？ extends E&gt;</code>。 （关键字<code>extends</code>的使用有点误导：回忆条目 29中，子类型被定义为每个类型都是它自己的子类型，即使它本身没有继承。）让我们修改<code>pushAll</code>来使用这个类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Wildcard type for a parameter that serves as an E producer</span><br><span class="line"></span><br><span class="line">public void pushAll(Iterable&lt;? extends E&gt; src) &#123;</span><br><span class="line">    for (E e : src)</span><br><span class="line">        push(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了这个改变，<code>Stack</code>类不仅可以干净地编译，而且客户端代码也不会用原始的<code>pushAll</code>声明编译。 因为<code>Stack</code>和它的客户端干净地编译，你知道一切都是类型安全的。</p>
<p>现在假设你想写一个<code>popAll</code>方法，与<code>pushAll</code>方法相对应。 <code>popAll</code>方法从栈中弹出每个元素并将元素添加到给定的集合中。 以下是第一次尝试编写<code>popAll</code>方法的过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// popAll method without wildcard type - deficient!</span><br><span class="line"></span><br><span class="line">public void popAll(Collection&lt;E&gt; dst) &#123;</span><br><span class="line"></span><br><span class="line">    while (!isEmpty())</span><br><span class="line"></span><br><span class="line">        dst.add(pop());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样，如果目标集合的元素类型与栈的元素类型完全匹配，则干净编译并且工作正常。 但是，这又不完全令人满意。 假设你有一个<code>Stack &lt;Number&gt;</code>和<code>Object</code>类型的变量。 如果从栈中弹出一个元素并将其存储在该变量中，它将编译并运行而不会出错。 所以你也不能这样做吗？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;Number&gt; numberStack = new Stack&lt;Number&gt;();</span><br><span class="line"></span><br><span class="line">Collection&lt;Object&gt; objects = ... ;</span><br><span class="line"></span><br><span class="line">numberStack.popAll(objects);</span><br></pre></td></tr></table></figure>
<p>如果尝试将此客户端代码与之前显示的<code>popAll</code>版本进行编译，则会得到与我们的第一版<code>pushAll</code>非常类似的错误：<code>Collection &lt;Object&gt;</code>不是<code>Collection &lt;Number&gt;</code>的子类型。 通配符类型再一次提供了一条出路。 <code>popAll</code>的输入参数的类型不应该是“E的集合”，而应该是“E的某个父类型的集合”（其中父类型被定义为E是它自己的父类型[JLS，4.10]）。 再次，有一个通配符类型，正是这个意思：<code>Collection &lt;？ super E&gt;</code>。 让我们修改<code>popAll</code>来使用它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// Wildcard type for parameter that serves as an E consumer</span><br><span class="line"></span><br><span class="line">public void popAll(Collection&lt;? super E&gt; dst) &#123;</span><br><span class="line"></span><br><span class="line">    while (!isEmpty())</span><br><span class="line"></span><br><span class="line">        dst.add(pop());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过这个改动，Stack类和客户端代码都可以干净地编译。</p>
<p>这个结论很清楚。 <strong>为了获得最大的灵活性，对代表生产者或消费者的输入参数使用通配符类型</strong>。 如果一个输入参数既是一个生产者又是一个消费者，那么通配符类型对你没有好处：你需要一个精确的类型匹配，这就是没有任何通配符的情况。</p>
<p>这里有一个助记符来帮助你记住使用哪种通配符类型：<br><strong>PECS代表： producer-extends，consumer-super。</strong></p>
<p>换句话说，如果一个参数化类型代表一个<code>T</code>生产者，使用<code>&lt;? extends T&gt;</code>；如果它代表<code>T</code>消费者，则使用<code>&lt;? super T&gt;</code>。 在我们的<code>Stack</code>示例中，<code>pushAll</code>方法的<code>src</code>参数生成栈使用的<code>E</code>实例，因此<code>src</code>的合适类型为<code>Iterable&lt;? extends E&gt;</code>；<code>popAll</code>方法的<code>dst</code>参数消费<code>Stack</code>中的<code>E</code>实例，因此<code>ds</code>t的合适类型是<code>Collection &lt;？ super E&gt;</code>。 PECS助记符抓住了使用通配符类型的基本原则。 Naftalin和Wadler称之为获取和放置原则（ Get and Put Principle ）[Naftalin07,2.4]。</p>
<p>记住这个助记符之后，让我们来看看本章中以前项目的一些方法和构造方法声明。 条目 28中的<code>Chooser</code>类构造方法有这样的声明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public Chooser(Collection&lt;T&gt; choices)</span><br></pre></td></tr></table></figure>
<p>这个构造方法只使用集合选择来生产类型<code>T</code>的值（并将它们存储起来以备后用），所以它的声明应该使用一个<code>extends T</code>的通配符类型。下面是得到的构造方法声明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// Wildcard type for parameter that serves as an T producer</span><br><span class="line"></span><br><span class="line">public Chooser(Collection&lt;? extends T&gt; choices)</span><br></pre></td></tr></table></figure>
<p>这种改变在实践中会有什么不同吗？ 是的，会有不同。 假你有一个<code>List &lt;Integer&gt;</code>，并且想把它传递给<code>Chooser&lt;Number&gt;</code>的构造方法。 这不会与原始声明一起编译，但是它只会将限定通配符类型添加到声明中。</p>
<p>现在看看条目 30中的<code>union</code>方法。下是声明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;E&gt; Set&lt;E&gt; union(Set&lt;E&gt; s1, Set&lt;E&gt; s2)</span><br></pre></td></tr></table></figure>
<p>两个参数<code>s1</code>和<code>s2</code>都是<code>E</code>的生产者，所以PECS助记符告诉我们该声明应该如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;E&gt; Set&lt;E&gt; union(Set&lt;? extends E&gt; s1,  Set&lt;? extends E&gt; s2)</span><br></pre></td></tr></table></figure>
<p>请注意，返回类型仍然是<code>Set &lt;E&gt;</code>。 不要使用限定通配符类型作为返回类型。除了会为用户提供额外的灵活性，还强制他们在客户端代码中使用通配符类型。 通过修改后的声明，此代码将清晰地编译：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Integer&gt;  integers =  Set.of(1, 3, 5);</span><br><span class="line"></span><br><span class="line">Set&lt;Double&gt;   doubles  =  Set.of(2.0, 4.0, 6.0);</span><br><span class="line"></span><br><span class="line">Set&lt;Number&gt;   numbers  =  union(integers, doubles);</span><br></pre></td></tr></table></figure>
<p>如果使用得当，类的用户几乎不会看到通配符类型。 他们使方法接受他们应该接受的参数，拒绝他们应该拒绝的参数。 <strong>如果一个类的用户必须考虑通配符类型，那么它的API可能有问题。</strong></p>
<p>在Java 8之前，类型推断规则不够聪明，无法处理先前的代码片段，这要求编译器使用上下文指定的返回类型（或目标类型）来推断<code>E</code>的类型。<code>union</code>方法调用的目标类型如前所示是<code>Set &lt;Number&gt;</code>。 如果尝试在早期版本的Java中编译片段（以及适合的<code>Set.of</code>工厂替代版本），将会看到如此长的错综复杂的错误消息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Union.java:14: error: incompatible types</span><br><span class="line"></span><br><span class="line">        Set&lt;Number&gt; numbers = union(integers, doubles);</span><br><span class="line"></span><br><span class="line">                                   ^</span><br><span class="line"></span><br><span class="line">  required: Set&lt;Number&gt;</span><br><span class="line"></span><br><span class="line">  found:    Set&lt;INT#1&gt;</span><br><span class="line"></span><br><span class="line">  where INT#1,INT#2 are intersection types:</span><br><span class="line"></span><br><span class="line">    INT#1 extends Number,Comparable&lt;? extends INT#2&gt;</span><br><span class="line"></span><br><span class="line">    INT#2 extends Number,Comparable&lt;?&gt;</span><br></pre></td></tr></table></figure>
<p>幸运的是有办法来处理这种错误。 如果编译器不能推断出正确的类型，你可以随时告诉它使用什么类型的显式类型参数[JLS，15.12]。 甚至在Java 8中引入目标类型之前，这不是你必须经常做的事情，这很好，因为显式类型参数不是很漂亮。 通过添加显式类型参数，如下所示，代码片段在Java 8之前的版本中进行了干净编译：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// Explicit type parameter - required prior to Java 8</span><br><span class="line"></span><br><span class="line">Set&lt;Number&gt; numbers = Union.&lt;Number&gt;union(integers, doubles);</span><br></pre></td></tr></table></figure>
<p>接下来让我们把注意力转向条目 30中的<code>max</code>方法。这里是原始声明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T extends Comparable&lt;T&gt;&gt; T max(List&lt;T&gt; list)</span><br></pre></td></tr></table></figure>
<p>以下是使用通配符类型的修改后的声明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T extends Comparable&lt;? super T&gt;&gt; T max(List&lt;? extends T&gt; list)</span><br></pre></td></tr></table></figure>
<p>为了从原来到修改后的声明，我们两次应用了PECS。首先直接的应用是参数列表。 它生成<code>T</code>实例，所以将类型从<code>List &lt;T&gt;</code>更改为<code>List&lt;? extends T&gt;</code>。 棘手的应用是类型参数<code>T</code>。这是我们第一次看到通配符应用于类型参数。 最初，<code>T</code>被指定为继承<code>Comparable &lt;T&gt;</code>，但<code>Comparable</code>的<code>T</code>消费<code>T</code>实例（并生成指示顺序关系的整数）。 因此，参数化类型<code>Comparable &lt;T&gt;</code>被替换为限定通配符类型<code>Comparable&lt;? super T&gt;</code>。 <code>Comparable</code>实例总是消费者，所以通常应该<strong>使用Comparable&lt;? super T&gt;优于Comparable <t></t></strong>。 <code>Comparator</code>也是如此。因此，通常应该<strong>使用Comparator&lt;? super T&gt;优于Comparator<t></t></strong>。</p>
<p>修改后的<code>max</code>声明可能是本书中最复杂的方法声明。 增加的复杂性是否真的起作用了吗？ 同样，它的确如此。 这是一个列表的简单例子，它被原始声明排除，但在被修改后的版本里是允许的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;ScheduledFuture&lt;?&gt;&gt; scheduledFutures = ... ;</span><br></pre></td></tr></table></figure>
<p>无法将原始方法声明应用于此列表的原因是<code>ScheduledFuture</code>不实现<code>Comparable &lt;ScheduledFuture&gt;</code>。 相反，它是<code>Delayed</code>的子接口，它继承了<code>Comparable &lt;Delayed&gt;</code>。 换句话说，一个<code>ScheduledFuture</code>实例不仅仅和其他的<code>ScheduledFuture</code>实例相比较： 它可以与任何<code>Delayed</code>实例比较，并且足以导致原始的声明拒绝它。 更普遍地说，通配符要求来支持没有直接实现<code>Comparable</code>（或<code>Comparator</code>）的类型，但继承了一个类型。</p>
<p>还有一个关于通配符相关的话题。 类型参数和通配符之间具有双重性，许多方法可以用一个或另一个声明。 例如，下面是两个可能的声明，用于交换列表中两个索引项目的静态方法。 第一个使用无限制类型参数（条目 30），第二个使用无限制通配符：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Two possible declarations for the swap method</span><br><span class="line"></span><br><span class="line">public static &lt;E&gt; void swap(List&lt;E&gt; list, int i, int j);</span><br><span class="line"></span><br><span class="line">public static void swap(List&lt;?&gt; list, int i, int j);</span><br></pre></td></tr></table></figure>
<p>这两个声明中的哪一个更可取，为什么？ 在公共API中，第二个更好，因为它更简单。 你传入一个列表（任何列表），该方法交换索引的元素。 没有类型参数需要担心。 通常，<strong>如果类型参数在方法声明中只出现一次，请将其替换为通配符</strong>。 如果它是一个无限制的类型参数，请将其替换为无限制的通配符; 如果它是一个限定类型参数，则用限定通配符替换它。</p>
<p>第二个<code>swap</code>方法声明有一个问题。 这个简单的实现不会编译：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static void swap(List&lt;?&gt; list, int i, int j) &#123;</span><br><span class="line">    list.set(i, list.set(j, list.get(i)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>试图编译它会产生这个不太有用的错误信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Swap.java:5: error: incompatible types: Object cannot be</span><br><span class="line"></span><br><span class="line">converted to CAP#1</span><br><span class="line"></span><br><span class="line">        list.set(i, list.set(j, list.get(i)));</span><br><span class="line"></span><br><span class="line">                                        ^</span><br><span class="line"></span><br><span class="line">  where CAP#1 is a fresh type-variable:</span><br><span class="line"></span><br><span class="line">    CAP#1 extends Object from capture of ?</span><br></pre></td></tr></table></figure>
<p>看起来我们不能把一个元素放回到我们刚刚拿出来的列表中。 问题是列表的类型是<code>List &lt;？&gt;</code>，并且不能将除null外的任何值放入<code>List &lt;？&gt;</code>中。 幸运的是，有一种方法可以在不使用不安全的转换或原始类型的情况下实现此方法。 这个想法是写一个私有辅助方法来捕捉通配符类型。 辅助方法必须是泛型方法才能捕获类型。 以下是它的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static void swap(List&lt;?&gt; list, int i, int j) &#123;</span><br><span class="line"></span><br><span class="line">    swapHelper(list, i, j);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Private helper method for wildcard capture</span><br><span class="line"></span><br><span class="line">private static &lt;E&gt; void swapHelper(List&lt;E&gt; list, int i, int j) &#123;</span><br><span class="line"></span><br><span class="line">    list.set(i, list.set(j, list.get(i)));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>swapHelper</code>方法知道该列表是一个<code>List &lt;E&gt;</code>。 因此，它知道从这个列表中获得的任何值都是E类型，并且可以安全地将任何类型的<code>E</code>值放入列表中。 这个稍微复杂的<code>swap</code>的实现可以干净地编译。 它允许我们导出基于通配符的漂亮声明，同时利用内部更复杂的泛型方法。 <code>swap</code>方法的客户端不需要面对更复杂的<code>swapHelper</code>声明，但他们从中受益。 辅助方法具有我们认为对公共方法来说过于复杂的签名。</p>
<p>总之，在你的API中使用通配符类型，虽然棘手，但使得API更加灵活。 如果编写一个将被广泛使用的类库，正确使用通配符类型应该被认为是强制性的。 记住基本规则： producer-extends, consumer-super（PECS）。 还要记住，所有<code>Comparable</code>和<code>Comparator</code>都是消费者。</p>
<h2 id="32-合理地结合泛型和可变参数"><a href="#32-合理地结合泛型和可变参数" class="headerlink" title="32. 合理地结合泛型和可变参数"></a>32. 合理地结合泛型和可变参数</h2><p>在Java 5中，可变参数方法（条目 53）和泛型都被添加到平台中，所以你可能希望它们能够正常交互; 可悲的是，他们并没有。 可变参数的目的是允许客户端将一个可变数量的参数传递给一个方法，但这是一个脆弱的抽象（ leaky abstraction）：当你调用一个可变参数方法时，会创建一个数组来保存可变参数；那个应该是实现细节的数组是可见的。 因此，当可变参数具有泛型或参数化类型时，会导致编译器警告混淆。</p>
<p>回顾条目 28，非具体化（ non-reifiable）的类型是其运行时表示比其编译时表示具有更少信息的类型，并且几乎所有泛型和参数化类型都是不可具体化的。 如果某个方法声明其可变参数为非具体化的类型，则编译器将在该声明上生成警告。 如果在推断类型不可确定的可变参数参数上调用该方法，那么编译器也会在调用中生成警告。 警告看起来像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">warning: [unchecked] Possible heap pollution from</span><br><span class="line">    parameterized vararg type List&lt;String&gt;</span><br></pre></td></tr></table></figure>
<p>当参数化类型的变量引用不属于该类型的对象时会发生堆污染（Heap pollution）[JLS，4.12.2]。 它会导致编译器的自动生成的强制转换失败，违反了泛型类型系统的基本保证。</p>
<p>例如，请考虑以下方法，该方法是第127页上的代码片段的一个不太明显的变体：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// Mixing generics and varargs can violate type safety!</span><br><span class="line">static void dangerous(List&lt;String&gt;... stringLists) &#123;</span><br><span class="line">    List&lt;Integer&gt; intList = List.of(42);</span><br><span class="line">    Object[] objects = stringLists;</span><br><span class="line">    objects[0] = intList;             // Heap pollution</span><br><span class="line">    String s = stringLists[0].get(0); // ClassCastException</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此方法没有可见的强制转换，但在调用一个或多个参数时抛出ClassCastException异常。 它的最后一行有一个由编译器生成的隐形转换。 这种转换失败，表明类型安全性已经被破坏，并且<strong>将值保存在泛型可变参数数组参数中是不安全的</strong>。</p>
<p>这个例子引发了一个有趣的问题：为什么声明一个带有泛型可变参数的方法是合法的，当明确创建一个泛型数组是非法的时候呢？ 换句话说，为什么前面显示的方法只生成一个警告，而127页上的代码片段会生成一个错误？ 答案是，具有泛型或参数化类型的可变参数参数的方法在实践中可能非常有用，因此语言设计人员选择忍受这种不一致。 事实上，Java类库导出了几个这样的方法，包括<code>Arrays.asList(T... a)</code>，<code>Collections.addAll(Collection&lt;? super T&gt; c, T... elements)</code>，<code>EnumSet.of(E first, E... rest)</code>。 与前面显示的危险方法不同，这些类库方法是类型安全的。</p>
<p>在Java 7中，<code>SafeVarargs</code>注解已添加到平台，以允许具有泛型可变参数的方法的作者自动禁止客户端警告。 实质上，<strong>SafeVarargs注解构成了作者对类型安全的方法的承诺</strong>。 为了交换这个承诺，编译器同意不要警告用户调用可能不安全的方法。</p>
<p>除非它实际上是安全的，否则注意不要使用<code>@SafeVarargs</code>注解标注一个方法。 那么需要做些什么来确保这一点呢？ 回想一下，调用方法时会创建一个泛型数组，以容纳可变参数。 如果方法没有在数组中存储任何东西（它会覆盖参数）并且不允许对数组的引用进行转义（这会使不受信任的代码访问数组），那么它是安全的。 换句话说，如果可变参数数组仅用于从调用者向方法传递可变数量的参数——毕竟这是可变参数的目的——那么该方法是安全的。</p>
<p>值得注意的是，你可以违反类型安全性，即使不会在可变参数数组中存储任何内容。 考虑下面的泛型可变参数方法，它返回一个包含参数的数组。 乍一看，它可能看起来像一个方便的小工具：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// UNSAFE - Exposes a reference to its generic parameter array!</span><br><span class="line">static &lt;T&gt; T[] toArray(T... args) &#123;</span><br><span class="line">    return args;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法只是返回它的可变参数数组。 该方法可能看起来并不危险，但它是！ 该数组的类型由传递给方法的参数的编译时类型决定，编译器可能没有足够的信息来做出正确的判断。 由于此方法返回其可变参数数组，它可以将堆污染传播到调用栈上。</p>
<p>为了具体说明，请考虑下面的泛型方法，它接受三个类型<code>T</code>的参数，并返回一个包含两个参数的数组，随机选择：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static &lt;T&gt; T[] pickTwo(T a, T b, T c) &#123;</span><br><span class="line">    switch(ThreadLocalRandom.current().nextInt(3)) &#123;</span><br><span class="line">      case 0: return toArray(a, b);</span><br><span class="line">      case 1: return toArray(a, c);</span><br><span class="line">      case 2: return toArray(b, c);</span><br><span class="line">    &#125;</span><br><span class="line">    throw new AssertionError(); // Can&apos;t get here</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法本身不是危险的，除了调用具有泛型可变参数的<code>toArray</code>方法之外，不会产生警告。</p>
<p>编译此方法时，编译器会生成代码以创建一个将两个<code>T</code>实例传递给<code>toArray</code>的可变参数数组。 这段代码分配了一个<code>Object []</code>类型的数组，它是保证保存这些实例的最具体的类型，而不管在调用位置传递给<code>pickTwo</code>的对象是什么类型。 <code>toArray</code>方法只是简单地将这个数组返回给<code>pickTwo</code>，然后<code>pickTwo</code>将它返回给调用者，所以<code>pickTwo</code>总是返回一个<code>Object []</code>类型的数组。</p>
<p>现在考虑这个测试<code>pickTw</code>的<code>main</code>方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    String[] attributes = pickTwo(&quot;Good&quot;, &quot;Fast&quot;, &quot;Cheap&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方法没有任何问题，因此它编译时不会产生任何警告。 但是当运行它时，抛出一个ClassCastException异常，尽管不包含可见的转换。 你没有看到的是，编译器已经生成了一个隐藏的强制转换为由<code>pickTwo</code>返回的值的<code>String []</code>类型，以便它可以存储在属性中。 转换失败，因为<code>Object []</code>不是<code>String []</code>的子类型。 这种故障相当令人不安，因为它从实际导致堆污染（<code>toArray</code>）的方法中移除了两个级别，并且在实际参数存储在其中之后，可变参数数组未被修改。</p>
<p>这个例子是为了让人们认识到<strong>给另一个方法访问一个泛型的可变参数数组是不安全的</strong>，除了两个例外：将数组传递给另一个可变参数方法是安全的，这个方法是用<code>@SafeVarargs</code>正确标注的， 将数组传递给一个非可变参数的方法是安全的，该方法仅计算数组内容的一些方法。</p>
<p>这里是安全使用泛型可变参数的典型示例。 此方法将任意数量的列表作为参数，并按顺序返回包含所有输入列表元素的单个列表。 由于该方法使用<code>@SafeVarargs</code>进行标注，因此在声明或其调用站位置上不会生成任何警告：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// Safe method with a generic varargs parameter</span><br><span class="line">@SafeVarargs</span><br><span class="line">static &lt;T&gt; List&lt;T&gt; flatten(List&lt;? extends T&gt;... lists) &#123;</span><br><span class="line">    List&lt;T&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line">    for (List&lt;? extends T&gt; list : lists)</span><br><span class="line">        result.addAll(list);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>决定何时使用<code>SafeVarargs</code>注解的规则很简单：在每种方法上使用<code>@SafeVarargs</code>，并使用泛型或参数化类型的可变参数，这样用户就不会因不必要的和令人困惑的编译器警告而担忧。 这意味着你不应该写危险或者<code>toArray</code>等不安全的可变参数方法。 每次编译器警告你可能会受到来自你控制的方法中泛型可变参数的堆污染时，请检查该方法是否安全。 提醒一下，在下列情况下，泛型可变参数方法是安全的：<br>1.它不会在可变参数数组中存储任何东西</p>
<p>2.它不会使数组（或克隆）对不可信代码可见。 如果违反这些禁令中的任何一项，请修复。</p>
<p>请注意，<code>SafeVarargs</code>注解只对不能被重写的方法是合法的，因为不可能保证每个可能的重写方法都是安全的。 在Java 8中，注解仅在静态方法和final实例方法上合法; 在Java 9中，它在私有实例方法中也变为合法。</p>
<p>使用<code>SafeVarargs</code>注解的替代方法是采用条目 28的建议，并用<code>List</code>参数替换可变参数（这是一个变相的数组）。 下面是应用于我们的<code>flatten</code>方法时，这种方法的样子。 请注意，只有参数声明被更改了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// List as a typesafe alternative to a generic varargs parameter</span><br><span class="line">static &lt;T&gt; List&lt;T&gt; flatten(List&lt;List&lt;? extends T&gt;&gt; lists) &#123;</span><br><span class="line">    List&lt;T&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line">    for (List&lt;? extends T&gt; list : lists)</span><br><span class="line">        result.addAll(list);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后可以将此方法与静态工厂方法<code>List.of</code>结合使用，以允许可变数量的参数。 请注意，这种方法依赖于<code>List.of</code>声明使用<code>@SafeVarargs</code>注解：<br>audience = flatten(List.of(friends, romans, countrymen));</p>
<p>这种方法的优点是编译器可以证明这种方法是类型安全的。 不必使用<code>SafeVarargs</code>注解来证明其安全性，也不用担心在确定安全性时可能会犯错。 主要缺点是客户端代码有点冗长，运行可能会慢一些。</p>
<p>这个技巧也可以用在不可能写一个安全的可变参数方法的情况下，就像第147页的<code>toArray</code>方法那样。它的列表模拟是<code>List.of</code>方法，所以我们甚至不必编写它; Java类库作者已经为我们完成了这项工作。 <code>pickTwo</code>方法然后变成这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static &lt;T&gt; List&lt;T&gt; pickTwo(T a, T b, T c) &#123;</span><br><span class="line">    switch(rnd.nextInt(3)) &#123;</span><br><span class="line">      case 0: return List.of(a, b);</span><br><span class="line">      case 1: return List.of(a, c);</span><br><span class="line">      case 2: return List.of(b, c);</span><br><span class="line">    &#125;</span><br><span class="line">    throw new AssertionError();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>main</code>方变成这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;String&gt; attributes = pickTwo(&quot;Good&quot;, &quot;Fast&quot;, &quot;Cheap&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>生成的代码是类型安全的，因为它只使用泛型，不是数组。</p>
<p>总而言之，可变参数和泛型不能很好地交互，因为可变参数机制是在数组上面构建的脆弱的抽象，并且数组具有与泛型不同的类型规则。 虽然泛型可变参数不是类型安全的，但它们是合法的。 如果选择使用泛型（或参数化）可变参数编写方法，请首先确保该方法是类型安全的，然后使用<code>@SafeVarargs</code>注解对其进行标注，以免造成使用不愉快。</p>
<h2 id="33-优先考虑类型安全的异构容器"><a href="#33-优先考虑类型安全的异构容器" class="headerlink" title="33. 优先考虑类型安全的异构容器"></a>33. 优先考虑类型安全的异构容器</h2><p>泛型的常见用法包括集合，如<code>Set &lt;E&gt;</code>和<code>Map &lt;K，V&gt;</code>和单个元素容器，如<code>ThreadLocal &lt;T&gt;</code>和<code>AtomicReference &lt;T&gt;</code>。 在所有这些用途中，它都是参数化的容器。 这限制了每个容器只能有固定数量的类型参数。 通常这正是你想要的。 一个<code>Set</code>有单一的类型参数，表示它的元素类型; 一个<code>Map</code>有两个，代表它的键和值的类型；等等。</p>
<p>然而有时候，你需要更多的灵活性。 例如，数据库一行记录可以具有任意多列，并且能够以类型安全的方式访问它们是很好的。 幸运的是，有一个简单的方法可以达到这个效果。 这个想法是参数化键（key）而不是容器。 然后将参数化的键提交给容器以插入或检索值。 泛型类型系统用于保证值的类型与其键一致。</p>
<p>作为这种方法的一个简单示例，请考虑一个Favorites类，它允许其客户端保存和检索任意多种类型的<code>favorite</code>实例。 该类型的Class对象将扮演参数化键的一部分。其原因是这<code>Class</code>类是泛型的。 类的类型从字面上来说不是简单的<code>Class</code>，而是<code>Class &lt;T&gt;</code>。 例如，<code>String.class</code>的类型为<code>Class &lt;String&gt;</code>，<code>Integer.class的</code>类型为<code>Class &lt;Integer&gt;</code>。 当在方法中传递字面类传递编译时和运行时类型信息时，它被称为类型令牌（type token）[Bracha04]。</p>
<p><code>Favorites</code>类的API很简单。 它看起来就像一个简单Map类，除了该键是参数化的以外。 客户端在设置和获取<code>favorites</code>实例时呈现一个Class对象。 这里是API：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Typesafe heterogeneous container pattern - API</span><br><span class="line">public class Favorites &#123;</span><br><span class="line">    public &lt;T&gt; void putFavorite(Class&lt;T&gt; type, T instance);</span><br><span class="line">    public &lt;T&gt; T getFavorite(Class&lt;T&gt; type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是一个演示<code>Favorites</code>类，保存，检索和打印喜欢的<code>String</code>，<code>Integer</code>和<code>Class</code>实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// Typesafe heterogeneous container pattern - client</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">    Favorites f = new Favorites();</span><br><span class="line"></span><br><span class="line">    f.putFavorite(String.class, &quot;Java&quot;);</span><br><span class="line"></span><br><span class="line">    f.putFavorite(Integer.class, 0xcafebabe);</span><br><span class="line"></span><br><span class="line">    f.putFavorite(Class.class, Favorites.class);</span><br><span class="line"></span><br><span class="line">     String favoriteString = f.getFavorite(String.class);</span><br><span class="line"></span><br><span class="line">    int favoriteInteger = f.getFavorite(Integer.class);</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; favoriteClass = f.getFavorite(Class.class);</span><br><span class="line"></span><br><span class="line">    System.out.printf(&quot;%s %x %s%n&quot;, favoriteString,</span><br><span class="line"></span><br><span class="line">        favoriteInteger, favoriteClass.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正如你所期望的，这个程序打印<code>Java cafebabe Favorites</code>。 请注意，顺便说一下，Java的<code>printf</code>方法与C语言的不同之处在于，应该使用<code>％n</code>，而在C中使用<code>\n</code>。<code>％n</code>生成适用的特定于平台的行分隔符，该分隔符在很多但不是所有平台上都是<code>\n</code>。</p>
<p><code>Favorites</code>实例是类型安全的：当你请求一个字符串时它永远不会返回一个整数。 它也是异构的：与普通Map不同，所有的键都是不同的类型。 因此，我们将<code>Favorites</code>称为类型安全异构容器（typesafe heterogeneous container.）。</p>
<p><code>Favorites</code>的实现非常小巧。 这是完整的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// Typesafe heterogeneous container pattern - implementation</span><br><span class="line">public class Favorites &#123;</span><br><span class="line">    private Map&lt;Class&lt;?&gt;, Object&gt; favorites = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public &lt;T&gt; void putFavorite(Class&lt;T&gt; type, T instance) &#123;</span><br><span class="line">        favorites.put(Objects.requireNonNull(type), instance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public &lt;T&gt; T getFavorite(Class&lt;T&gt; type) &#123;</span><br><span class="line">        return type.cast(favorites.get(type));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有一些微妙的事情发生。 每个<code>Favorites</code>实例都由一个名为<code>favorites</code>私有的<code>Map&lt;Class&lt;?&gt;, Object&gt;</code>来支持。 你可能认为无法将任何内容放入此Map中，因为这是无限定的通配符类型，但事实恰恰相反。 需要注意的是通配符类型是嵌套的：它不是通配符类型的Map类型，而是键的类型。 这意味着每个键都可以有不同的参数化类型：一个可以是<code>Class &lt;String&gt;</code>，下一个<code>Class &lt;Integer&gt;</code>等等。 这就是异构的由来。</p>
<p>接下来要注意的是，favorites的Map的值类型只是Object。 换句话说，Map不保证键和值之间的类型关系，即每个值都是由其键表示的类型。 事实上，Java的类型系统并不足以表达这一点。 但是我们知道这是真的，并在检索一个favorite时利用了这点。</p>
<p><code>putFavorite</code>实现很简单：只需将给定的Class对象映射到给定的favorites的实例即可。 如上所述，这丢弃了键和值之间的“类型联系（type linkage）”；无法知道这个值是不是键的一个实例。 但没关系，因为<code>getFavorites</code>方法可以并且确实重新建立这种关联。</p>
<p><code>getFavorite</code>的实现比<code>putFavorite</code>更复杂。 首先，它从favorites Map中获取与给定Class对象相对应的值。 这是返回的正确对象引用，但它具有错误的编译时类型：它是Object（favorites map的值类型），我们需要返回类型<code>T</code>。因此，<code>getFavorite</code>实现动态地将对象引用转换为Class对象表示的类型，使用Class的<code>cast</code>方法。</p>
<p><code>cast</code>方法是Java的cast操作符的动态模拟。它只是检查它的参数是否由Class对象表示的类型的实例。如果是，它返回参数；否则会抛出<code>ClassCastException</code>异常。我们知道，假设客户端代码能够干净地编译，<code>getFavorite</code>中的强制转换不会抛出<code>ClassCastException</code>异常。 也就是说，favorites map中的值始终与其键的类型相匹配。</p>
<p>那么这个<code>cast</code>方法为我们做了什么，因为它只是返回它的参数？ <code>cast</code>的签名充分利用了Class类是泛型的事实。 它的返回类型是Class对象的类型参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class Class&lt;T&gt; &#123;</span><br><span class="line">    T cast(Object obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这正是<code>getFavorite</code>方法所需要的。 这正是确保Favorites类型安全，而不用求助一个未经检查的强制转换的<code>T</code>类型。</p>
<p>Favorites类有两个限制值得注意。 首先，恶意客户可以通过使用原始形式的Class对象，轻松破坏Favorites实例的类型安全。 但生成的客户端代码在编译时会生成未经检查的警告。 这与正常的集合实现（如HashSet和HashMap）没有什么不同。 通过使用原始类型HashSet（条目 26），可以轻松地将字符串放入<code>HashSet &lt;Integer&gt;</code>中。 也就是说，如果你愿意为此付出一点代价，就可以拥有运行时类型安全性。 确保Favorites永远不违反类型不变的方法是，使<code>putFavorite</code>方法检查该实例是否由type表示类型的实例，并且我们已经知道如何执行此操作。只需使用动态转换：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Achieving runtime type safety with a dynamic cast</span><br><span class="line">public &lt;T&gt; void putFavorite(Class&lt;T&gt; type, T instance) &#123;</span><br><span class="line">    favorites.put(type, type.cast(instance));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>java.util.Collections</code>中有一些集合包装类，可以发挥相同的诀窍。 它们被称为<code>checkedSet</code>，<code>checkedList</code>，<code>checkedMap</code>等等。 他们的静态工厂除了一个集合（或Map）之外还有一个Class对象（或两个）。 静态工厂是泛型方法，确保Class对象和集合的编译时类型匹配。 包装类为它们包装的集合添加了具体化。 例如，如果有人试图将<code>Coin</code>放入你的<code>Collection &lt;Stamp&gt;</code>中，则包装类在运行时会抛出<code>ClassCastException</code>。 这些包装类对于追踪在混合了泛型和原始类型的应用程序中添加不正确类型的元素到集合的客户端代码很有用。</p>
<p>Favorites类的第二个限制是它不能用于不可具体化的（non-reifiable）类型（条目 28）。 换句话说，你可以保存你最喜欢的<code>String</code>或<code>String []</code>，但不能保存<code>List &lt;String&gt;</code>。 如果你尝试保存你最喜欢的<code>List &lt;String&gt;</code>，程序将不能编译。 原因是无法获取<code>List &lt;String&gt;</code>的Class对象。 <code>List &lt;String&gt; .class</code>是语法错误，也是一件好事。 <code>List &lt;String&gt;</code>和<code>List &lt;Integer&gt;</code>共享一个Class对象，即<code>List.class</code>。 如果“字面类型（type literals）”<code>List &lt;String&gt; .class</code>和<code>List &lt;Integer&gt; .class</code>合法并返回相同的对象引用，那么它会对Favorites对象的内部造成严重破坏。 对于这种限制，没有完全令人满意的解决方法。</p>
<p>Favorites使用的类型令牌( type tokens)是无限制的：<code>getFavorite</code>和<code>putFavorite</code>接受任何Class对象。 有时你可能需要限制可传递给方法的类型。 这可以通过一个有限定的类型令牌来实现，该令牌只是一个类型令牌，它使用限定的类型参数（条目 30）或限定的通配符（条目 31）来放置可以表示的类型的边界。</p>
<p>注解API（条目 39）广泛使用限定类型的令牌。 例如，以下是在运行时读取注解的方法。 此方法来自<code>AnnotatedElement</code>接口，该接口由表示类，方法，属性和其他程序元素的反射类型实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T extends Annotation&gt;</span><br><span class="line">    T getAnnotation(Class&lt;T&gt; annotationType);</span><br></pre></td></tr></table></figure>
<p>参数<code>annotationType</code>是表示注解类型的限定类型令牌。 该方法返回该类型的元素的注解（如果它有一个）；如果没有，则返回null。 本质上，注解元素是一个类型安全的异构容器，其键是注解类型。</p>
<p>假设有一个<code>Class &lt;?&gt;</code>类型的对象，并且想要将它传递给需要限定类型令牌（如<code>getAnnotation</code>）的方法。 可以将对象转换为<code>Class&lt;? extends Annotation&gt;</code>，但是这个转换没有被检查，所以它会产生一个编译时警告（条目 27）。 幸运的是，Class类提供了一种安全（动态）执行这种类型转换的实例方法。 该方法被称为<code>asSubclass</code>，并且它转换所调用的Class对象来表示由其参数表示的类的子类。 如果转换成功，该方法返回它的参数；如果失败，则抛出<code>ClassCastException</code>异常。</p>
<p>以下是如何使用<code>asSubclass</code>方法在编译时读取类型未知的注解。 此方法编译时没有错误或警告：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// Use of asSubclass to safely cast to a bounded type token</span><br><span class="line">static Annotation getAnnotation(AnnotatedElement element,</span><br><span class="line">                                String annotationTypeName) &#123;</span><br><span class="line">    Class&lt;?&gt; annotationType = null; // Unbounded type token</span><br><span class="line">    try &#123;</span><br><span class="line">        annotationType = Class.forName(annotationTypeName);</span><br><span class="line">    &#125; catch (Exception ex) &#123;</span><br><span class="line">        throw new IllegalArgumentException(ex);</span><br><span class="line">    &#125;</span><br><span class="line">    return element.getAnnotation(</span><br><span class="line">        annotationType.asSubclass(Annotation.class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总之，泛型API的通常用法（以集合API为例）限制了每个容器的固定数量的类型参数。 你可以通过将类型参数放在键上而不是容器上来解决此限制。 可以使用Class对象作为此类型安全异构容器的键。 以这种方式使用的Class对象称为类型令牌。 也可以使用自定义键类型。 例如，可以有一个表示数据库行（容器）的<code>DatabaseRow</code>类型和一个泛型类型<code>Column &lt;T&gt;</code>作为其键。</p>
<h2 id="34-使用枚举类型替代整型常量"><a href="#34-使用枚举类型替代整型常量" class="headerlink" title="34. 使用枚举类型替代整型常量"></a>34. 使用枚举类型替代整型常量</h2><p>枚举是其合法值由一组固定的常量组成的一种类型，例如一年中的季节，太阳系中的行星或一副扑克牌中的套装。 在将枚举类型添加到该语言之前，表示枚举类型的常见模式是声明一组名为int的常量，每个类型的成员都有一个常量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// The int enum pattern - severely deficient!</span><br><span class="line">public static final int APPLE_FUJI         = 0;</span><br><span class="line">public static final int APPLE_PIPPIN       = 1;</span><br><span class="line">public static final int APPLE_GRANNY_SMITH = 2;</span><br><span class="line">public static final int ORANGE_NAVEL  = 0;</span><br><span class="line">public static final int ORANGE_TEMPLE = 1;</span><br><span class="line">public static final int ORANGE_BLOOD  = 2;</span><br></pre></td></tr></table></figure>
<p>这种被称为int枚举模式的技术有许多缺点。 它没有提供类型安全的方式，也没有提供任何表达力。 如果你将一个Apple传递给一个需要Orange的方法，那么编译器不会出现警告，还会用<code>==</code>运算符比较Apple与Orange，或者更糟糕的是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// Tasty citrus flavored applesauce!</span><br><span class="line">int i = (APPLE_FUJI - ORANGE_TEMPLE) / APPLE_PIPPIN;</span><br></pre></td></tr></table></figure>
<p>请注意，每个Apple常量的名称前缀为<code>APPLE_</code>，每个<code>Orange</code>常量的名称前缀为<code>ORANGE_</code>。 这是因为Java不为int枚举组提供名称空间。 当两个int枚举组具有相同的命名常量时，前缀可以防止名称冲突，例如在<code>ELEMENT_MERCURY</code>和<code>PLANET_MERCURY</code>之间。</p>
<p>使用int枚举的程序很脆弱。 因为int枚举是编译时常量[JLS，4.12.4]，所以它们的int值被编译到使用它们的客户端中[JLS，13.1]。 如果与int枚举关联的值发生更改，则必须重新编译其客户端。 如果没有，客户仍然会运行，但他们的行为将是不正确的。</p>
<p>没有简单的方法将int枚举常量转换为可打印的字符串。 如果你打印这样一个常量或者从调试器中显示出来，你看到的只是一个数字，这不是很有用。 没有可靠的方法来迭代组中的所有int枚举常量，甚至无法获得int枚举组的大小。</p>
<p>你可能会遇到这种模式的变体，其中使用了字符串常量来代替int常量。 这种称为字符串枚举模式的变体更不理想。 尽管它为常量提供了可打印的字符串，但它可以导致初级用户将字符串常量硬编码为客户端代码，而不是使用属性名称。 如果这种硬编码的字符串常量包含书写错误，它将在编译时逃脱检测并导致运行时出现错误。 此外，它可能会导致性能问题，因为它依赖于字符串比较。</p>
<p>幸运的是，Java提供了一种避免int和String枚举模式的所有缺点的替代方法，并提供了许多额外的好处。 它是枚举类型[JLS，8.9]。 以下是它最简单的形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public enum Apple  &#123; FUJI, PIPPIN, GRANNY_SMITH &#125;</span><br><span class="line">public enum Orange &#123; NAVEL, TEMPLE, BLOOD &#125;</span><br></pre></td></tr></table></figure>
<p>从表面上看，这些枚举类型可能看起来与其他语言类似，比如C，C ++和C＃，但事实并非如此。 Java的枚举类型是完整的类，比其他语言中的其他语言更强大，其枚举本质本上是int值。</p>
<p>Java枚举类型背后的基本思想很简单：它们是通过公共静态final属性为每个枚举常量导出一个实例的类。 由于没有可访问的构造方法，枚举类型实际上是final的。 由于客户既不能创建枚举类型的实例也不能继承它，除了声明的枚举常量外，不能有任何实例。 换句话说，枚举类型是实例控制的（第6页）。 它们是单例（条目 3）的泛型化，基本上是单元素的枚举。</p>
<p>枚举提供了编译时类型的安全性。 如果声明一个参数为Apple类型，则可以保证传递给该参数的任何非空对象引用是三个有效Apple值中的一个。 尝试传递错误类型的值将导致编译时错误，因为会尝试将一个枚举类型的表达式分配给另一个类型的变量，或者使用<code>==</code>运算符来比较不同枚举类型的值。</p>
<p>具有相同名称常量的枚举类型可以和平共存，因为每种类型都有其自己的名称空间。 可以在枚举类型中添加或重新排序常量，而无需重新编译其客户端，因为导出常量的属性在枚举类型与其客户端之间提供了一层隔离：常量值不会编译到客户端，因为它们位于int枚举模式中。 最后，可以通过调用其<code>toString</code>方法将枚举转换为可打印的字符串。</p>
<p>除了纠正int枚举的缺陷之外，枚举类型还允许添加任意方法和属性并实现任意接口。 它们提供了所有Object方法的高质量实现（第3章），它们实现了<code>Comparable</code>（条目 14）和<code>Serializable</code>（第12章），并针对枚举类型的可任意改变性设计了序列化方式。</p>
<p>那么，为什么你要添加方法或属性到一个枚举类型？ 对于初学者，可能想要将数据与其常量关联起来。 例如，我们的Apple和Orange类型可能会从返回水果颜色的方法或返回水果图像的方法中受益。 还可以使用任何看起来合适的方法来增强枚举类型。 枚举类型可以作为枚举常量的简单集合，并随着时间的推移而演变为全功能抽象。</p>
<p>对于丰富的枚举类型的一个很好的例子，考虑我们太阳系的八颗行星。 每个行星都有质量和半径，从这两个属性可以计算出它的表面重力。 从而在给定物体的质量下，计算出一个物体在行星表面上的重量。 下面是这个枚举类型。 每个枚举常量之后的括号中的数字是传递给其构造方法的参数。 在这种情况下，它们是地球的质量和半径：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// Enum type with data and behavior</span><br><span class="line">public enum Planet &#123;</span><br><span class="line">    MERCURY(3.302e+23, 2.439e6),</span><br><span class="line">    VENUS  (4.869e+24, 6.052e6),</span><br><span class="line">    EARTH  (5.975e+24, 6.378e6),</span><br><span class="line">    MARS   (6.419e+23, 3.393e6),</span><br><span class="line">    JUPITER(1.899e+27, 7.149e7),</span><br><span class="line">    SATURN (5.685e+26, 6.027e7),</span><br><span class="line">    URANUS (8.683e+25, 2.556e7),</span><br><span class="line">    NEPTUNE(1.024e+26, 2.477e7);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private final double mass;           // In kilograms</span><br><span class="line">    private final double radius;         // In meters</span><br><span class="line">    private final double surfaceGravity; // In m / s^2</span><br><span class="line">    // Universal gravitational constant in m^3 / kg s^2</span><br><span class="line">    private static final double G = 6.67300E-11;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // Constructor</span><br><span class="line">    Planet(double mass, double radius) &#123;</span><br><span class="line">        this.mass = mass;</span><br><span class="line">        this.radius = radius;</span><br><span class="line">        surfaceGravity = G * mass / (radius * radius);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public double mass()           &#123; return mass; &#125;</span><br><span class="line">    public double radius()         &#123; return radius; &#125;</span><br><span class="line">    public double surfaceGravity() &#123; return surfaceGravity; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public double surfaceWeight(double mass) &#123;</span><br><span class="line">        return mass * surfaceGravity;  // F = ma</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编写一个丰富的枚举类型比如<code>Planet</code>很容易。 <strong>要将数据与枚举常量相关联，请声明实例属性并编写一个构造方法，构造方法带有数据并将数据保存在属性中</strong>。 枚举本质上是不变的，所以所有的属性都应该是final的（条目 17）。 属性可以是公开的，但最好将它们设置为私有并提供公共访问方法（条目16）。 在<code>Planet</code>的情况下，构造方法还计算和存储表面重力，但这只是一种优化。 每当重力被<code>SurfaceWeight</code>方法使用时，它可以从质量和半径重新计算出来，该方法返回它在由常数表示的行星上的重量。</p>
<p>虽然<code>Planet</code>枚举很简单，但它的功能非常强大。 这是一个简短的程序，它将一个物体在地球上的重量（任何单位），打印一个漂亮的表格，显示该物体在所有八个行星上的重量（以相同单位）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class WeightTable &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      double earthWeight = Double.parseDouble(args[0]);</span><br><span class="line">      double mass = earthWeight / Planet.EARTH.surfaceGravity();</span><br><span class="line">      for (Planet p : Planet.values())</span><br><span class="line">          System.out.printf(&quot;Weight on %s is %f%n&quot;,</span><br><span class="line">                            p, p.surfaceWeight(mass));</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意，<code>Planet</code>和所有枚举一样，都有一个静态<code>values</code>方法，该方法以声明的顺序返回其值的数组。 另请注意，<code>toString</code>方法返回每个枚举值的声明名称，使<code>println</code>和<code>printf</code>可以轻松打印。 如果你对此字符串表示形式不满意，可以通过重写<code>toString</code>方法来更改它。 这是使用命令行参数185运行<code>WeightTable</code>程序（不重写toString）的结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Weight on MERCURY is 69.912739</span><br><span class="line">Weight on VENUS is 167.434436</span><br><span class="line">Weight on EARTH is 185.000000</span><br><span class="line">Weight on MARS is 70.226739</span><br><span class="line">Weight on JUPITER is 467.990696</span><br><span class="line">Weight on SATURN is 197.120111</span><br><span class="line">Weight on URANUS is 167.398264</span><br><span class="line">Weight on NEPTUNE is 210.208751</span><br></pre></td></tr></table></figure>
<p>直到2006年，在Java中加入枚举两年之后，冥王星不再是一颗行星。 这引发了一个问题：“当你从枚举类型中移除一个元素时会发生什么？”答案是，任何不引用移除元素的客户端程序都将继续正常工作。 所以，举例来说，我们的<code>WeightTable</code>程序只需要打印一行少一行的表格。 什么是客户端程序引用删除的元素（在这种情况下，<code>Planet.Pluto</code>）？ 如果重新编译客户端程序，编译将会失败并在引用前一个星球的行处提供有用的错误消息; 如果无法重新编译客户端，它将在运行时从此行中引发有用的异常。 这是你所希望的最好的行为，远远好于你用int枚举模式得到的结果。</p>
<p>一些与枚举常量相关的行为只需要在定义枚举的类或包中使用。 这些行为最好以私有或包级私有方式实现。 然后每个常量携带一个隐藏的行为集合，允许包含枚举的类或包在与常量一起呈现时作出适当的反应。 与其他类一样，除非你有一个令人信服的理由将枚举方法暴露给它的客户端，否则将其声明为私有的，如果需要的话将其声明为包级私有（条目 15）。</p>
<p>如果一个枚举是广泛使用的，它应该是一个顶级类; 如果它的使用与特定的顶级类绑定，它应该是该顶级类的成员类（条目 24）。 例如，<code>java.math.RoundingMode</code>枚举表示小数部分的舍入模式。 <code>BigDecimal</code>类使用了这些舍入模式，但它们提供了一种有用的抽象，它并不与<code>BigDecimal</code>有根本的联系。 通过将<code>RoundingMode</code>设置为顶层枚举，类库设计人员鼓励任何需要舍入模式的程序员重用此枚举，从而提高跨API的一致性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// Enum type that switches on its own value - questionable</span><br><span class="line">public enum Operation &#123;</span><br><span class="line">    PLUS, MINUS, TIMES, DIVIDE;</span><br><span class="line"></span><br><span class="line">    // Do the arithmetic operation represented by this constant</span><br><span class="line">    public double apply(double x, double y) &#123;</span><br><span class="line">        switch(this) &#123;</span><br><span class="line">            case PLUS:   return x + y;</span><br><span class="line">            case MINUS:  return x - y;</span><br><span class="line">            case TIMES:  return x * y;</span><br><span class="line">            case DIVIDE: return x / y;</span><br><span class="line">        &#125;</span><br><span class="line">        throw new AssertionError(&quot;Unknown op: &quot; + this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此代码有效，但不是很漂亮。 如果没有<code>throw</code>语句，就不能编译，因为该方法的结束在技术上是可达到的，尽管它永远不会被达到[JLS，14.21]。 更糟的是，代码很脆弱。 如果添加新的枚举常量，但忘记向switch语句添加相应的条件，枚举仍然会编译，但在尝试应用新操作时，它将在运行时失败。</p>
<p>幸运的是，有一种更好的方法可以将不同的行为与每个枚举常量关联起来：在枚举类型中声明一个抽象的<code>apply</code>方法，并用常量特定的类主体中的每个常量的具体方法重写它。 这种方法被称为特定于常量（constant-specific）的方法实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// Enum type with constant-specific method implementations</span><br><span class="line">public enum Operation &#123;</span><br><span class="line">  PLUS  &#123;public double apply(double x, double y)&#123;return x + y;&#125;&#125;,</span><br><span class="line">  MINUS &#123;public double apply(double x, double y)&#123;return x - y;&#125;&#125;,</span><br><span class="line">  TIMES &#123;public double apply(double x, double y)&#123;return x * y;&#125;&#125;,</span><br><span class="line">  DIVIDE&#123;public double apply(double x, double y)&#123;return x / y;&#125;&#125;;</span><br><span class="line"></span><br><span class="line">  public abstract double apply(double x, double y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果向第二个版本的操作添加新的常量，则不太可能会忘记提供<code>apply</code>方法，因为该方法紧跟在每个常量声明之后。 万一忘记了，编译器会提醒你，因为枚举类型中的抽象方法必须被所有常量中的具体方法重写。</p>
<p>特定于常量的方法实现可以与特定于常量的数据结合使用。 例如，以下是<code>Operation</code>的一个版本，它重写<code>toString</code>方法以返回通常与该操作关联的符号：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// Enum type with constant-specific class bodies and data</span><br><span class="line">public enum Operation &#123;</span><br><span class="line">    PLUS(&quot;+&quot;) &#123;</span><br><span class="line">        public double apply(double x, double y) &#123; return x + y; &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    MINUS(&quot;-&quot;) &#123;</span><br><span class="line">        public double apply(double x, double y) &#123; return x - y; &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    TIMES(&quot;*&quot;) &#123;</span><br><span class="line">        public double apply(double x, double y) &#123; return x * y; &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    DIVIDE(&quot;/&quot;) &#123;</span><br><span class="line">        public double apply(double x, double y) &#123; return x / y; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private final String symbol;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Operation(String symbol) &#123; this.symbol = symbol; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override public String toString() &#123; return symbol; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public abstract double apply(double x, double y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显示的<code>toString</code>实现可以很容易地打印算术表达式，正如这个小程序所展示的那样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    double x = Double.parseDouble(args[0]);</span><br><span class="line">    double y = Double.parseDouble(args[1]);</span><br><span class="line">    for (Operation op : Operation.values())</span><br><span class="line">        System.out.printf(&quot;%f %s %f = %f%n&quot;,</span><br><span class="line">                          x, op, y, op.apply(x, y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以2和4作为命令行参数运行此程序会生成以下输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2.000000 + 4.000000 = 6.000000</span><br><span class="line">2.000000 - 4.000000 = -2.000000</span><br><span class="line">2.000000 * 4.000000 = 8.000000</span><br><span class="line">2.000000 / 4.000000 = 0.500000</span><br></pre></td></tr></table></figure>
<p>枚举类型具有自动生成的<code>valueOf(String)</code>方法，该方法将常量名称转换为常量本身。 如果在枚举类型中重写<code>toString</code>方法，请考虑编写<code>fromString</code>方法将自定义字符串表示法转换回相应的枚举类型。 下面的代码（类型名称被适当地改变）将对任何枚举都有效，只要每个常量具有唯一的字符串表示形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// Implementing a fromString method on an enum type</span><br><span class="line">private static final Map&lt;String, Operation&gt; stringToEnum =</span><br><span class="line">        Stream.of(values()).collect(</span><br><span class="line">            toMap(Object::toString, e -&gt; e));</span><br><span class="line"></span><br><span class="line">// Returns Operation for string, if any</span><br><span class="line">public static Optional&lt;Operation&gt; fromString(String symbol) &#123;</span><br><span class="line">    return Optional.ofNullable(stringToEnum.get(symbol));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意，<code>Operation</code>枚举常量被放在<code>stringToEnum</code>的map中，它来自于创建枚举常量后运行的静态属性初始化。前面的代码在<code>values()</code>方法返回的数组上使用流（第7章）；在Java 8之前，我们创建一个空的<code>hashMap</code>并遍历值数组，将字符串到枚举映射插入到map中，如果愿意，仍然可以这样做。但请注意，尝试让每个常量都将自己放入来自其构造方法的map中不起作用。这会导致编译错误，这是好事，因为如果它是合法的，它会在运行时导致<code>NullPointerException</code>。除了编译时常量属性（条目 34）之外，枚举构造方法不允许访问枚举的静态属性。此限制是必需的，因为静态属性在枚举构造方法运行时尚未初始化。这种限制的一个特例是枚举常量不能从构造方法中相互访问。</p>
<p>另请注意，<code>fromString</code>方法返回一个<code>Optional&lt;String&gt;</code>。 这允许该方法指示传入的字符串不代表有效的操作，并且强制客户端面对这种可能性（条目 55）。</p>
<p>特定于常量的方法实现的一个缺点是它们使得难以在枚举常量之间共享代码。 例如，考虑一个代表工资包中的工作天数的枚举。 该枚举有一个方法，根据工人的基本工资（每小时）和当天工作的分钟数计算当天工人的工资。 在五个工作日内，任何超过正常工作时间的工作都会产生加班费; 在两个周末的日子里，所有工作都会产生加班费。 使用switch语句，通过将多个<code>case</code>标签应用于两个代码片段中的每一个，可以轻松完成此计算：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// Enum that switches on its value to share code - questionable</span><br><span class="line">enum PayrollDay &#123;</span><br><span class="line">    MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY,</span><br><span class="line">    SATURDAY, SUNDAY;</span><br><span class="line"></span><br><span class="line">    private static final int MINS_PER_SHIFT = 8 * 60;</span><br><span class="line"></span><br><span class="line">    int pay(int minutesWorked, int payRate) &#123;</span><br><span class="line">        int basePay = minutesWorked * payRate;</span><br><span class="line"></span><br><span class="line">        int overtimePay;</span><br><span class="line">        switch(this) &#123;</span><br><span class="line">          case SATURDAY: case SUNDAY: // Weekend</span><br><span class="line">            overtimePay = basePay / 2;</span><br><span class="line">            break;</span><br><span class="line">          default: // Weekday</span><br><span class="line">            overtimePay = minutesWorked &lt;= MINS_PER_SHIFT ?</span><br><span class="line">              0 : (minutesWorked - MINS_PER_SHIFT) * payRate / 2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return basePay + overtimePay;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码无可否认是简洁的，但从维护的角度来看是危险的。 假设你给枚举添加了一个元素，可能是一个特殊的值来表示一个假期，但忘记在switch语句中添加一个相应的case条件。 该程序仍然会编译，但付费方法会默默地为工作日支付相同数量的休假日，与普通工作日相同。</p>
<p>要使用特定于常量的方法实现安全地执行工资计算，必须为每个常量重复加班工资计算，或将计算移至两个辅助方法，一个用于工作日，另一个用于周末，并调用适当的辅助方法来自每个常量。 这两种方法都会产生相当数量的样板代码，大大降低了可读性并增加了出错机会。</p>
<p>通过使用执行加班计算的具体方法替换<code>PayrollDay</code>上的抽象<code>overtimePa</code>y方法，可以减少样板。 那么只有周末的日子必须重写该方法。 但是，这与switch语句具有相同的缺点：如果在不重写<code>overtimePay</code>方法的情况下添加另一天，则会默默继承周日计算方式。</p>
<p>你真正想要的是每次添加枚举常量时被迫选择加班费策略。 幸运的是，有一个很好的方法来实现这一点。 这个想法是将加班费计算移入私有嵌套枚举中，并将此策略枚举的实例传递给<code>PayrollDay</code>枚举的构造方法。 然后，<code>PayrollDay</code>枚举将加班工资计算委托给策略枚举，从而无需在<code>PayrollDay</code>中实现switch语句或特定于常量的方法实现。 虽然这种模式不如switch语句简洁，但它更安全，更灵活：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">// The strategy enum pattern</span><br><span class="line">enum PayrollDay &#123;</span><br><span class="line">    MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY,</span><br><span class="line">    SATURDAY(PayType.WEEKEND), SUNDAY(PayType.WEEKEND);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private final PayType payType;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    PayrollDay(PayType payType) &#123; this.payType = payType; &#125;</span><br><span class="line">    PayrollDay() &#123; this(PayType.WEEKDAY); &#125;  // Default</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    int pay(int minutesWorked, int payRate) &#123;</span><br><span class="line">        return payType.pay(minutesWorked, payRate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // The strategy enum type</span><br><span class="line">    private enum PayType &#123;</span><br><span class="line">        WEEKDAY &#123;</span><br><span class="line">            int overtimePay(int minsWorked, int payRate) &#123;</span><br><span class="line">                return minsWorked &lt;= MINS_PER_SHIFT ? 0 :</span><br><span class="line">                  (minsWorked - MINS_PER_SHIFT) * payRate / 2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        WEEKEND &#123;</span><br><span class="line">            int overtimePay(int minsWorked, int payRate) &#123;</span><br><span class="line">                return minsWorked * payRate / 2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        abstract int overtimePay(int mins, int payRate);</span><br><span class="line">        private static final int MINS_PER_SHIFT = 8 * 60;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        int pay(int minsWorked, int payRate) &#123;</span><br><span class="line">            int basePay = minsWorked * payRate;</span><br><span class="line">            return basePay + overtimePay(minsWorked, payRate);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果对枚举的switch语句不是实现常量特定行为的好选择，那么它们有什么好处呢?枚举类型的switch有利于用常量特定的行为增加枚举类型。例如，假设<code>Operation</code>枚举不在你的控制之下，你希望它有一个实例方法来返回每个相反的操作。你可以用以下静态方法模拟效果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// Switch on an enum to simulate a missing method</span><br><span class="line">public static Operation inverse(Operation op) &#123;</span><br><span class="line">    switch(op) &#123;</span><br><span class="line">        case PLUS:   return Operation.MINUS;</span><br><span class="line">        case MINUS:  return Operation.PLUS;</span><br><span class="line">        case TIMES:  return Operation.DIVIDE;</span><br><span class="line">        case DIVIDE: return Operation.TIMES;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        default:  throw new AssertionError(&quot;Unknown op: &quot; + op);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果某个方法不属于枚举类型，则还应该在你控制的枚举类型上使用此技术。 该方法可能需要用于某些用途，但通常不足以用于列入枚举类型。</p>
<p>一般而言，枚举通常在性能上与int常数相当。 枚举的一个小小的性能缺点是加载和初始化枚举类型存在空间和时间成本，但在实践中不太可能引人注意。</p>
<p>那么你应该什么时候使用枚举呢？ 任何时候使用枚举都需要一组常量，这些常量的成员在编译时已知。 当然，这包括“天然枚举类型”，如行星，星期几和棋子。 但是它也包含了其它你已经知道编译时所有可能值的集合，例如菜单上的选项，操作代码和命令行标志。<strong> 一个枚举类型中的常量集不需要一直保持不变</strong>。 枚举功能是专门设计用于允许二进制兼容的枚举类型的演变。</p>
<p>总之，枚举类型优于int常量的优点是令人信服的。 枚举更具可读性，更安全，更强大。 许多枚举不需要显式构造方法或成员，但其他人则可以通过将数据与每个常量关联并提供行为受此数据影响的方法而受益。 使用单一方法关联多个行为可以减少枚举。 在这种相对罕见的情况下，更喜欢使用常量特定的方法来枚举自己的值。 如果一些（但不是全部）枚举常量共享共同行为，请考虑策略枚举模式。</p>
<h2 id="35-使用实例属性替代序数"><a href="#35-使用实例属性替代序数" class="headerlink" title="35. 使用实例属性替代序数"></a>35. 使用实例属性替代序数</h2><p>许多枚举通常与单个int值关联。所有枚举都有一个<code>ordinal</code>方法，它返回每个枚举常量类型的数值位置。你可能想从序数中派生一个关联的int值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// Abuse of ordinal to derive an associated value - DON&apos;T DO THIS</span><br><span class="line"></span><br><span class="line">public enum Ensemble &#123;</span><br><span class="line"></span><br><span class="line">    SOLO,   DUET,   TRIO, QUARTET, QUINTET,</span><br><span class="line"></span><br><span class="line">    SEXTET, SEPTET, OCTET, NONET,  DECTET;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public int numberOfMusicians() &#123; return ordinal() + 1; &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然这个枚举能正常工作，但对于维护来说则是一场噩梦。如果常量被重新排序，<code>numberOfMusicians</code>方法将会中断。 如果你想添加一个与你已经使用的int值相关的第二个枚举常量，则没有那么好运了。 例如，为双四重奏（double quartet）添加一个常量可能会很好，它就像八重奏一样，由8位演奏家组成，但是没有办法做到这一点。</p>
<p>此外，如果没有给所有这些int值添加常量，也不能为某个int值添加一个常量。例如，假设你想要添加一个常量，表示一个由12位演奏家组成的三重四重奏（triple quartet）。对于由11个演奏家组成的合奏曲，并没有标准的术语，因此你不得不为未使用的int值（11）添加一个虚拟常量（dummy constant）。最多看起来就是有些不好看。如果许多int值是未使用的，则是不切实际的。</p>
<p>幸运的是，这些问题有一个简单的解决方案。 <strong>永远不要从枚举的序号中得出与它相关的值; 请将其保存在实例属性中</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public enum Ensemble &#123;</span><br><span class="line"></span><br><span class="line">    SOLO(1), DUET(2), TRIO(3), QUARTET(4), QUINTET(5),</span><br><span class="line"></span><br><span class="line">    SEXTET(6), SEPTET(7), OCTET(8), DOUBLE_QUARTET(8),</span><br><span class="line"></span><br><span class="line">    NONET(9), DECTET(10), TRIPLE_QUARTET(12);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private final int numberOfMusicians;</span><br><span class="line"></span><br><span class="line">    Ensemble(int size) &#123; this.numberOfMusicians = size; &#125;</span><br><span class="line"></span><br><span class="line">    public int numberOfMusicians() &#123; return numberOfMusicians; &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>枚举规范对此<code>ordinal</code>方法说道：“大多数程序员对这种方法没有用处。 它被设计用于基于枚举的通用数据结构，如<code>EnumSet</code>和<code>EnumMap</code>。“除非你在编写这样数据结构的代码，否则最好避免使用<code>ordinal</code>方法。</p>

      
    </div>
    <footer class="article-footer">
      <ul class="article-meta">
        <li>
          <span class="label">Published Date:</span>
          <a href="/2018/05/09/effective-java-cn-31-35/" class="article-date">
  <time datetime="2018-05-09T01:26:02.000Z" itemprop="datePublished">2018-05-09</time>
</a>

        </li>
        
          <li>
            <span class="label">Category:</span>
            
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>
  </div>


          </li>
        
        
        <hr/>
      </ul>
    </footer>
  </div>
  
    
<nav id="article-nav" class="article-nav">
  
    <a href="/2018/05/09/effective-java-cn-36-37/" id="article-nav-newer" class="article-nav-link-wrap newer">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Effective Java 中文版(item:36-37)
        
      </div>
    </a>
  
  
    <a href="/2018/05/09/effective-java-cn-26-30/" id="article-nav-older" class="article-nav-link-wrap older">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Effective Java 中文版(item:26-30)</div>
    </a>
  
</nav>


  
</article>








      </div>
      
    <footer id="footer" class="post-footer footer">
      
      <hr/>
      <div id="footerContent" class="footer-content">
        <p>如需联系,可以前往我的<a href="https://github.com/yuanwai">Github</a>留言,或者电邮:<a href="mailto:lxdhzzj@gmial.com">lxdhzzj@gmial.com</a></p>


      </div>
    </footer>

      





<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/1.5.10/clipboard.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/typing.js"></script>
<!--[if lt IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script><![endif]-->







    </div>
  </body>
</html>
