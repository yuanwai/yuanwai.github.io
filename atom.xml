<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>员外在减肥</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://luxiangdong.com/"/>
  <updated>2018-05-09T03:10:20.544Z</updated>
  <id>http://luxiangdong.com/</id>
  
  <author>
    <name>Xiangdong Lu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Effective Java 中文版(item:36-37)</title>
    <link href="http://luxiangdong.com/2018/05/09/effective-java-cn-36-37/"/>
    <id>http://luxiangdong.com/2018/05/09/effective-java-cn-36-37/</id>
    <published>2018-05-09T01:26:23.000Z</published>
    <updated>2018-05-09T03:10:20.544Z</updated>
    
    <content type="html"><![CDATA[<h2 id="36-使用EnumSet替代位属性"><a href="#36-使用EnumSet替代位属性" class="headerlink" title="36. 使用EnumSet替代位属性"></a>36. 使用EnumSet替代位属性</h2><p>如果枚举类型的元素主要用于集合中，一般来说使用int枚举模式（条目 34），下面将2的不同倍数赋值给每个常量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// Bit field enumeration constants - OBSOLETE!</span><br><span class="line">public class Text &#123;</span><br><span class="line">    public static final int STYLE_BOLD          = 1 &lt;&lt; 0;  // 1</span><br><span class="line">    public static final int STYLE_ITALIC        = 1 &lt;&lt; 1;  // 2</span><br><span class="line">    public static final int STYLE_UNDERLINE     = 1 &lt;&lt; 2;  // 4</span><br><span class="line">    public static final int STYLE_STRIKETHROUGH = 1 &lt;&lt; 3;  // 8</span><br><span class="line"></span><br><span class="line">    // Parameter is bitwise OR of zero or more STYLE_ constants</span><br><span class="line">    public void applyStyles(int styles) &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种表示方式允许你使用按位或（or）运算将几个常量合并到一个称为位属性（bit field）的集合中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">text.applyStyles(STYLE_BOLD | STYLE_ITALIC);</span><br></pre></td></tr></table></figure><p>位属性表示还允许你使用按位算术有效地执行集合运算，如并集和交集。 但是位属性具有int枚举常量等的所有缺点。 当打印为数字时，解释位属性比简单的int枚举常量更难理解。 没有简单的方法遍历所有由位属性表示的元素。 最后，必须预测在编写API时需要的最大位数，并相应地为位属性（通常为int或long）选择一种类型。 一旦你选择了一个类型，你就不能超过它的宽度（32或64位）而不改变API。</p><p>一些程序员使用枚举优于int常量，当他们需要传递常量集合时仍然使用位属性。 没有理由这样做，因为存在更好的选择。 java.util包提供了<code>EnumSet</code>类来有效地表示从单个枚举类型中提取的值集合。 这个类实现了Set接口，提供了所有其他Set实现的丰富性，类型安全性和互操作性。 但是在内部，每个EnumSet都表示为一个位矢量（bit vector）。 如果底层的枚举类型有64个或更少的元素，并且大多数情况下，整个<code>EnumSet</code>用单个long表示，所以它的性能与位属性的性能相当。 批量操作（如removeAll和retainAll）是使用按位算术实现的，就像你为位属性手动操作一样。 但是完全避免了手动位混乱的丑陋和错误倾向：<code>EnumSet</code>为你做了很大的努力。</p><p>下面是前一个使用枚举和枚举集合替代位属性的示例。 它更短，更清晰，更安全：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// EnumSet - a modern replacement for bit fields</span><br><span class="line">public class Text &#123;</span><br><span class="line">    public enum Style &#123; BOLD, ITALIC, UNDERLINE, STRIKETHROUGH &#125;</span><br><span class="line"></span><br><span class="line">    // Any Set could be passed in, but EnumSet is clearly best</span><br><span class="line">    public void applyStyles(Set&lt;Style&gt; styles) &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是将<code>EnumSet</code>实例传递给applyStyles方法的客户端代码。 <code>EnumSet</code>类提供了一组丰富的静态工厂，可以轻松创建集合，其中一个代码如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">text.applyStyles(EnumSet.of(Style.BOLD, Style.ITALIC));</span><br></pre></td></tr></table></figure><p>请注意，<code>applyStyles</code>方法采用<code>Set&lt;Style&gt;</code>而不是<code>EnumSet&lt;Style&gt;</code>参数。 尽管所有客户端都可能会将<code>EnumSet</code>传递给该方法，但接受接口类型而不是实现类型通常是很好的做法（条目 64）。 这允许一个不寻常的客户端通过其他Set实现的可能性。</p><p>总之，<strong>仅仅因为枚举类型将被用于集合中，所以没有理由用位属性来表示它</strong>。 <code>EnumSet</code>类将位属性的简洁性和性能与条目 34中所述的枚举类型的所有优点相结合。<code>EnumSet</code>的一个真正缺点是，它不像Java 9那样创建一个不可变的<code>EnumSet</code>，但是在即将发布的版本中可能会得到补救。 同时，你可以用<code>Collections.unmodifiableSet</code>封装一个<code>EnumSet</code>，但是简洁性和性能会受到影响。</p><h2 id="37-使用EnumMap替代序数索引"><a href="#37-使用EnumMap替代序数索引" class="headerlink" title="37. 使用EnumMap替代序数索引"></a>37. 使用EnumMap替代序数索引</h2><p>有时可能会看到使用<code>ordinal</code>方法（条目 35）来索引到数组或列表的代码。 例如，考虑一下这个简单的类来代表一种植物：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Plant &#123;</span><br><span class="line">    enum LifeCycle &#123; ANNUAL, PERENNIAL, BIENNIAL &#125;</span><br><span class="line">    final String name;</span><br><span class="line">    final LifeCycle lifeCycle;</span><br><span class="line"></span><br><span class="line">    Plant(String name, LifeCycle lifeCycle) &#123;</span><br><span class="line">        [this.name](http://this.name) = name;</span><br><span class="line">        this.lifeCycle = lifeCycle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override public String toString() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在假设你有一组植物代表一个花园，想要列出这些由生命周期组织的植物(一年生，多年生，或双年生)。为此，需要构建三个集合，每个生命周期作为一个，并遍历整个花园，将每个植物放置在适当的集合中。一些程序员可以通过将这些集合放入一个由生命周期序数索引的数组中来实现这一点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// Using ordinal() to index into an array - DON&apos;T DO THIS!</span><br><span class="line"></span><br><span class="line">Set&lt;Plant&gt;[] plantsByLifeCycle =</span><br><span class="line"></span><br><span class="line">    (Set&lt;Plant&gt;[]) new Set[Plant.LifeCycle.values().length];</span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt; plantsByLifeCycle.length; i++)</span><br><span class="line"></span><br><span class="line">    plantsByLifeCycle[i] = new HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">for (Plant p : garden)</span><br><span class="line"></span><br><span class="line">    plantsByLifeCycle[p.lifeCycle.ordinal()].add(p);</span><br><span class="line"></span><br><span class="line">// Print the results</span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt; plantsByLifeCycle.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">    System.out.printf(&quot;%s: %s%n&quot;,</span><br><span class="line"></span><br><span class="line">        Plant.LifeCycle.values()[i], plantsByLifeCycle[i]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法是有效的，但充满了问题。 因为数组不兼容泛型（条目 28），程序需要一个未经检查的转换，并且不会干净地编译。 由于该数组不知道索引代表什么，因此必须手动标记索引输出。 但是这种技术最严重的问题是，当你访问一个由枚举序数索引的数组时，你有责任使用正确的int值; int不提供枚举的类型安全性。 如果你使用了错误的值，程序会默默地做错误的事情，如果你幸运的话，抛出一个<code>ArrayIndexOutOfBoundsException</code>异常。</p><p>有一个更好的方法来达到同样的效果。 该数组有效地用作从枚举到值的映射，因此不妨使用Map。 更具体地说，有一个非常快速的Map实现，设计用于枚举键，称为<code>java.util.EnumMap</code>。 下面是当程序重写为使用<code>EnumMap</code>时的样子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Using an EnumMap to associate data with an enum</span><br><span class="line"></span><br><span class="line">Map&lt;Plant.LifeCycle, Set&lt;Plant&gt;&gt;  plantsByLifeCycle =</span><br><span class="line"></span><br><span class="line">    new EnumMap&lt;&gt;(Plant.LifeCycle.class);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;36-使用EnumSet替代位属性&quot;&gt;&lt;a href=&quot;#36-使用EnumSet替代位属性&quot; class=&quot;headerlink&quot; title=&quot;36. 使用EnumSet替代位属性&quot;&gt;&lt;/a&gt;36. 使用EnumSet替代位属性&lt;/h2&gt;&lt;p&gt;如果枚举类型的元
      
    
    </summary>
    
      <category term="java" scheme="http://luxiangdong.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>Effective Java 中文版(item:31-35)</title>
    <link href="http://luxiangdong.com/2018/05/09/effective-java-cn-31-35/"/>
    <id>http://luxiangdong.com/2018/05/09/effective-java-cn-31-35/</id>
    <published>2018-05-09T01:26:02.000Z</published>
    <updated>2018-05-09T03:08:52.760Z</updated>
    
    <content type="html"><![CDATA[<h2 id="31-使用限定通配符来增加API的灵活性"><a href="#31-使用限定通配符来增加API的灵活性" class="headerlink" title="31. 使用限定通配符来增加API的灵活性"></a>31. 使用限定通配符来增加API的灵活性</h2><p>如条目 28所述，参数化类型是不变的。换句话说，对于任何两个不同类型的<code>Type1</code>和<code>Type</code>，<code>List &lt;Type1&gt;</code>既不是<code>List &lt;Type2&gt;</code>子类型也不是其父类型。尽管<code>List &lt;String&gt;</code>不是<code>List &lt;Object&gt;</code>的子类型是违反直觉的，但它确实是有道理的。 可以将任何对象放入<code>List &lt;Object&gt;</code>中，但是只能将字符串放入<code>List &lt;String&gt;</code>中。 由于<code>List &lt;String&gt;</code>不能做<code>List &lt;Object&gt;</code>所能做的所有事情，所以它不是一个子类型（条目 10 中的里氏替代原则）。</p><p>相对于提供的不可变的类型，有时你需要比此更多的灵活性。 考虑条目 29中的<code>Stack</code>类。下面是它的公共API：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Stack&lt;E&gt; &#123;</span><br><span class="line"></span><br><span class="line">    public Stack();</span><br><span class="line"></span><br><span class="line">    public void push(E e);</span><br><span class="line"></span><br><span class="line">    public E pop();</span><br><span class="line"></span><br><span class="line">    public boolean isEmpty();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设我们想要添加一个方法来获取一系列元素，并将它们全部推送到栈上。 以下是第一种尝试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// pushAll method without wildcard type - deficient!</span><br><span class="line"></span><br><span class="line">public void pushAll(Iterable&lt;E&gt; src) &#123;</span><br><span class="line">    for (E e : src)</span><br><span class="line">        push(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法可以干净地编译，但不完全令人满意。 如果可遍历的<code>src</code>元素类型与栈的元素类型完全匹配，那么它工作正常。 但是，假设有一个<code>Stack &lt;Number&gt;</code>，并调用<code>push(intVal)</code>，其中<code>intVal</code>的类型是<code>Integer</code>。 这是因为<code>Integer</code>是<code>Number</code>的子类型。 从逻辑上看，这似乎也应该起作用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;Number&gt; numberStack = new Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">Iterable&lt;Integer&gt; integers = ... ;</span><br><span class="line"></span><br><span class="line">numberStack.pushAll(integers);</span><br></pre></td></tr></table></figure><p>但是，如果你尝试了，会得到这个错误消息，因为参数化类型是不变的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">StackTest.java:7: error: incompatible types: Iterable&lt;Integer&gt;</span><br><span class="line"></span><br><span class="line">cannot be converted to Iterable&lt;Number&gt;</span><br><span class="line"></span><br><span class="line">        numberStack.pushAll(integers);</span><br><span class="line"></span><br><span class="line">                            ^</span><br></pre></td></tr></table></figure><p>幸运的是，有对应的解决方法。 该语言提供了一种特殊的参数化类型来调用一个限定通配符类型来处理这种情况。 <code>pushAll</code>的输入参数的类型不应该是“E的Iterable接口”，而应该是“E的某个子类型的Iterable接口”，并且有一个通配符类型，这意味着：<code>Iterable &lt;？ extends E&gt;</code>。 （关键字<code>extends</code>的使用有点误导：回忆条目 29中，子类型被定义为每个类型都是它自己的子类型，即使它本身没有继承。）让我们修改<code>pushAll</code>来使用这个类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Wildcard type for a parameter that serves as an E producer</span><br><span class="line"></span><br><span class="line">public void pushAll(Iterable&lt;? extends E&gt; src) &#123;</span><br><span class="line">    for (E e : src)</span><br><span class="line">        push(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了这个改变，<code>Stack</code>类不仅可以干净地编译，而且客户端代码也不会用原始的<code>pushAll</code>声明编译。 因为<code>Stack</code>和它的客户端干净地编译，你知道一切都是类型安全的。</p><p>现在假设你想写一个<code>popAll</code>方法，与<code>pushAll</code>方法相对应。 <code>popAll</code>方法从栈中弹出每个元素并将元素添加到给定的集合中。 以下是第一次尝试编写<code>popAll</code>方法的过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// popAll method without wildcard type - deficient!</span><br><span class="line"></span><br><span class="line">public void popAll(Collection&lt;E&gt; dst) &#123;</span><br><span class="line"></span><br><span class="line">    while (!isEmpty())</span><br><span class="line"></span><br><span class="line">        dst.add(pop());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样，如果目标集合的元素类型与栈的元素类型完全匹配，则干净编译并且工作正常。 但是，这又不完全令人满意。 假设你有一个<code>Stack &lt;Number&gt;</code>和<code>Object</code>类型的变量。 如果从栈中弹出一个元素并将其存储在该变量中，它将编译并运行而不会出错。 所以你也不能这样做吗？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;Number&gt; numberStack = new Stack&lt;Number&gt;();</span><br><span class="line"></span><br><span class="line">Collection&lt;Object&gt; objects = ... ;</span><br><span class="line"></span><br><span class="line">numberStack.popAll(objects);</span><br></pre></td></tr></table></figure><p>如果尝试将此客户端代码与之前显示的<code>popAll</code>版本进行编译，则会得到与我们的第一版<code>pushAll</code>非常类似的错误：<code>Collection &lt;Object&gt;</code>不是<code>Collection &lt;Number&gt;</code>的子类型。 通配符类型再一次提供了一条出路。 <code>popAll</code>的输入参数的类型不应该是“E的集合”，而应该是“E的某个父类型的集合”（其中父类型被定义为E是它自己的父类型[JLS，4.10]）。 再次，有一个通配符类型，正是这个意思：<code>Collection &lt;？ super E&gt;</code>。 让我们修改<code>popAll</code>来使用它：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// Wildcard type for parameter that serves as an E consumer</span><br><span class="line"></span><br><span class="line">public void popAll(Collection&lt;? super E&gt; dst) &#123;</span><br><span class="line"></span><br><span class="line">    while (!isEmpty())</span><br><span class="line"></span><br><span class="line">        dst.add(pop());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这个改动，Stack类和客户端代码都可以干净地编译。</p><p>这个结论很清楚。 <strong>为了获得最大的灵活性，对代表生产者或消费者的输入参数使用通配符类型</strong>。 如果一个输入参数既是一个生产者又是一个消费者，那么通配符类型对你没有好处：你需要一个精确的类型匹配，这就是没有任何通配符的情况。</p><p>这里有一个助记符来帮助你记住使用哪种通配符类型：<br><strong>PECS代表： producer-extends，consumer-super。</strong></p><p>换句话说，如果一个参数化类型代表一个<code>T</code>生产者，使用<code>&lt;? extends T&gt;</code>；如果它代表<code>T</code>消费者，则使用<code>&lt;? super T&gt;</code>。 在我们的<code>Stack</code>示例中，<code>pushAll</code>方法的<code>src</code>参数生成栈使用的<code>E</code>实例，因此<code>src</code>的合适类型为<code>Iterable&lt;? extends E&gt;</code>；<code>popAll</code>方法的<code>dst</code>参数消费<code>Stack</code>中的<code>E</code>实例，因此<code>ds</code>t的合适类型是<code>Collection &lt;？ super E&gt;</code>。 PECS助记符抓住了使用通配符类型的基本原则。 Naftalin和Wadler称之为获取和放置原则（ Get and Put Principle ）[Naftalin07,2.4]。</p><p>记住这个助记符之后，让我们来看看本章中以前项目的一些方法和构造方法声明。 条目 28中的<code>Chooser</code>类构造方法有这样的声明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public Chooser(Collection&lt;T&gt; choices)</span><br></pre></td></tr></table></figure><p>这个构造方法只使用集合选择来生产类型<code>T</code>的值（并将它们存储起来以备后用），所以它的声明应该使用一个<code>extends T</code>的通配符类型。下面是得到的构造方法声明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// Wildcard type for parameter that serves as an T producer</span><br><span class="line"></span><br><span class="line">public Chooser(Collection&lt;? extends T&gt; choices)</span><br></pre></td></tr></table></figure><p>这种改变在实践中会有什么不同吗？ 是的，会有不同。 假你有一个<code>List &lt;Integer&gt;</code>，并且想把它传递给<code>Chooser&lt;Number&gt;</code>的构造方法。 这不会与原始声明一起编译，但是它只会将限定通配符类型添加到声明中。</p><p>现在看看条目 30中的<code>union</code>方法。下是声明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;E&gt; Set&lt;E&gt; union(Set&lt;E&gt; s1, Set&lt;E&gt; s2)</span><br></pre></td></tr></table></figure><p>两个参数<code>s1</code>和<code>s2</code>都是<code>E</code>的生产者，所以PECS助记符告诉我们该声明应该如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;E&gt; Set&lt;E&gt; union(Set&lt;? extends E&gt; s1,  Set&lt;? extends E&gt; s2)</span><br></pre></td></tr></table></figure><p>请注意，返回类型仍然是<code>Set &lt;E&gt;</code>。 不要使用限定通配符类型作为返回类型。除了会为用户提供额外的灵活性，还强制他们在客户端代码中使用通配符类型。 通过修改后的声明，此代码将清晰地编译：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Integer&gt;  integers =  Set.of(1, 3, 5);</span><br><span class="line"></span><br><span class="line">Set&lt;Double&gt;   doubles  =  Set.of(2.0, 4.0, 6.0);</span><br><span class="line"></span><br><span class="line">Set&lt;Number&gt;   numbers  =  union(integers, doubles);</span><br></pre></td></tr></table></figure><p>如果使用得当，类的用户几乎不会看到通配符类型。 他们使方法接受他们应该接受的参数，拒绝他们应该拒绝的参数。 <strong>如果一个类的用户必须考虑通配符类型，那么它的API可能有问题。</strong></p><p>在Java 8之前，类型推断规则不够聪明，无法处理先前的代码片段，这要求编译器使用上下文指定的返回类型（或目标类型）来推断<code>E</code>的类型。<code>union</code>方法调用的目标类型如前所示是<code>Set &lt;Number&gt;</code>。 如果尝试在早期版本的Java中编译片段（以及适合的<code>Set.of</code>工厂替代版本），将会看到如此长的错综复杂的错误消息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Union.java:14: error: incompatible types</span><br><span class="line"></span><br><span class="line">        Set&lt;Number&gt; numbers = union(integers, doubles);</span><br><span class="line"></span><br><span class="line">                                   ^</span><br><span class="line"></span><br><span class="line">  required: Set&lt;Number&gt;</span><br><span class="line"></span><br><span class="line">  found:    Set&lt;INT#1&gt;</span><br><span class="line"></span><br><span class="line">  where INT#1,INT#2 are intersection types:</span><br><span class="line"></span><br><span class="line">    INT#1 extends Number,Comparable&lt;? extends INT#2&gt;</span><br><span class="line"></span><br><span class="line">    INT#2 extends Number,Comparable&lt;?&gt;</span><br></pre></td></tr></table></figure><p>幸运的是有办法来处理这种错误。 如果编译器不能推断出正确的类型，你可以随时告诉它使用什么类型的显式类型参数[JLS，15.12]。 甚至在Java 8中引入目标类型之前，这不是你必须经常做的事情，这很好，因为显式类型参数不是很漂亮。 通过添加显式类型参数，如下所示，代码片段在Java 8之前的版本中进行了干净编译：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// Explicit type parameter - required prior to Java 8</span><br><span class="line"></span><br><span class="line">Set&lt;Number&gt; numbers = Union.&lt;Number&gt;union(integers, doubles);</span><br></pre></td></tr></table></figure><p>接下来让我们把注意力转向条目 30中的<code>max</code>方法。这里是原始声明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T extends Comparable&lt;T&gt;&gt; T max(List&lt;T&gt; list)</span><br></pre></td></tr></table></figure><p>以下是使用通配符类型的修改后的声明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T extends Comparable&lt;? super T&gt;&gt; T max(List&lt;? extends T&gt; list)</span><br></pre></td></tr></table></figure><p>为了从原来到修改后的声明，我们两次应用了PECS。首先直接的应用是参数列表。 它生成<code>T</code>实例，所以将类型从<code>List &lt;T&gt;</code>更改为<code>List&lt;? extends T&gt;</code>。 棘手的应用是类型参数<code>T</code>。这是我们第一次看到通配符应用于类型参数。 最初，<code>T</code>被指定为继承<code>Comparable &lt;T&gt;</code>，但<code>Comparable</code>的<code>T</code>消费<code>T</code>实例（并生成指示顺序关系的整数）。 因此，参数化类型<code>Comparable &lt;T&gt;</code>被替换为限定通配符类型<code>Comparable&lt;? super T&gt;</code>。 <code>Comparable</code>实例总是消费者，所以通常应该<strong>使用Comparable&lt;? super T&gt;优于Comparable <t></t></strong>。 <code>Comparator</code>也是如此。因此，通常应该<strong>使用Comparator&lt;? super T&gt;优于Comparator<t></t></strong>。</p><p>修改后的<code>max</code>声明可能是本书中最复杂的方法声明。 增加的复杂性是否真的起作用了吗？ 同样，它的确如此。 这是一个列表的简单例子，它被原始声明排除，但在被修改后的版本里是允许的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;ScheduledFuture&lt;?&gt;&gt; scheduledFutures = ... ;</span><br></pre></td></tr></table></figure><p>无法将原始方法声明应用于此列表的原因是<code>ScheduledFuture</code>不实现<code>Comparable &lt;ScheduledFuture&gt;</code>。 相反，它是<code>Delayed</code>的子接口，它继承了<code>Comparable &lt;Delayed&gt;</code>。 换句话说，一个<code>ScheduledFuture</code>实例不仅仅和其他的<code>ScheduledFuture</code>实例相比较： 它可以与任何<code>Delayed</code>实例比较，并且足以导致原始的声明拒绝它。 更普遍地说，通配符要求来支持没有直接实现<code>Comparable</code>（或<code>Comparator</code>）的类型，但继承了一个类型。</p><p>还有一个关于通配符相关的话题。 类型参数和通配符之间具有双重性，许多方法可以用一个或另一个声明。 例如，下面是两个可能的声明，用于交换列表中两个索引项目的静态方法。 第一个使用无限制类型参数（条目 30），第二个使用无限制通配符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Two possible declarations for the swap method</span><br><span class="line"></span><br><span class="line">public static &lt;E&gt; void swap(List&lt;E&gt; list, int i, int j);</span><br><span class="line"></span><br><span class="line">public static void swap(List&lt;?&gt; list, int i, int j);</span><br></pre></td></tr></table></figure><p>这两个声明中的哪一个更可取，为什么？ 在公共API中，第二个更好，因为它更简单。 你传入一个列表（任何列表），该方法交换索引的元素。 没有类型参数需要担心。 通常，<strong>如果类型参数在方法声明中只出现一次，请将其替换为通配符</strong>。 如果它是一个无限制的类型参数，请将其替换为无限制的通配符; 如果它是一个限定类型参数，则用限定通配符替换它。</p><p>第二个<code>swap</code>方法声明有一个问题。 这个简单的实现不会编译：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static void swap(List&lt;?&gt; list, int i, int j) &#123;</span><br><span class="line">    list.set(i, list.set(j, list.get(i)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>试图编译它会产生这个不太有用的错误信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Swap.java:5: error: incompatible types: Object cannot be</span><br><span class="line"></span><br><span class="line">converted to CAP#1</span><br><span class="line"></span><br><span class="line">        list.set(i, list.set(j, list.get(i)));</span><br><span class="line"></span><br><span class="line">                                        ^</span><br><span class="line"></span><br><span class="line">  where CAP#1 is a fresh type-variable:</span><br><span class="line"></span><br><span class="line">    CAP#1 extends Object from capture of ?</span><br></pre></td></tr></table></figure><p>看起来我们不能把一个元素放回到我们刚刚拿出来的列表中。 问题是列表的类型是<code>List &lt;？&gt;</code>，并且不能将除null外的任何值放入<code>List &lt;？&gt;</code>中。 幸运的是，有一种方法可以在不使用不安全的转换或原始类型的情况下实现此方法。 这个想法是写一个私有辅助方法来捕捉通配符类型。 辅助方法必须是泛型方法才能捕获类型。 以下是它的定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static void swap(List&lt;?&gt; list, int i, int j) &#123;</span><br><span class="line"></span><br><span class="line">    swapHelper(list, i, j);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Private helper method for wildcard capture</span><br><span class="line"></span><br><span class="line">private static &lt;E&gt; void swapHelper(List&lt;E&gt; list, int i, int j) &#123;</span><br><span class="line"></span><br><span class="line">    list.set(i, list.set(j, list.get(i)));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>swapHelper</code>方法知道该列表是一个<code>List &lt;E&gt;</code>。 因此，它知道从这个列表中获得的任何值都是E类型，并且可以安全地将任何类型的<code>E</code>值放入列表中。 这个稍微复杂的<code>swap</code>的实现可以干净地编译。 它允许我们导出基于通配符的漂亮声明，同时利用内部更复杂的泛型方法。 <code>swap</code>方法的客户端不需要面对更复杂的<code>swapHelper</code>声明，但他们从中受益。 辅助方法具有我们认为对公共方法来说过于复杂的签名。</p><p>总之，在你的API中使用通配符类型，虽然棘手，但使得API更加灵活。 如果编写一个将被广泛使用的类库，正确使用通配符类型应该被认为是强制性的。 记住基本规则： producer-extends, consumer-super（PECS）。 还要记住，所有<code>Comparable</code>和<code>Comparator</code>都是消费者。</p><h2 id="32-合理地结合泛型和可变参数"><a href="#32-合理地结合泛型和可变参数" class="headerlink" title="32. 合理地结合泛型和可变参数"></a>32. 合理地结合泛型和可变参数</h2><p>在Java 5中，可变参数方法（条目 53）和泛型都被添加到平台中，所以你可能希望它们能够正常交互; 可悲的是，他们并没有。 可变参数的目的是允许客户端将一个可变数量的参数传递给一个方法，但这是一个脆弱的抽象（ leaky abstraction）：当你调用一个可变参数方法时，会创建一个数组来保存可变参数；那个应该是实现细节的数组是可见的。 因此，当可变参数具有泛型或参数化类型时，会导致编译器警告混淆。</p><p>回顾条目 28，非具体化（ non-reifiable）的类型是其运行时表示比其编译时表示具有更少信息的类型，并且几乎所有泛型和参数化类型都是不可具体化的。 如果某个方法声明其可变参数为非具体化的类型，则编译器将在该声明上生成警告。 如果在推断类型不可确定的可变参数参数上调用该方法，那么编译器也会在调用中生成警告。 警告看起来像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">warning: [unchecked] Possible heap pollution from</span><br><span class="line">    parameterized vararg type List&lt;String&gt;</span><br></pre></td></tr></table></figure><p>当参数化类型的变量引用不属于该类型的对象时会发生堆污染（Heap pollution）[JLS，4.12.2]。 它会导致编译器的自动生成的强制转换失败，违反了泛型类型系统的基本保证。</p><p>例如，请考虑以下方法，该方法是第127页上的代码片段的一个不太明显的变体：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// Mixing generics and varargs can violate type safety!</span><br><span class="line">static void dangerous(List&lt;String&gt;... stringLists) &#123;</span><br><span class="line">    List&lt;Integer&gt; intList = List.of(42);</span><br><span class="line">    Object[] objects = stringLists;</span><br><span class="line">    objects[0] = intList;             // Heap pollution</span><br><span class="line">    String s = stringLists[0].get(0); // ClassCastException</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此方法没有可见的强制转换，但在调用一个或多个参数时抛出ClassCastException异常。 它的最后一行有一个由编译器生成的隐形转换。 这种转换失败，表明类型安全性已经被破坏，并且<strong>将值保存在泛型可变参数数组参数中是不安全的</strong>。</p><p>这个例子引发了一个有趣的问题：为什么声明一个带有泛型可变参数的方法是合法的，当明确创建一个泛型数组是非法的时候呢？ 换句话说，为什么前面显示的方法只生成一个警告，而127页上的代码片段会生成一个错误？ 答案是，具有泛型或参数化类型的可变参数参数的方法在实践中可能非常有用，因此语言设计人员选择忍受这种不一致。 事实上，Java类库导出了几个这样的方法，包括<code>Arrays.asList(T... a)</code>，<code>Collections.addAll(Collection&lt;? super T&gt; c, T... elements)</code>，<code>EnumSet.of(E first, E... rest)</code>。 与前面显示的危险方法不同，这些类库方法是类型安全的。</p><p>在Java 7中，<code>SafeVarargs</code>注解已添加到平台，以允许具有泛型可变参数的方法的作者自动禁止客户端警告。 实质上，<strong>SafeVarargs注解构成了作者对类型安全的方法的承诺</strong>。 为了交换这个承诺，编译器同意不要警告用户调用可能不安全的方法。</p><p>除非它实际上是安全的，否则注意不要使用<code>@SafeVarargs</code>注解标注一个方法。 那么需要做些什么来确保这一点呢？ 回想一下，调用方法时会创建一个泛型数组，以容纳可变参数。 如果方法没有在数组中存储任何东西（它会覆盖参数）并且不允许对数组的引用进行转义（这会使不受信任的代码访问数组），那么它是安全的。 换句话说，如果可变参数数组仅用于从调用者向方法传递可变数量的参数——毕竟这是可变参数的目的——那么该方法是安全的。</p><p>值得注意的是，你可以违反类型安全性，即使不会在可变参数数组中存储任何内容。 考虑下面的泛型可变参数方法，它返回一个包含参数的数组。 乍一看，它可能看起来像一个方便的小工具：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// UNSAFE - Exposes a reference to its generic parameter array!</span><br><span class="line">static &lt;T&gt; T[] toArray(T... args) &#123;</span><br><span class="line">    return args;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法只是返回它的可变参数数组。 该方法可能看起来并不危险，但它是！ 该数组的类型由传递给方法的参数的编译时类型决定，编译器可能没有足够的信息来做出正确的判断。 由于此方法返回其可变参数数组，它可以将堆污染传播到调用栈上。</p><p>为了具体说明，请考虑下面的泛型方法，它接受三个类型<code>T</code>的参数，并返回一个包含两个参数的数组，随机选择：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static &lt;T&gt; T[] pickTwo(T a, T b, T c) &#123;</span><br><span class="line">    switch(ThreadLocalRandom.current().nextInt(3)) &#123;</span><br><span class="line">      case 0: return toArray(a, b);</span><br><span class="line">      case 1: return toArray(a, c);</span><br><span class="line">      case 2: return toArray(b, c);</span><br><span class="line">    &#125;</span><br><span class="line">    throw new AssertionError(); // Can&apos;t get here</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法本身不是危险的，除了调用具有泛型可变参数的<code>toArray</code>方法之外，不会产生警告。</p><p>编译此方法时，编译器会生成代码以创建一个将两个<code>T</code>实例传递给<code>toArray</code>的可变参数数组。 这段代码分配了一个<code>Object []</code>类型的数组，它是保证保存这些实例的最具体的类型，而不管在调用位置传递给<code>pickTwo</code>的对象是什么类型。 <code>toArray</code>方法只是简单地将这个数组返回给<code>pickTwo</code>，然后<code>pickTwo</code>将它返回给调用者，所以<code>pickTwo</code>总是返回一个<code>Object []</code>类型的数组。</p><p>现在考虑这个测试<code>pickTw</code>的<code>main</code>方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    String[] attributes = pickTwo(&quot;Good&quot;, &quot;Fast&quot;, &quot;Cheap&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法没有任何问题，因此它编译时不会产生任何警告。 但是当运行它时，抛出一个ClassCastException异常，尽管不包含可见的转换。 你没有看到的是，编译器已经生成了一个隐藏的强制转换为由<code>pickTwo</code>返回的值的<code>String []</code>类型，以便它可以存储在属性中。 转换失败，因为<code>Object []</code>不是<code>String []</code>的子类型。 这种故障相当令人不安，因为它从实际导致堆污染（<code>toArray</code>）的方法中移除了两个级别，并且在实际参数存储在其中之后，可变参数数组未被修改。</p><p>这个例子是为了让人们认识到<strong>给另一个方法访问一个泛型的可变参数数组是不安全的</strong>，除了两个例外：将数组传递给另一个可变参数方法是安全的，这个方法是用<code>@SafeVarargs</code>正确标注的， 将数组传递给一个非可变参数的方法是安全的，该方法仅计算数组内容的一些方法。</p><p>这里是安全使用泛型可变参数的典型示例。 此方法将任意数量的列表作为参数，并按顺序返回包含所有输入列表元素的单个列表。 由于该方法使用<code>@SafeVarargs</code>进行标注，因此在声明或其调用站位置上不会生成任何警告：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// Safe method with a generic varargs parameter</span><br><span class="line">@SafeVarargs</span><br><span class="line">static &lt;T&gt; List&lt;T&gt; flatten(List&lt;? extends T&gt;... lists) &#123;</span><br><span class="line">    List&lt;T&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line">    for (List&lt;? extends T&gt; list : lists)</span><br><span class="line">        result.addAll(list);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>决定何时使用<code>SafeVarargs</code>注解的规则很简单：在每种方法上使用<code>@SafeVarargs</code>，并使用泛型或参数化类型的可变参数，这样用户就不会因不必要的和令人困惑的编译器警告而担忧。 这意味着你不应该写危险或者<code>toArray</code>等不安全的可变参数方法。 每次编译器警告你可能会受到来自你控制的方法中泛型可变参数的堆污染时，请检查该方法是否安全。 提醒一下，在下列情况下，泛型可变参数方法是安全的：<br>1.它不会在可变参数数组中存储任何东西</p><p>2.它不会使数组（或克隆）对不可信代码可见。 如果违反这些禁令中的任何一项，请修复。</p><p>请注意，<code>SafeVarargs</code>注解只对不能被重写的方法是合法的，因为不可能保证每个可能的重写方法都是安全的。 在Java 8中，注解仅在静态方法和final实例方法上合法; 在Java 9中，它在私有实例方法中也变为合法。</p><p>使用<code>SafeVarargs</code>注解的替代方法是采用条目 28的建议，并用<code>List</code>参数替换可变参数（这是一个变相的数组）。 下面是应用于我们的<code>flatten</code>方法时，这种方法的样子。 请注意，只有参数声明被更改了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// List as a typesafe alternative to a generic varargs parameter</span><br><span class="line">static &lt;T&gt; List&lt;T&gt; flatten(List&lt;List&lt;? extends T&gt;&gt; lists) &#123;</span><br><span class="line">    List&lt;T&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line">    for (List&lt;? extends T&gt; list : lists)</span><br><span class="line">        result.addAll(list);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后可以将此方法与静态工厂方法<code>List.of</code>结合使用，以允许可变数量的参数。 请注意，这种方法依赖于<code>List.of</code>声明使用<code>@SafeVarargs</code>注解：<br>audience = flatten(List.of(friends, romans, countrymen));</p><p>这种方法的优点是编译器可以证明这种方法是类型安全的。 不必使用<code>SafeVarargs</code>注解来证明其安全性，也不用担心在确定安全性时可能会犯错。 主要缺点是客户端代码有点冗长，运行可能会慢一些。</p><p>这个技巧也可以用在不可能写一个安全的可变参数方法的情况下，就像第147页的<code>toArray</code>方法那样。它的列表模拟是<code>List.of</code>方法，所以我们甚至不必编写它; Java类库作者已经为我们完成了这项工作。 <code>pickTwo</code>方法然后变成这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static &lt;T&gt; List&lt;T&gt; pickTwo(T a, T b, T c) &#123;</span><br><span class="line">    switch(rnd.nextInt(3)) &#123;</span><br><span class="line">      case 0: return List.of(a, b);</span><br><span class="line">      case 1: return List.of(a, c);</span><br><span class="line">      case 2: return List.of(b, c);</span><br><span class="line">    &#125;</span><br><span class="line">    throw new AssertionError();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>main</code>方变成这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;String&gt; attributes = pickTwo(&quot;Good&quot;, &quot;Fast&quot;, &quot;Cheap&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成的代码是类型安全的，因为它只使用泛型，不是数组。</p><p>总而言之，可变参数和泛型不能很好地交互，因为可变参数机制是在数组上面构建的脆弱的抽象，并且数组具有与泛型不同的类型规则。 虽然泛型可变参数不是类型安全的，但它们是合法的。 如果选择使用泛型（或参数化）可变参数编写方法，请首先确保该方法是类型安全的，然后使用<code>@SafeVarargs</code>注解对其进行标注，以免造成使用不愉快。</p><h2 id="33-优先考虑类型安全的异构容器"><a href="#33-优先考虑类型安全的异构容器" class="headerlink" title="33. 优先考虑类型安全的异构容器"></a>33. 优先考虑类型安全的异构容器</h2><p>泛型的常见用法包括集合，如<code>Set &lt;E&gt;</code>和<code>Map &lt;K，V&gt;</code>和单个元素容器，如<code>ThreadLocal &lt;T&gt;</code>和<code>AtomicReference &lt;T&gt;</code>。 在所有这些用途中，它都是参数化的容器。 这限制了每个容器只能有固定数量的类型参数。 通常这正是你想要的。 一个<code>Set</code>有单一的类型参数，表示它的元素类型; 一个<code>Map</code>有两个，代表它的键和值的类型；等等。</p><p>然而有时候，你需要更多的灵活性。 例如，数据库一行记录可以具有任意多列，并且能够以类型安全的方式访问它们是很好的。 幸运的是，有一个简单的方法可以达到这个效果。 这个想法是参数化键（key）而不是容器。 然后将参数化的键提交给容器以插入或检索值。 泛型类型系统用于保证值的类型与其键一致。</p><p>作为这种方法的一个简单示例，请考虑一个Favorites类，它允许其客户端保存和检索任意多种类型的<code>favorite</code>实例。 该类型的Class对象将扮演参数化键的一部分。其原因是这<code>Class</code>类是泛型的。 类的类型从字面上来说不是简单的<code>Class</code>，而是<code>Class &lt;T&gt;</code>。 例如，<code>String.class</code>的类型为<code>Class &lt;String&gt;</code>，<code>Integer.class的</code>类型为<code>Class &lt;Integer&gt;</code>。 当在方法中传递字面类传递编译时和运行时类型信息时，它被称为类型令牌（type token）[Bracha04]。</p><p><code>Favorites</code>类的API很简单。 它看起来就像一个简单Map类，除了该键是参数化的以外。 客户端在设置和获取<code>favorites</code>实例时呈现一个Class对象。 这里是API：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Typesafe heterogeneous container pattern - API</span><br><span class="line">public class Favorites &#123;</span><br><span class="line">    public &lt;T&gt; void putFavorite(Class&lt;T&gt; type, T instance);</span><br><span class="line">    public &lt;T&gt; T getFavorite(Class&lt;T&gt; type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是一个演示<code>Favorites</code>类，保存，检索和打印喜欢的<code>String</code>，<code>Integer</code>和<code>Class</code>实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// Typesafe heterogeneous container pattern - client</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">    Favorites f = new Favorites();</span><br><span class="line"></span><br><span class="line">    f.putFavorite(String.class, &quot;Java&quot;);</span><br><span class="line"></span><br><span class="line">    f.putFavorite(Integer.class, 0xcafebabe);</span><br><span class="line"></span><br><span class="line">    f.putFavorite(Class.class, Favorites.class);</span><br><span class="line"></span><br><span class="line">     String favoriteString = f.getFavorite(String.class);</span><br><span class="line"></span><br><span class="line">    int favoriteInteger = f.getFavorite(Integer.class);</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; favoriteClass = f.getFavorite(Class.class);</span><br><span class="line"></span><br><span class="line">    System.out.printf(&quot;%s %x %s%n&quot;, favoriteString,</span><br><span class="line"></span><br><span class="line">        favoriteInteger, favoriteClass.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如你所期望的，这个程序打印<code>Java cafebabe Favorites</code>。 请注意，顺便说一下，Java的<code>printf</code>方法与C语言的不同之处在于，应该使用<code>％n</code>，而在C中使用<code>\n</code>。<code>％n</code>生成适用的特定于平台的行分隔符，该分隔符在很多但不是所有平台上都是<code>\n</code>。</p><p><code>Favorites</code>实例是类型安全的：当你请求一个字符串时它永远不会返回一个整数。 它也是异构的：与普通Map不同，所有的键都是不同的类型。 因此，我们将<code>Favorites</code>称为类型安全异构容器（typesafe heterogeneous container.）。</p><p><code>Favorites</code>的实现非常小巧。 这是完整的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// Typesafe heterogeneous container pattern - implementation</span><br><span class="line">public class Favorites &#123;</span><br><span class="line">    private Map&lt;Class&lt;?&gt;, Object&gt; favorites = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public &lt;T&gt; void putFavorite(Class&lt;T&gt; type, T instance) &#123;</span><br><span class="line">        favorites.put(Objects.requireNonNull(type), instance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public &lt;T&gt; T getFavorite(Class&lt;T&gt; type) &#123;</span><br><span class="line">        return type.cast(favorites.get(type));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有一些微妙的事情发生。 每个<code>Favorites</code>实例都由一个名为<code>favorites</code>私有的<code>Map&lt;Class&lt;?&gt;, Object&gt;</code>来支持。 你可能认为无法将任何内容放入此Map中，因为这是无限定的通配符类型，但事实恰恰相反。 需要注意的是通配符类型是嵌套的：它不是通配符类型的Map类型，而是键的类型。 这意味着每个键都可以有不同的参数化类型：一个可以是<code>Class &lt;String&gt;</code>，下一个<code>Class &lt;Integer&gt;</code>等等。 这就是异构的由来。</p><p>接下来要注意的是，favorites的Map的值类型只是Object。 换句话说，Map不保证键和值之间的类型关系，即每个值都是由其键表示的类型。 事实上，Java的类型系统并不足以表达这一点。 但是我们知道这是真的，并在检索一个favorite时利用了这点。</p><p><code>putFavorite</code>实现很简单：只需将给定的Class对象映射到给定的favorites的实例即可。 如上所述，这丢弃了键和值之间的“类型联系（type linkage）”；无法知道这个值是不是键的一个实例。 但没关系，因为<code>getFavorites</code>方法可以并且确实重新建立这种关联。</p><p><code>getFavorite</code>的实现比<code>putFavorite</code>更复杂。 首先，它从favorites Map中获取与给定Class对象相对应的值。 这是返回的正确对象引用，但它具有错误的编译时类型：它是Object（favorites map的值类型），我们需要返回类型<code>T</code>。因此，<code>getFavorite</code>实现动态地将对象引用转换为Class对象表示的类型，使用Class的<code>cast</code>方法。</p><p><code>cast</code>方法是Java的cast操作符的动态模拟。它只是检查它的参数是否由Class对象表示的类型的实例。如果是，它返回参数；否则会抛出<code>ClassCastException</code>异常。我们知道，假设客户端代码能够干净地编译，<code>getFavorite</code>中的强制转换不会抛出<code>ClassCastException</code>异常。 也就是说，favorites map中的值始终与其键的类型相匹配。</p><p>那么这个<code>cast</code>方法为我们做了什么，因为它只是返回它的参数？ <code>cast</code>的签名充分利用了Class类是泛型的事实。 它的返回类型是Class对象的类型参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class Class&lt;T&gt; &#123;</span><br><span class="line">    T cast(Object obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这正是<code>getFavorite</code>方法所需要的。 这正是确保Favorites类型安全，而不用求助一个未经检查的强制转换的<code>T</code>类型。</p><p>Favorites类有两个限制值得注意。 首先，恶意客户可以通过使用原始形式的Class对象，轻松破坏Favorites实例的类型安全。 但生成的客户端代码在编译时会生成未经检查的警告。 这与正常的集合实现（如HashSet和HashMap）没有什么不同。 通过使用原始类型HashSet（条目 26），可以轻松地将字符串放入<code>HashSet &lt;Integer&gt;</code>中。 也就是说，如果你愿意为此付出一点代价，就可以拥有运行时类型安全性。 确保Favorites永远不违反类型不变的方法是，使<code>putFavorite</code>方法检查该实例是否由type表示类型的实例，并且我们已经知道如何执行此操作。只需使用动态转换：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Achieving runtime type safety with a dynamic cast</span><br><span class="line">public &lt;T&gt; void putFavorite(Class&lt;T&gt; type, T instance) &#123;</span><br><span class="line">    favorites.put(type, type.cast(instance));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>java.util.Collections</code>中有一些集合包装类，可以发挥相同的诀窍。 它们被称为<code>checkedSet</code>，<code>checkedList</code>，<code>checkedMap</code>等等。 他们的静态工厂除了一个集合（或Map）之外还有一个Class对象（或两个）。 静态工厂是泛型方法，确保Class对象和集合的编译时类型匹配。 包装类为它们包装的集合添加了具体化。 例如，如果有人试图将<code>Coin</code>放入你的<code>Collection &lt;Stamp&gt;</code>中，则包装类在运行时会抛出<code>ClassCastException</code>。 这些包装类对于追踪在混合了泛型和原始类型的应用程序中添加不正确类型的元素到集合的客户端代码很有用。</p><p>Favorites类的第二个限制是它不能用于不可具体化的（non-reifiable）类型（条目 28）。 换句话说，你可以保存你最喜欢的<code>String</code>或<code>String []</code>，但不能保存<code>List &lt;String&gt;</code>。 如果你尝试保存你最喜欢的<code>List &lt;String&gt;</code>，程序将不能编译。 原因是无法获取<code>List &lt;String&gt;</code>的Class对象。 <code>List &lt;String&gt; .class</code>是语法错误，也是一件好事。 <code>List &lt;String&gt;</code>和<code>List &lt;Integer&gt;</code>共享一个Class对象，即<code>List.class</code>。 如果“字面类型（type literals）”<code>List &lt;String&gt; .class</code>和<code>List &lt;Integer&gt; .class</code>合法并返回相同的对象引用，那么它会对Favorites对象的内部造成严重破坏。 对于这种限制，没有完全令人满意的解决方法。</p><p>Favorites使用的类型令牌( type tokens)是无限制的：<code>getFavorite</code>和<code>putFavorite</code>接受任何Class对象。 有时你可能需要限制可传递给方法的类型。 这可以通过一个有限定的类型令牌来实现，该令牌只是一个类型令牌，它使用限定的类型参数（条目 30）或限定的通配符（条目 31）来放置可以表示的类型的边界。</p><p>注解API（条目 39）广泛使用限定类型的令牌。 例如，以下是在运行时读取注解的方法。 此方法来自<code>AnnotatedElement</code>接口，该接口由表示类，方法，属性和其他程序元素的反射类型实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T extends Annotation&gt;</span><br><span class="line">    T getAnnotation(Class&lt;T&gt; annotationType);</span><br></pre></td></tr></table></figure><p>参数<code>annotationType</code>是表示注解类型的限定类型令牌。 该方法返回该类型的元素的注解（如果它有一个）；如果没有，则返回null。 本质上，注解元素是一个类型安全的异构容器，其键是注解类型。</p><p>假设有一个<code>Class &lt;?&gt;</code>类型的对象，并且想要将它传递给需要限定类型令牌（如<code>getAnnotation</code>）的方法。 可以将对象转换为<code>Class&lt;? extends Annotation&gt;</code>，但是这个转换没有被检查，所以它会产生一个编译时警告（条目 27）。 幸运的是，Class类提供了一种安全（动态）执行这种类型转换的实例方法。 该方法被称为<code>asSubclass</code>，并且它转换所调用的Class对象来表示由其参数表示的类的子类。 如果转换成功，该方法返回它的参数；如果失败，则抛出<code>ClassCastException</code>异常。</p><p>以下是如何使用<code>asSubclass</code>方法在编译时读取类型未知的注解。 此方法编译时没有错误或警告：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// Use of asSubclass to safely cast to a bounded type token</span><br><span class="line">static Annotation getAnnotation(AnnotatedElement element,</span><br><span class="line">                                String annotationTypeName) &#123;</span><br><span class="line">    Class&lt;?&gt; annotationType = null; // Unbounded type token</span><br><span class="line">    try &#123;</span><br><span class="line">        annotationType = Class.forName(annotationTypeName);</span><br><span class="line">    &#125; catch (Exception ex) &#123;</span><br><span class="line">        throw new IllegalArgumentException(ex);</span><br><span class="line">    &#125;</span><br><span class="line">    return element.getAnnotation(</span><br><span class="line">        annotationType.asSubclass(Annotation.class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总之，泛型API的通常用法（以集合API为例）限制了每个容器的固定数量的类型参数。 你可以通过将类型参数放在键上而不是容器上来解决此限制。 可以使用Class对象作为此类型安全异构容器的键。 以这种方式使用的Class对象称为类型令牌。 也可以使用自定义键类型。 例如，可以有一个表示数据库行（容器）的<code>DatabaseRow</code>类型和一个泛型类型<code>Column &lt;T&gt;</code>作为其键。</p><h2 id="34-使用枚举类型替代整型常量"><a href="#34-使用枚举类型替代整型常量" class="headerlink" title="34. 使用枚举类型替代整型常量"></a>34. 使用枚举类型替代整型常量</h2><p>枚举是其合法值由一组固定的常量组成的一种类型，例如一年中的季节，太阳系中的行星或一副扑克牌中的套装。 在将枚举类型添加到该语言之前，表示枚举类型的常见模式是声明一组名为int的常量，每个类型的成员都有一个常量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// The int enum pattern - severely deficient!</span><br><span class="line">public static final int APPLE_FUJI         = 0;</span><br><span class="line">public static final int APPLE_PIPPIN       = 1;</span><br><span class="line">public static final int APPLE_GRANNY_SMITH = 2;</span><br><span class="line">public static final int ORANGE_NAVEL  = 0;</span><br><span class="line">public static final int ORANGE_TEMPLE = 1;</span><br><span class="line">public static final int ORANGE_BLOOD  = 2;</span><br></pre></td></tr></table></figure><p>这种被称为int枚举模式的技术有许多缺点。 它没有提供类型安全的方式，也没有提供任何表达力。 如果你将一个Apple传递给一个需要Orange的方法，那么编译器不会出现警告，还会用<code>==</code>运算符比较Apple与Orange，或者更糟糕的是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// Tasty citrus flavored applesauce!</span><br><span class="line">int i = (APPLE_FUJI - ORANGE_TEMPLE) / APPLE_PIPPIN;</span><br></pre></td></tr></table></figure><p>请注意，每个Apple常量的名称前缀为<code>APPLE_</code>，每个<code>Orange</code>常量的名称前缀为<code>ORANGE_</code>。 这是因为Java不为int枚举组提供名称空间。 当两个int枚举组具有相同的命名常量时，前缀可以防止名称冲突，例如在<code>ELEMENT_MERCURY</code>和<code>PLANET_MERCURY</code>之间。</p><p>使用int枚举的程序很脆弱。 因为int枚举是编译时常量[JLS，4.12.4]，所以它们的int值被编译到使用它们的客户端中[JLS，13.1]。 如果与int枚举关联的值发生更改，则必须重新编译其客户端。 如果没有，客户仍然会运行，但他们的行为将是不正确的。</p><p>没有简单的方法将int枚举常量转换为可打印的字符串。 如果你打印这样一个常量或者从调试器中显示出来，你看到的只是一个数字，这不是很有用。 没有可靠的方法来迭代组中的所有int枚举常量，甚至无法获得int枚举组的大小。</p><p>你可能会遇到这种模式的变体，其中使用了字符串常量来代替int常量。 这种称为字符串枚举模式的变体更不理想。 尽管它为常量提供了可打印的字符串，但它可以导致初级用户将字符串常量硬编码为客户端代码，而不是使用属性名称。 如果这种硬编码的字符串常量包含书写错误，它将在编译时逃脱检测并导致运行时出现错误。 此外，它可能会导致性能问题，因为它依赖于字符串比较。</p><p>幸运的是，Java提供了一种避免int和String枚举模式的所有缺点的替代方法，并提供了许多额外的好处。 它是枚举类型[JLS，8.9]。 以下是它最简单的形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public enum Apple  &#123; FUJI, PIPPIN, GRANNY_SMITH &#125;</span><br><span class="line">public enum Orange &#123; NAVEL, TEMPLE, BLOOD &#125;</span><br></pre></td></tr></table></figure><p>从表面上看，这些枚举类型可能看起来与其他语言类似，比如C，C ++和C＃，但事实并非如此。 Java的枚举类型是完整的类，比其他语言中的其他语言更强大，其枚举本质本上是int值。</p><p>Java枚举类型背后的基本思想很简单：它们是通过公共静态final属性为每个枚举常量导出一个实例的类。 由于没有可访问的构造方法，枚举类型实际上是final的。 由于客户既不能创建枚举类型的实例也不能继承它，除了声明的枚举常量外，不能有任何实例。 换句话说，枚举类型是实例控制的（第6页）。 它们是单例（条目 3）的泛型化，基本上是单元素的枚举。</p><p>枚举提供了编译时类型的安全性。 如果声明一个参数为Apple类型，则可以保证传递给该参数的任何非空对象引用是三个有效Apple值中的一个。 尝试传递错误类型的值将导致编译时错误，因为会尝试将一个枚举类型的表达式分配给另一个类型的变量，或者使用<code>==</code>运算符来比较不同枚举类型的值。</p><p>具有相同名称常量的枚举类型可以和平共存，因为每种类型都有其自己的名称空间。 可以在枚举类型中添加或重新排序常量，而无需重新编译其客户端，因为导出常量的属性在枚举类型与其客户端之间提供了一层隔离：常量值不会编译到客户端，因为它们位于int枚举模式中。 最后，可以通过调用其<code>toString</code>方法将枚举转换为可打印的字符串。</p><p>除了纠正int枚举的缺陷之外，枚举类型还允许添加任意方法和属性并实现任意接口。 它们提供了所有Object方法的高质量实现（第3章），它们实现了<code>Comparable</code>（条目 14）和<code>Serializable</code>（第12章），并针对枚举类型的可任意改变性设计了序列化方式。</p><p>那么，为什么你要添加方法或属性到一个枚举类型？ 对于初学者，可能想要将数据与其常量关联起来。 例如，我们的Apple和Orange类型可能会从返回水果颜色的方法或返回水果图像的方法中受益。 还可以使用任何看起来合适的方法来增强枚举类型。 枚举类型可以作为枚举常量的简单集合，并随着时间的推移而演变为全功能抽象。</p><p>对于丰富的枚举类型的一个很好的例子，考虑我们太阳系的八颗行星。 每个行星都有质量和半径，从这两个属性可以计算出它的表面重力。 从而在给定物体的质量下，计算出一个物体在行星表面上的重量。 下面是这个枚举类型。 每个枚举常量之后的括号中的数字是传递给其构造方法的参数。 在这种情况下，它们是地球的质量和半径：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// Enum type with data and behavior</span><br><span class="line">public enum Planet &#123;</span><br><span class="line">    MERCURY(3.302e+23, 2.439e6),</span><br><span class="line">    VENUS  (4.869e+24, 6.052e6),</span><br><span class="line">    EARTH  (5.975e+24, 6.378e6),</span><br><span class="line">    MARS   (6.419e+23, 3.393e6),</span><br><span class="line">    JUPITER(1.899e+27, 7.149e7),</span><br><span class="line">    SATURN (5.685e+26, 6.027e7),</span><br><span class="line">    URANUS (8.683e+25, 2.556e7),</span><br><span class="line">    NEPTUNE(1.024e+26, 2.477e7);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private final double mass;           // In kilograms</span><br><span class="line">    private final double radius;         // In meters</span><br><span class="line">    private final double surfaceGravity; // In m / s^2</span><br><span class="line">    // Universal gravitational constant in m^3 / kg s^2</span><br><span class="line">    private static final double G = 6.67300E-11;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // Constructor</span><br><span class="line">    Planet(double mass, double radius) &#123;</span><br><span class="line">        this.mass = mass;</span><br><span class="line">        this.radius = radius;</span><br><span class="line">        surfaceGravity = G * mass / (radius * radius);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public double mass()           &#123; return mass; &#125;</span><br><span class="line">    public double radius()         &#123; return radius; &#125;</span><br><span class="line">    public double surfaceGravity() &#123; return surfaceGravity; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public double surfaceWeight(double mass) &#123;</span><br><span class="line">        return mass * surfaceGravity;  // F = ma</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写一个丰富的枚举类型比如<code>Planet</code>很容易。 <strong>要将数据与枚举常量相关联，请声明实例属性并编写一个构造方法，构造方法带有数据并将数据保存在属性中</strong>。 枚举本质上是不变的，所以所有的属性都应该是final的（条目 17）。 属性可以是公开的，但最好将它们设置为私有并提供公共访问方法（条目16）。 在<code>Planet</code>的情况下，构造方法还计算和存储表面重力，但这只是一种优化。 每当重力被<code>SurfaceWeight</code>方法使用时，它可以从质量和半径重新计算出来，该方法返回它在由常数表示的行星上的重量。</p><p>虽然<code>Planet</code>枚举很简单，但它的功能非常强大。 这是一个简短的程序，它将一个物体在地球上的重量（任何单位），打印一个漂亮的表格，显示该物体在所有八个行星上的重量（以相同单位）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class WeightTable &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      double earthWeight = Double.parseDouble(args[0]);</span><br><span class="line">      double mass = earthWeight / Planet.EARTH.surfaceGravity();</span><br><span class="line">      for (Planet p : Planet.values())</span><br><span class="line">          System.out.printf(&quot;Weight on %s is %f%n&quot;,</span><br><span class="line">                            p, p.surfaceWeight(mass));</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，<code>Planet</code>和所有枚举一样，都有一个静态<code>values</code>方法，该方法以声明的顺序返回其值的数组。 另请注意，<code>toString</code>方法返回每个枚举值的声明名称，使<code>println</code>和<code>printf</code>可以轻松打印。 如果你对此字符串表示形式不满意，可以通过重写<code>toString</code>方法来更改它。 这是使用命令行参数185运行<code>WeightTable</code>程序（不重写toString）的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Weight on MERCURY is 69.912739</span><br><span class="line">Weight on VENUS is 167.434436</span><br><span class="line">Weight on EARTH is 185.000000</span><br><span class="line">Weight on MARS is 70.226739</span><br><span class="line">Weight on JUPITER is 467.990696</span><br><span class="line">Weight on SATURN is 197.120111</span><br><span class="line">Weight on URANUS is 167.398264</span><br><span class="line">Weight on NEPTUNE is 210.208751</span><br></pre></td></tr></table></figure><p>直到2006年，在Java中加入枚举两年之后，冥王星不再是一颗行星。 这引发了一个问题：“当你从枚举类型中移除一个元素时会发生什么？”答案是，任何不引用移除元素的客户端程序都将继续正常工作。 所以，举例来说，我们的<code>WeightTable</code>程序只需要打印一行少一行的表格。 什么是客户端程序引用删除的元素（在这种情况下，<code>Planet.Pluto</code>）？ 如果重新编译客户端程序，编译将会失败并在引用前一个星球的行处提供有用的错误消息; 如果无法重新编译客户端，它将在运行时从此行中引发有用的异常。 这是你所希望的最好的行为，远远好于你用int枚举模式得到的结果。</p><p>一些与枚举常量相关的行为只需要在定义枚举的类或包中使用。 这些行为最好以私有或包级私有方式实现。 然后每个常量携带一个隐藏的行为集合，允许包含枚举的类或包在与常量一起呈现时作出适当的反应。 与其他类一样，除非你有一个令人信服的理由将枚举方法暴露给它的客户端，否则将其声明为私有的，如果需要的话将其声明为包级私有（条目 15）。</p><p>如果一个枚举是广泛使用的，它应该是一个顶级类; 如果它的使用与特定的顶级类绑定，它应该是该顶级类的成员类（条目 24）。 例如，<code>java.math.RoundingMode</code>枚举表示小数部分的舍入模式。 <code>BigDecimal</code>类使用了这些舍入模式，但它们提供了一种有用的抽象，它并不与<code>BigDecimal</code>有根本的联系。 通过将<code>RoundingMode</code>设置为顶层枚举，类库设计人员鼓励任何需要舍入模式的程序员重用此枚举，从而提高跨API的一致性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// Enum type that switches on its own value - questionable</span><br><span class="line">public enum Operation &#123;</span><br><span class="line">    PLUS, MINUS, TIMES, DIVIDE;</span><br><span class="line"></span><br><span class="line">    // Do the arithmetic operation represented by this constant</span><br><span class="line">    public double apply(double x, double y) &#123;</span><br><span class="line">        switch(this) &#123;</span><br><span class="line">            case PLUS:   return x + y;</span><br><span class="line">            case MINUS:  return x - y;</span><br><span class="line">            case TIMES:  return x * y;</span><br><span class="line">            case DIVIDE: return x / y;</span><br><span class="line">        &#125;</span><br><span class="line">        throw new AssertionError(&quot;Unknown op: &quot; + this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此代码有效，但不是很漂亮。 如果没有<code>throw</code>语句，就不能编译，因为该方法的结束在技术上是可达到的，尽管它永远不会被达到[JLS，14.21]。 更糟的是，代码很脆弱。 如果添加新的枚举常量，但忘记向switch语句添加相应的条件，枚举仍然会编译，但在尝试应用新操作时，它将在运行时失败。</p><p>幸运的是，有一种更好的方法可以将不同的行为与每个枚举常量关联起来：在枚举类型中声明一个抽象的<code>apply</code>方法，并用常量特定的类主体中的每个常量的具体方法重写它。 这种方法被称为特定于常量（constant-specific）的方法实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// Enum type with constant-specific method implementations</span><br><span class="line">public enum Operation &#123;</span><br><span class="line">  PLUS  &#123;public double apply(double x, double y)&#123;return x + y;&#125;&#125;,</span><br><span class="line">  MINUS &#123;public double apply(double x, double y)&#123;return x - y;&#125;&#125;,</span><br><span class="line">  TIMES &#123;public double apply(double x, double y)&#123;return x * y;&#125;&#125;,</span><br><span class="line">  DIVIDE&#123;public double apply(double x, double y)&#123;return x / y;&#125;&#125;;</span><br><span class="line"></span><br><span class="line">  public abstract double apply(double x, double y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果向第二个版本的操作添加新的常量，则不太可能会忘记提供<code>apply</code>方法，因为该方法紧跟在每个常量声明之后。 万一忘记了，编译器会提醒你，因为枚举类型中的抽象方法必须被所有常量中的具体方法重写。</p><p>特定于常量的方法实现可以与特定于常量的数据结合使用。 例如，以下是<code>Operation</code>的一个版本，它重写<code>toString</code>方法以返回通常与该操作关联的符号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// Enum type with constant-specific class bodies and data</span><br><span class="line">public enum Operation &#123;</span><br><span class="line">    PLUS(&quot;+&quot;) &#123;</span><br><span class="line">        public double apply(double x, double y) &#123; return x + y; &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    MINUS(&quot;-&quot;) &#123;</span><br><span class="line">        public double apply(double x, double y) &#123; return x - y; &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    TIMES(&quot;*&quot;) &#123;</span><br><span class="line">        public double apply(double x, double y) &#123; return x * y; &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    DIVIDE(&quot;/&quot;) &#123;</span><br><span class="line">        public double apply(double x, double y) &#123; return x / y; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private final String symbol;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Operation(String symbol) &#123; this.symbol = symbol; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override public String toString() &#123; return symbol; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public abstract double apply(double x, double y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显示的<code>toString</code>实现可以很容易地打印算术表达式，正如这个小程序所展示的那样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    double x = Double.parseDouble(args[0]);</span><br><span class="line">    double y = Double.parseDouble(args[1]);</span><br><span class="line">    for (Operation op : Operation.values())</span><br><span class="line">        System.out.printf(&quot;%f %s %f = %f%n&quot;,</span><br><span class="line">                          x, op, y, op.apply(x, y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以2和4作为命令行参数运行此程序会生成以下输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2.000000 + 4.000000 = 6.000000</span><br><span class="line">2.000000 - 4.000000 = -2.000000</span><br><span class="line">2.000000 * 4.000000 = 8.000000</span><br><span class="line">2.000000 / 4.000000 = 0.500000</span><br></pre></td></tr></table></figure><p>枚举类型具有自动生成的<code>valueOf(String)</code>方法，该方法将常量名称转换为常量本身。 如果在枚举类型中重写<code>toString</code>方法，请考虑编写<code>fromString</code>方法将自定义字符串表示法转换回相应的枚举类型。 下面的代码（类型名称被适当地改变）将对任何枚举都有效，只要每个常量具有唯一的字符串表示形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// Implementing a fromString method on an enum type</span><br><span class="line">private static final Map&lt;String, Operation&gt; stringToEnum =</span><br><span class="line">        Stream.of(values()).collect(</span><br><span class="line">            toMap(Object::toString, e -&gt; e));</span><br><span class="line"></span><br><span class="line">// Returns Operation for string, if any</span><br><span class="line">public static Optional&lt;Operation&gt; fromString(String symbol) &#123;</span><br><span class="line">    return Optional.ofNullable(stringToEnum.get(symbol));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，<code>Operation</code>枚举常量被放在<code>stringToEnum</code>的map中，它来自于创建枚举常量后运行的静态属性初始化。前面的代码在<code>values()</code>方法返回的数组上使用流（第7章）；在Java 8之前，我们创建一个空的<code>hashMap</code>并遍历值数组，将字符串到枚举映射插入到map中，如果愿意，仍然可以这样做。但请注意，尝试让每个常量都将自己放入来自其构造方法的map中不起作用。这会导致编译错误，这是好事，因为如果它是合法的，它会在运行时导致<code>NullPointerException</code>。除了编译时常量属性（条目 34）之外，枚举构造方法不允许访问枚举的静态属性。此限制是必需的，因为静态属性在枚举构造方法运行时尚未初始化。这种限制的一个特例是枚举常量不能从构造方法中相互访问。</p><p>另请注意，<code>fromString</code>方法返回一个<code>Optional&lt;String&gt;</code>。 这允许该方法指示传入的字符串不代表有效的操作，并且强制客户端面对这种可能性（条目 55）。</p><p>特定于常量的方法实现的一个缺点是它们使得难以在枚举常量之间共享代码。 例如，考虑一个代表工资包中的工作天数的枚举。 该枚举有一个方法，根据工人的基本工资（每小时）和当天工作的分钟数计算当天工人的工资。 在五个工作日内，任何超过正常工作时间的工作都会产生加班费; 在两个周末的日子里，所有工作都会产生加班费。 使用switch语句，通过将多个<code>case</code>标签应用于两个代码片段中的每一个，可以轻松完成此计算：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// Enum that switches on its value to share code - questionable</span><br><span class="line">enum PayrollDay &#123;</span><br><span class="line">    MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY,</span><br><span class="line">    SATURDAY, SUNDAY;</span><br><span class="line"></span><br><span class="line">    private static final int MINS_PER_SHIFT = 8 * 60;</span><br><span class="line"></span><br><span class="line">    int pay(int minutesWorked, int payRate) &#123;</span><br><span class="line">        int basePay = minutesWorked * payRate;</span><br><span class="line"></span><br><span class="line">        int overtimePay;</span><br><span class="line">        switch(this) &#123;</span><br><span class="line">          case SATURDAY: case SUNDAY: // Weekend</span><br><span class="line">            overtimePay = basePay / 2;</span><br><span class="line">            break;</span><br><span class="line">          default: // Weekday</span><br><span class="line">            overtimePay = minutesWorked &lt;= MINS_PER_SHIFT ?</span><br><span class="line">              0 : (minutesWorked - MINS_PER_SHIFT) * payRate / 2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return basePay + overtimePay;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码无可否认是简洁的，但从维护的角度来看是危险的。 假设你给枚举添加了一个元素，可能是一个特殊的值来表示一个假期，但忘记在switch语句中添加一个相应的case条件。 该程序仍然会编译，但付费方法会默默地为工作日支付相同数量的休假日，与普通工作日相同。</p><p>要使用特定于常量的方法实现安全地执行工资计算，必须为每个常量重复加班工资计算，或将计算移至两个辅助方法，一个用于工作日，另一个用于周末，并调用适当的辅助方法来自每个常量。 这两种方法都会产生相当数量的样板代码，大大降低了可读性并增加了出错机会。</p><p>通过使用执行加班计算的具体方法替换<code>PayrollDay</code>上的抽象<code>overtimePa</code>y方法，可以减少样板。 那么只有周末的日子必须重写该方法。 但是，这与switch语句具有相同的缺点：如果在不重写<code>overtimePay</code>方法的情况下添加另一天，则会默默继承周日计算方式。</p><p>你真正想要的是每次添加枚举常量时被迫选择加班费策略。 幸运的是，有一个很好的方法来实现这一点。 这个想法是将加班费计算移入私有嵌套枚举中，并将此策略枚举的实例传递给<code>PayrollDay</code>枚举的构造方法。 然后，<code>PayrollDay</code>枚举将加班工资计算委托给策略枚举，从而无需在<code>PayrollDay</code>中实现switch语句或特定于常量的方法实现。 虽然这种模式不如switch语句简洁，但它更安全，更灵活：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">// The strategy enum pattern</span><br><span class="line">enum PayrollDay &#123;</span><br><span class="line">    MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY,</span><br><span class="line">    SATURDAY(PayType.WEEKEND), SUNDAY(PayType.WEEKEND);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private final PayType payType;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    PayrollDay(PayType payType) &#123; this.payType = payType; &#125;</span><br><span class="line">    PayrollDay() &#123; this(PayType.WEEKDAY); &#125;  // Default</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    int pay(int minutesWorked, int payRate) &#123;</span><br><span class="line">        return payType.pay(minutesWorked, payRate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // The strategy enum type</span><br><span class="line">    private enum PayType &#123;</span><br><span class="line">        WEEKDAY &#123;</span><br><span class="line">            int overtimePay(int minsWorked, int payRate) &#123;</span><br><span class="line">                return minsWorked &lt;= MINS_PER_SHIFT ? 0 :</span><br><span class="line">                  (minsWorked - MINS_PER_SHIFT) * payRate / 2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        WEEKEND &#123;</span><br><span class="line">            int overtimePay(int minsWorked, int payRate) &#123;</span><br><span class="line">                return minsWorked * payRate / 2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        abstract int overtimePay(int mins, int payRate);</span><br><span class="line">        private static final int MINS_PER_SHIFT = 8 * 60;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        int pay(int minsWorked, int payRate) &#123;</span><br><span class="line">            int basePay = minsWorked * payRate;</span><br><span class="line">            return basePay + overtimePay(minsWorked, payRate);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果对枚举的switch语句不是实现常量特定行为的好选择，那么它们有什么好处呢?枚举类型的switch有利于用常量特定的行为增加枚举类型。例如，假设<code>Operation</code>枚举不在你的控制之下，你希望它有一个实例方法来返回每个相反的操作。你可以用以下静态方法模拟效果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// Switch on an enum to simulate a missing method</span><br><span class="line">public static Operation inverse(Operation op) &#123;</span><br><span class="line">    switch(op) &#123;</span><br><span class="line">        case PLUS:   return Operation.MINUS;</span><br><span class="line">        case MINUS:  return Operation.PLUS;</span><br><span class="line">        case TIMES:  return Operation.DIVIDE;</span><br><span class="line">        case DIVIDE: return Operation.TIMES;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        default:  throw new AssertionError(&quot;Unknown op: &quot; + op);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果某个方法不属于枚举类型，则还应该在你控制的枚举类型上使用此技术。 该方法可能需要用于某些用途，但通常不足以用于列入枚举类型。</p><p>一般而言，枚举通常在性能上与int常数相当。 枚举的一个小小的性能缺点是加载和初始化枚举类型存在空间和时间成本，但在实践中不太可能引人注意。</p><p>那么你应该什么时候使用枚举呢？ 任何时候使用枚举都需要一组常量，这些常量的成员在编译时已知。 当然，这包括“天然枚举类型”，如行星，星期几和棋子。 但是它也包含了其它你已经知道编译时所有可能值的集合，例如菜单上的选项，操作代码和命令行标志。<strong> 一个枚举类型中的常量集不需要一直保持不变</strong>。 枚举功能是专门设计用于允许二进制兼容的枚举类型的演变。</p><p>总之，枚举类型优于int常量的优点是令人信服的。 枚举更具可读性，更安全，更强大。 许多枚举不需要显式构造方法或成员，但其他人则可以通过将数据与每个常量关联并提供行为受此数据影响的方法而受益。 使用单一方法关联多个行为可以减少枚举。 在这种相对罕见的情况下，更喜欢使用常量特定的方法来枚举自己的值。 如果一些（但不是全部）枚举常量共享共同行为，请考虑策略枚举模式。</p><h2 id="35-使用实例属性替代序数"><a href="#35-使用实例属性替代序数" class="headerlink" title="35. 使用实例属性替代序数"></a>35. 使用实例属性替代序数</h2><p>许多枚举通常与单个int值关联。所有枚举都有一个<code>ordinal</code>方法，它返回每个枚举常量类型的数值位置。你可能想从序数中派生一个关联的int值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// Abuse of ordinal to derive an associated value - DON&apos;T DO THIS</span><br><span class="line"></span><br><span class="line">public enum Ensemble &#123;</span><br><span class="line"></span><br><span class="line">    SOLO,   DUET,   TRIO, QUARTET, QUINTET,</span><br><span class="line"></span><br><span class="line">    SEXTET, SEPTET, OCTET, NONET,  DECTET;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public int numberOfMusicians() &#123; return ordinal() + 1; &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然这个枚举能正常工作，但对于维护来说则是一场噩梦。如果常量被重新排序，<code>numberOfMusicians</code>方法将会中断。 如果你想添加一个与你已经使用的int值相关的第二个枚举常量，则没有那么好运了。 例如，为双四重奏（double quartet）添加一个常量可能会很好，它就像八重奏一样，由8位演奏家组成，但是没有办法做到这一点。</p><p>此外，如果没有给所有这些int值添加常量，也不能为某个int值添加一个常量。例如，假设你想要添加一个常量，表示一个由12位演奏家组成的三重四重奏（triple quartet）。对于由11个演奏家组成的合奏曲，并没有标准的术语，因此你不得不为未使用的int值（11）添加一个虚拟常量（dummy constant）。最多看起来就是有些不好看。如果许多int值是未使用的，则是不切实际的。</p><p>幸运的是，这些问题有一个简单的解决方案。 <strong>永远不要从枚举的序号中得出与它相关的值; 请将其保存在实例属性中</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public enum Ensemble &#123;</span><br><span class="line"></span><br><span class="line">    SOLO(1), DUET(2), TRIO(3), QUARTET(4), QUINTET(5),</span><br><span class="line"></span><br><span class="line">    SEXTET(6), SEPTET(7), OCTET(8), DOUBLE_QUARTET(8),</span><br><span class="line"></span><br><span class="line">    NONET(9), DECTET(10), TRIPLE_QUARTET(12);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private final int numberOfMusicians;</span><br><span class="line"></span><br><span class="line">    Ensemble(int size) &#123; this.numberOfMusicians = size; &#125;</span><br><span class="line"></span><br><span class="line">    public int numberOfMusicians() &#123; return numberOfMusicians; &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>枚举规范对此<code>ordinal</code>方法说道：“大多数程序员对这种方法没有用处。 它被设计用于基于枚举的通用数据结构，如<code>EnumSet</code>和<code>EnumMap</code>。“除非你在编写这样数据结构的代码，否则最好避免使用<code>ordinal</code>方法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;31-使用限定通配符来增加API的灵活性&quot;&gt;&lt;a href=&quot;#31-使用限定通配符来增加API的灵活性&quot; class=&quot;headerlink&quot; title=&quot;31. 使用限定通配符来增加API的灵活性&quot;&gt;&lt;/a&gt;31. 使用限定通配符来增加API的灵活性&lt;/h2
      
    
    </summary>
    
      <category term="java" scheme="http://luxiangdong.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>Effective Java 中文版(item:26-30)</title>
    <link href="http://luxiangdong.com/2018/05/09/effective-java-cn-26-30/"/>
    <id>http://luxiangdong.com/2018/05/09/effective-java-cn-26-30/</id>
    <published>2018-05-09T01:25:48.000Z</published>
    <updated>2018-05-09T03:04:56.414Z</updated>
    
    <content type="html"><![CDATA[<h2 id="26-不要使用原始类型"><a href="#26-不要使用原始类型" class="headerlink" title="26. 不要使用原始类型"></a>26. 不要使用原始类型</h2><p>首先，有几个术语。一个类或接口，它的声明有一个或多个类型参数（ type parameters ），被称之为泛型类或泛型接口[JLS，8.1.2,9.1.2]。 例如，List接口具有单个类型参数E，表示其元素类型。 接口的全名是<code>List&lt;E&gt;</code>（读作“E”的列表），但是人们经常称它为List。 泛型类和接口统称为泛型类型（generic types）。</p><p>每个泛型定义了一组参数化类型（parameterized types），它们由类或接口名称组成，后跟一个与泛型类型的形式类型参数[JLS，4.4,4.5]相对应的实际类型参数的尖括号“&lt;&gt;”列表。 例如，<code>List&lt;String&gt;</code>（读作“字符串列表”）是一个参数化类型，表示其元素类型为String的列表。 （String是与形式类型参数E相对应的实际类型参数）。</p><p>最后，每个泛型定义了一个原始类型（ raw type），它是没有任何类型参数的泛型类型的名称[JLS，4.8]。 例如，对应于<code>List&lt;E&gt;</code>的原始类型是List。 原始类型的行为就像所有的泛型类型信息都从类型声明中被清除一样。 它们的存在主要是为了与没有泛型之前的代码相兼容。</p><p>在泛型被添加到Java之前，这是一个典型的集合声明。 从Java 9开始，它仍然是合法的，但并不是典型的声明方式了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Raw collection type - don&apos;t do this!</span><br><span class="line"></span><br><span class="line">// My stamp collection. Contains only Stamp instances.</span><br><span class="line">private final Collection stamps = ... ;</span><br></pre></td></tr></table></figure><p>如果你今天使用这个声明，然后不小心把coin实例放入你的stamp集合中，错误的插入编译和运行没有错误（尽管编译器发出一个模糊的警告）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// Erroneous insertion of coin into stamp collection</span><br><span class="line">stamps.add(new Coin( ... )); // Emits &quot;unchecked call&quot; warning</span><br></pre></td></tr></table></figure><p>直到您尝试从stamp集合中检索coin实例时才会发生错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Raw iterator type - don&apos;t do this!</span><br><span class="line">for (Iterator i = stamps.iterator(); i.hasNext(); )</span><br><span class="line">    Stamp stamp = (Stamp) i.next(); // Throws ClassCastException</span><br><span class="line">        stamp.cancel();</span><br></pre></td></tr></table></figure><p>正如本书所提到的，在编译完成之后尽快发现错误是值得的，理想情况是在编译时。 在这种情况下，直到运行时才发现错误，在错误发生后的很长一段时间，以及可能远离包含错误的代码的代码中。 一旦看到ClassCastException，就必须搜索代码类库，查找将coin实例放入stamp集合的方法调用。 编译器不能帮助你，因为它不能理解那个说“仅包含stamp实例”的注释。</p><p>对于泛型，类型声明包含的信息，而不是注释：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// Parameterized collection type - typesafe</span><br><span class="line">private final Collection&lt;Stamp&gt; stamps = ... ;</span><br></pre></td></tr></table></figure><p>从这个声明中，编译器知道stamps集合应该只包含Stamp实例，并保证它是true，假设你的整个代码类库编译时不发出（或者抑制;参见条目27）任何警告。 当使用参数化类型声明声明stamps时，错误的插入会生成一个编译时错误消息，告诉你到底发生了什么错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Test.java:9: error: incompatible types: Coin cannot be converted</span><br><span class="line">to Stamp</span><br><span class="line">    c.add(new Coin());</span><br><span class="line">              ^</span><br></pre></td></tr></table></figure><p>当从集合中检索元素时，编译器会为你插入不可见的强制转换，并保证它们不会失败（再假设你的所有代码都不会生成或禁止任何编译器警告）。 虽然意外地将coin实例插入stamp集合的预期可能看起来很牵强，但这个问题是真实的。 例如，很容易想象将<code>BigInteger</code>放入一个只包含<code>BigDecimal</code>实例的集合中。</p><p>如前所述，使用原始类型（没有类型参数的泛型）是合法的，但是你不应该这样做。 <strong>如果你使用原始类型，则会丧失泛型的所有安全性和表达上的优势</strong>。 鉴于你不应该使用它们，为什么语言设计者首先允许原始类型呢？ 答案是为了兼容性。 泛型被添加时，Java即将进入第二个十年，并且有大量的代码没有使用泛型。 所有这些代码都是合法的，并且与使用泛型的新代码进行交互操作被认为是至关重要的。 将参数化类型的实例传递给为原始类型设计的方法必须是合法的，反之亦然。 这个需求，被称为迁移兼容性，驱使决策支持原始类型，并使用擦除来实现泛型（条目 28）。</p><p>虽然不应使用诸如List之类的原始类型，但可以使用参数化类型来允许插入任意对象（如<code>List&lt;Object&gt;</code>）。 原始类型List和参数化类型<code>List&lt;Object&gt;</code>之间有什么区别？ 松散地说，前者已经选择了泛型类型系统，而后者明确地告诉编译器，它能够保存任何类型的对象。 虽然可以将<code>List&lt;String&gt;</code>传递给List类型的参数，但不能将其传递给<code>List&lt;Object&gt;</code>类型的参数。 泛型有子类型的规则，<code>List&lt;String&gt;</code>是原始类型List的子类型，但不是参数化类型<code>List&lt;Object&gt;</code>的子类型（条目 28）。 因此，如果使用诸如List之类的原始类型，则会丢失类型安全性，但是如果使用参数化类型（例如<code>List &lt;Object&gt;</code>）则不会。</p><p>为了具体说明，请考虑以下程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// Fails at runtime - unsafeAdd method uses a raw type (List)!</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;String&gt; strings = new ArrayList&lt;&gt;();</span><br><span class="line">    unsafeAdd(strings, Integer.valueOf(42));</span><br><span class="line">    String s = strings.get(0); // Has compiler-generated cast</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void unsafeAdd(List list, Object o) &#123;</span><br><span class="line">    list.add(o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此程序可以编译，它使用原始类型列表，但会收到警告：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Test.java:10: warning: [unchecked] unchecked call to add(E) as a</span><br><span class="line">member of the raw type List</span><br><span class="line">    list.add(o);</span><br><span class="line">            ^</span><br></pre></td></tr></table></figure><p>实际上，如果运行该程序，则当程序尝试调用<code>strings.get(0)</code>的结果（一个Integer）转换为一个String时，会得到ClassCastException异常。 这是一个编译器生成的强制转换，因此通常会保证成功，但在这种情况下，我们忽略了编译器警告并付出了代价。</p><p>如果用unsafeAdd声明中的参数化类型<code>List &lt;Object&gt;</code>替换原始类型List，并尝试重新编译该程序，则会发现它不再编译，而是发出错误消息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Test.java:5: error: incompatible types: List&lt;String&gt; cannot be</span><br><span class="line">converted to List&lt;Object&gt;</span><br><span class="line">    unsafeAdd(strings, Integer.valueOf(42));</span><br></pre></td></tr></table></figure><p>你可能会试图使用原始类型来处理元素类型未知且无关紧要的集合。 例如，假设你想编写一个方法，它需要两个集合并返回它们共同拥有的元素的数量。 如果是泛型新手，那么您可以这样写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// Use of raw type for unknown element type - don&apos;t do this!</span><br><span class="line">static int numElementsInCommon(Set s1, Set s2) &#123;</span><br><span class="line">    int result = 0;</span><br><span class="line">    for (Object o1 : s1)</span><br><span class="line">        if (s2.contains(o1))</span><br><span class="line">            result++;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法可以工作，但它使用原始类型，这是危险的。 安全替代方式是使用无限制通配符类型（unbounded wildcard types）。 如果要使用泛型类型，但不知道或关心实际类型参数是什么，则可以使用问号来代替。 例如，泛型类型<code>Set&lt;E&gt;</code>的无限制通配符类型是<code>Set &lt;?&gt;</code>（读取“某种类型的集合”）。 它是最通用的参数化的Set类型，能够保持任何集合。 下面是<code>numElementsInCommon</code>方法使用无限制通配符类型声明的情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// Uses unbounded wildcard type - typesafe and flexible</span><br><span class="line">static int numElementsInCommon(Set&lt;?&gt; s1, Set&lt;?&gt; s2) &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>无限制通配符<code>Set &lt;?&gt;</code>与原始类型Set之间有什么区别？ 问号真的给你放任何东西吗？ 这不是要点，但通配符类型是安全的，原始类型不是。 你可以将任何元素放入具有原始类型的集合中，轻易破坏集合的类型不变性（如第119页上的unsafeAdd方法所示）; 你不能把任何元素（除null之外）放入一个<code>Collection &lt;?&gt;</code>中。 试图这样做会产生一个像这样的编译时错误消息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">WildCard.java:13: error: incompatible types: String cannot be</span><br><span class="line">converted to CAP#1</span><br><span class="line">    c.add(&quot;verboten&quot;);</span><br><span class="line">          ^</span><br><span class="line">  where CAP#1 is a fresh type-variable:</span><br><span class="line">    CAP#1 extends Object from capture of ?</span><br></pre></td></tr></table></figure><p>不可否认的是，这个错误信息留下了一些需要的东西，但是编译器已经完成了它的工作，不管它的元素类型是什么，都不会破坏集合的类型不变性。 你不仅可以将任何元素（除null以外）放入一个<code>Collection &lt;?&gt;</code>中，但是不能保证你所得到的对象的类型。 如果这些限制是不可接受的，可以使用泛型方法（条目 30）或有限制配符类型（条目 31）。</p><p>对于不应该使用原始类型的规则，有一些小例外。 <strong>你必须在类字面值（class literals）中使用原始类型</strong>。 规范中不允许使用参数化类型（尽管它允许数组类型和基本类型）[JLS，15.8.2]。 换句话说，<code>List.class</code>，<code>String [] .class</code>和<code>int.class</code>都是合法的，但<code>List &lt;String&gt; .class</code>和<code>List &lt;?&gt;.class</code>不是合法的。</p><p>规则的第二个例外涉及<code>instanceof</code>操作符。 因为泛型类型信息在运行时被删除，所以在无限制通配符类型以外的参数化类型上使用instanceof运算符是非法的。 使用无限制通配符类型代替原始类型不会以任何方式影响instanceof运算符的行为。 在这种情况下，尖括号和问号就显得多余。 以下是使用泛型类型的instanceof运算符的首选方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Legitimate use of raw type - instanceof operator</span><br><span class="line">if (o instanceof Set) &#123;       // Raw type</span><br><span class="line">    Set&lt;?&gt; s = (Set&lt;?&gt;) o;    // Wildcard type</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，一旦确定<code>o</code>对象是一个Set，则必须将其转换为通配符<code>Set &lt;?&gt;</code>，而不是原始类型Set。 这是一个强制转换，所以不会导致编译器警告。</p><p>总之，使用原始类型可能导致运行时异常，所以不要使用它们。 它们仅用于与泛型引入之前的传统代码的兼容性和互操作性。 作为一个快速回顾，<code>Set&lt;Object&gt;</code>是一个参数化类型，表示一个可以包含任何类型对象的集合，<code>Set&lt;?&gt;</code>是一个通配符类型，表示一个只能包含某些未知类型对象的集合，Set是一个原始类型，它不在泛型类型系统之列。 前两个类型是安全的，最后一个不是。</p><p>为了快速参考，下表中总结了本条目（以及本章稍后介绍的一些）中介绍的术语：</p><table><thead><tr><th>术语</th><th>中文含义</th><th>举例</th><th>所在条目</th></tr></thead><tbody><tr><td>Parameterized type</td><td>参数化类型</td><td><code>List&lt;String&gt;</code></td><td>条目 26</td></tr><tr><td>Actual type parameter</td><td>实际类型参数</td><td><code>String</code></td><td>条目 26</td></tr><tr><td>Generic type</td><td>泛型类型</td><td><code>List&lt;E&gt;</code></td><td>条目 26</td></tr><tr><td>Formal type parameter</td><td>形式类型参数</td><td><code>E</code></td><td>条目 26</td></tr><tr><td>Unbounded wildcard type</td><td>无限制通配符类型</td><td><code>List&lt;?&gt;</code></td><td>条目 26</td></tr><tr><td>Raw type</td><td>原始类型</td><td><code>List</code></td><td>条目 26</td></tr><tr><td>Bounded type parameter</td><td>限制类型参数</td><td><code>&lt;E extends Number&gt;</code></td><td>条目 29</td></tr><tr><td>Recursive type bound</td><td>递归类型限制</td><td><code>&lt;T extends Comparable&lt;T&gt;&gt;</code></td><td>条目 30</td></tr><tr><td>Bounded wildcard type</td><td>限制通配符类型</td><td><code>List&lt;? extends Number&gt;</code></td><td>条目 31</td></tr><tr><td>Generic method</td><td>泛型方法</td><td><code>static &lt;E&gt; List&lt;E&gt; asList(E[] a)</code></td><td>条目 30</td></tr><tr><td>Type token</td><td>类型令牌</td><td><code>String.class</code></td><td>条目 33</td></tr></tbody></table><h2 id="27-消除非检查警告"><a href="#27-消除非检查警告" class="headerlink" title="27. 消除非检查警告"></a>27. 消除非检查警告</h2><p>使用泛型编程时，会看到许多编译器警告：未经检查的强制转换警告，未经检查的方法调用警告，未经检查的参数化可变长度类型警告以及未经检查的转换警告。 你使用泛型获得的经验越多，获得的警告越少，但不要期望新编写的代码能够干净地编译。</p><p>许多未经检查的警告很容易消除。 例如，假设你不小心写了以下声明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Lark&gt; exaltation = new HashSet();</span><br></pre></td></tr></table></figure><p>编译器会提醒你你做错了什么：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Venery.java:4: warning: [unchecked] unchecked conversion</span><br><span class="line">        Set&lt;Lark&gt; exaltation = new HashSet();</span><br><span class="line">                               ^</span><br><span class="line">  required: Set&lt;Lark&gt;</span><br><span class="line">  found:    HashSet</span><br></pre></td></tr></table></figure><p>然后可以进行指示修正，让警告消失。 请注意，实际上并不需要指定类型参数，只是为了表明它与Java 7中引入的钻石运算符（”&lt;&gt;”）一同出现。然后编译器会推断出正确的实际类型参数（在本例中为Lark）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Lark&gt; exaltation = new HashSet&lt;&gt;();</span><br></pre></td></tr></table></figure><p>但一些警告更难以消除。 本章充满了这种警告的例子。 当你收到需要进一步思考的警告时，坚持不懈！ <strong>尽可能地消除每一个未经检查的警告</strong>。 如果你消除所有的警告，你可以放心，你的代码是类型安全的，这是一件非常好的事情。 这意味着在运行时你将不会得到一个ClassCastException异常，并且增加了你的程序将按照你的意图行事的信心。</p><p><strong>如果你不能消除警告，但你可以证明引发警告的代码是类型安全的，那么（并且只能这样）用@SuppressWarnings(“unchecked”)注解来抑制警告</strong>。 如果你在没有首先证明代码是类型安全的情况下压制警告，那么你给自己一个错误的安全感。 代码可能会在不发出任何警告的情况下进行编译，但是它仍然可以在运行时抛出ClassCastException异常。 但是，如果你忽略了你认为是安全的未经检查的警告（而不是抑制它们），那么当一个新的警告出现时，你将不会注意到这是一个真正的问题。 新出现的警告就会淹没在所有的错误警告当中。</p><p><code>SuppressWarnings</code>注解可用于任何声明，从单个局部变量声明到整个类。 <strong>始终在尽可能最小的范围内使用SuppressWarnings注解</strong>。 通常这是一个变量声明或一个非常短的方法或构造方法。 切勿在整个类上使用<code>SuppressWarnings</code>注解。 这样做可能会掩盖重要的警告。</p><p>如果你发现自己在长度超过一行的方法或构造方法上使用<code>SuppressWarnings</code>注解，则可以将其移到局部变量声明上。 你可能需要声明一个新的局部变量，但这是值得的。 例如，考虑这个来自ArrayList的toArray方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">    if (a.length &lt; size)</span><br><span class="line">       return (T[]) Arrays.copyOf(elements, size, a.getClass());</span><br><span class="line">    System.arraycopy(elements, 0, a, 0, size);</span><br><span class="line">    if (a.length &gt; size)</span><br><span class="line">       a[size] = null;</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">如果编译ArrayList类，则该方法会生成此警告：</span><br><span class="line">ArrayList.java:305: warning: [unchecked] unchecked cast</span><br><span class="line">       return (T[]) Arrays.copyOf(elements, size, a.getClass());</span><br><span class="line">                                 ^</span><br><span class="line">  required: T[]</span><br><span class="line">  found:    Object[]</span><br></pre></td></tr></table></figure><p>在返回语句中设置<code>SuppressWarnings</code>注解是非法的，因为它不是一个声明[JLS，9.7]。 你可能会试图把注释放在整个方法上，但是不要这要做。 相反，声明一个局部变量来保存返回值并标注它的声明，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// Adding local variable to reduce scope of @SuppressWarnings</span><br><span class="line">public &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">    if (a.length &lt; size) &#123;</span><br><span class="line">        // This cast is correct because the array we&apos;re creating</span><br><span class="line">        // is of the same type as the one passed in, which is T[].</span><br><span class="line">        @SuppressWarnings(&quot;unchecked&quot;) T[] result =</span><br><span class="line">            (T[]) Arrays.copyOf(elements, size, a.getClass());</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    System.arraycopy(elements, 0, a, 0, size);</span><br><span class="line">    if (a.length &gt; size)</span><br><span class="line">        a[size] = null;</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所产生的方法干净地编译，并最小化未经检查的警告被抑制的范围。</p><p><strong>每当使用@SuppressWarnings(“unchecked”)注解时，请添加注释，说明为什么是安全的</strong>。 这将有助于他人理解代码，更重要的是，这将减少有人修改代码的可能性，从而使计算不安全。 如果你觉得很难写这样的注释，请继续思考。 毕竟，你最终可能会发现未经检查的操作是不安全的。</p><p>总之，未经检查的警告是重要的。 不要忽视他们。 每个未经检查的警告代表在运行时出现ClassCastException异常的可能性。 尽你所能消除这些警告。 如果无法消除未经检查的警告，并且可以证明引发该警告的代码是安全类型的，则可以在尽可能小的范围内使用 <code>@SuppressWarnings(“unchecked”)</code>注解来禁止警告。 记录你决定在注释中抑制此警告的理由。</p><h2 id="28-列表优于数组"><a href="#28-列表优于数组" class="headerlink" title="28.列表优于数组"></a>28.列表优于数组</h2><p>数组在两个重要方面与泛型不同。 首先，数组是协变的（covariant）。 这个吓人的单词意味着如果<code>Sub</code>是<code>Super</code>的子类型，则数组类型<code>Sub []</code>是数组类型<code>Super []</code>的子类型。 相比之下，泛型是不变的（invariant）：对于任何两种不同的类型<code>Type1</code>和<code>Type2</code>，<code>List&lt;Type1&gt;</code>既不是<code>List &lt;Type2&gt;</code>的子类型也不是父类型。[JLS，4.10; Naftalin07,2.5]。 你可能认为这意味着泛型是不足的，但可以说是数组缺陷。 这段代码是合法的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// Fails at runtime!</span><br><span class="line">Object[] objectArray = new Long[1];</span><br><span class="line">objectArray[0] = &quot;I don&apos;t fit in&quot;; // Throws ArrayStoreException</span><br></pre></td></tr></table></figure><p>但这个不是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// Won&apos;t compile!</span><br><span class="line">List&lt;Object&gt; ol = new ArrayList&lt;Long&gt;(); // Incompatible types</span><br><span class="line">ol.add(&quot;I don&apos;t fit in&quot;);</span><br></pre></td></tr></table></figure><p>无论哪种方式，你不能把一个String类型放到一个Long类型容器中，但是用一个数组，你会发现在运行时产生了一个错误；对于列表，可以在编译时就能发现错误。 当然，你宁愿在编译时找出错误。</p><p>数组和泛型之间的第二个主要区别是数组被具体化了（reified）[JLS，4.7]。 这意味着数组在运行时知道并强制执行它们的元素类型。 如前所述，如果尝试将一个String放入Long数组中，得到一个ArrayStoreException异常。 相反，泛型通过擦除（erasure）来实现[JLS，4.6]。 这意味着它们只在编译时执行类型约束，并在运行时丢弃（或擦除）它们的元素类型信息。 擦除是允许泛型类型与不使用泛型的遗留代码自由互操作（条目 26），从而确保在Java 5中平滑过渡到泛型。</p><p>由于这些基本差异，数组和泛型不能很好地在一起混合使用。 例如，创建泛型类型的数组，参数化类型的数组，以及类型参数的数组都是非法的。 因此，这些数组创建表达式都不合法：<code>new List &lt;E&gt; []</code>，<code>new List &lt;String&gt; []</code>，<code>new E []</code>。 所有将在编译时导致泛型数组创建错误。</p><p>为什么创建一个泛型数组是非法的？ 因为它不是类型安全的。 如果这是合法的，编译器生成的强制转换程序在运行时可能会因为ClassCastException异常而失败。 这将违反泛型类型系统提供的基本保证。</p><p>为了具体说明，请考虑下面的代码片段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Why generic array creation is illegal - won&apos;t compile!</span><br><span class="line">List&lt;String&gt;[] stringLists = new List&lt;String&gt;[1];  // (1)</span><br><span class="line">List&lt;Integer&gt; intList = List.of(42);               // (2)</span><br><span class="line">Object[] objects = stringLists;                    // (3)</span><br><span class="line">objects[0] = intList;                              // (4)</span><br><span class="line">String s = stringLists[0].get(0);                  // (5)</span><br></pre></td></tr></table></figure><p>让我们假设第1行创建一个泛型数组是合法的。第2行创建并初始化包含单个元素的<code>List&lt;Integer&gt;</code>。第3行将<code>List&lt;String&gt;</code>数组存储到Object数组变量中，这是合法的，因为数组是协变的。第4行将<code>List &lt;Integer&gt;</code>存储在Object数组的唯一元素中，这是因为泛型是通过擦除来实现的：<code>List&lt;Integer&gt;</code>实例的运行时类型仅仅是List，而<code>List&lt;String&gt; []</code>实例是<code>List []</code>，所以这个赋值不会产生ArrayStoreException异常。现在我们遇到了麻烦。将一个<code>List&lt;Integer&gt;</code>实例存储到一个声明为仅保存<code>List&lt;String&gt;</code>实例的数组中。在第5行中，我们从这个数组的唯一列表中检索唯一的元素。编译器自动将检索到的元素转换为String，但它是一个Integer，所以我们在运行时得到一个ClassCastException异常。为了防止发生这种情况，第1行（创建一个泛型数组）必须产生一个编译时错误。</p><p>类型<code>E</code>，<code>List&lt;E&gt;</code>和<code>List&lt;String&gt;</code>等在技术上被称为不可具体化的类型（nonreifiable types）[JLS，4.7]。 直观地说，不可具体化的类型是其运行时表示包含的信息少于其编译时表示的类型。 由于擦除，可唯一确定的参数化类型是无限定通配符类型，如<code>List &lt;?&gt;</code>和<code>Map &lt;?, ?&gt;</code>（条目 26）。 尽管很少有用，创建无限定通配符类型的数组是合法的。</p><p>禁止泛型数组的创建可能会很恼人的。 这意味着，例如，泛型集合通常不可能返回其元素类型的数组（但是参见条目 33中的部分解决方案）。 这也意味着，当使用可变参数方法（条目 53）和泛型时，会产生令人困惑的警告。 这是因为每次调用可变参数方法时，都会创建一个数组来保存可变参数。 如果此数组的元素类型不可确定，则会收到警告。 <code>SafeVarargs</code>注解可以用来解决这个问题（条目 32）。</p><p>当你在强制转换为数组类型时，得到泛型数组创建错误，或是未经检查的强制转换警告时，最佳解决方案通常是使用集合类型<code>List &lt;E&gt;</code>而不是数组类型<code>E []</code>。 这样可能会牺牲一些简洁性或性能，但作为交换，你会获得更好的类型安全性和互操作性。</p><p>例如，假设你想用带有集合的构造方法来编写一个<code>Chooser</code>类，并且有个方法返回随机选择的集合的一个元素。 根据传递给构造方法的集合，可以使用选择器作为游戏模具，魔术8球或数据源进行蒙特卡罗模拟。 这是一个没有泛型的简单实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// Chooser - a class badly in need of generics!</span><br><span class="line">public class Chooser &#123;</span><br><span class="line">    private final Object[] choiceArray;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public Chooser(Collection choices) &#123;</span><br><span class="line">        choiceArray = choices.toArray();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public Object choose() &#123;</span><br><span class="line">        Random rnd = ThreadLocalRandom.current();</span><br><span class="line">        return choiceArray[rnd.nextInt(choiceArray.length)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要使用这个类，每次调用方法时，都必须将Object的<code>choose</code>方法的返回值转换为所需的类型，如果类型错误，则转换在运行时失败。 我们先根据条目 29的建议，试图修改Chooser类，使其成为泛型的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// A first cut at making Chooser generic - won&apos;t compile</span><br><span class="line">public class Chooser&lt;T&gt; &#123;</span><br><span class="line">    private final T[] choiceArray;</span><br><span class="line"></span><br><span class="line">    public Chooser(Collection&lt;T&gt; choices) &#123;</span><br><span class="line">        choiceArray = choices.toArray();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // choose method unchanged</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你尝试编译这个类，会得到这个错误信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Chooser.java:9: error: incompatible types: Object[] cannot be</span><br><span class="line">converted to T[]</span><br><span class="line">        choiceArray = choices.toArray();</span><br><span class="line">                                     ^</span><br><span class="line">  where T is a type-variable:</span><br><span class="line">    T extends Object declared in class Chooser</span><br></pre></td></tr></table></figure><p>没什么大不了的，将Object数组转换为T数组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">choiceArray = (T[]) choices.toArray();</span><br></pre></td></tr></table></figure><p>这没有了错误，而是得到一个警告：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Chooser.java:9: warning: [unchecked] unchecked cast</span><br><span class="line">        choiceArray = (T[]) choices.toArray();</span><br><span class="line">                                           ^</span><br><span class="line">  required: T[], found: Object[]</span><br><span class="line">  where T is a type-variable:</span><br><span class="line">T extends Object declared in class Chooser</span><br></pre></td></tr></table></figure><p>编译器告诉你在运行时不能保证强制转换的安全性，因为程序不会知道T代表什么类型——记住，元素类型信息在运行时会被泛型删除。 该程序可以正常工作吗？ 是的，但编译器不能证明这一点。 你可以证明这一点，在注释中提出证据，并用注解来抑制警告，但最好是消除警告的原因（条目 27）。</p><p>要消除未经检查的强制转换警告，请使用列表而不是数组。 下面是另一个版本的Chooser类，编译时没有错误或警告：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// List-based Chooser - typesafe</span><br><span class="line">public class Chooser&lt;T&gt; &#123;</span><br><span class="line">    private final List&lt;T&gt; choiceList;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public Chooser(Collection&lt;T&gt; choices) &#123;</span><br><span class="line">        choiceList = new ArrayList&lt;&gt;(choices);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public T choose() &#123;</span><br><span class="line">        Random rnd = ThreadLocalRandom.current();</span><br><span class="line">        return choiceList.get(rnd.nextInt(choiceList.size()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个版本有些冗长，也许运行比较慢，但是值得一提的是，在运行时不会得到<code>ClassCastException</code>异常。</p><p>总之，数组和泛型具有非常不同的类型规则。 数组是协变和具体化的; 泛型是不变的，类型擦除的。 因此，数组提供运行时类型的安全性，但不提供编译时类型的安全性，反之亦然。 一般来说，数组和泛型不能很好地混合工作。 如果你发现把它们混合在一起，得到编译时错误或者警告，你的第一个冲动应该是用列表来替换数组。</p><h2 id="29-优先考虑泛型"><a href="#29-优先考虑泛型" class="headerlink" title="29. 优先考虑泛型"></a>29. 优先考虑泛型</h2><p>参数化声明并使用JDK提供的泛型类型和方法通常不会太困难。 但编写自己的泛型类型有点困难，但值得努力学习。</p><p>考虑条目 7中的简单堆栈实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// Object-based collection - a prime candidate for generics</span><br><span class="line">public class Stack &#123;</span><br><span class="line">    private Object[] elements;</span><br><span class="line">    private int size = 0;</span><br><span class="line">    private static final int DEFAULT_INITIAL_CAPACITY = 16;</span><br><span class="line"></span><br><span class="line">    public Stack() &#123;</span><br><span class="line">        elements = new Object[DEFAULT_INITIAL_CAPACITY];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void push(Object e) &#123;</span><br><span class="line">        ensureCapacity();</span><br><span class="line">        elements[size++] = e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object pop() &#123;</span><br><span class="line">        if (size == 0)</span><br><span class="line">            throw new EmptyStackException();</span><br><span class="line">        Object result = elements[--size];</span><br><span class="line">        elements[size] = null; // Eliminate obsolete reference</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isEmpty() &#123;</span><br><span class="line">        return size == 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void ensureCapacity() &#123;</span><br><span class="line">        if (elements.length == size)</span><br><span class="line">            elements = Arrays.copyOf(elements, 2 * size + 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类应该已经被参数化了，但是由于事实并非如此，我们可以对它进行泛型化。 换句话说，我们可以参数化它，而不会损害原始非参数化版本的客户端。 就目前而言，客户端必须强制转换从堆栈中弹出的对象，而这些强制转换可能会在运行时失败。 泛型化类的第一步是在其声明中添加一个或多个类型参数。 在这种情况下，有一个类型参数，表示堆栈的元素类型，这个类型参数的常规名称是<code>E</code>（条目 68）。</p><p>下一步是用相应的类型参数替换所有使用的Object类型，然后尝试编译生成的程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// Initial attempt to generify Stack - won&apos;t compile!</span><br><span class="line">public class Stack&lt;E&gt; &#123;</span><br><span class="line">    private E[] elements;</span><br><span class="line">    private int size = 0;</span><br><span class="line">    private static final int DEFAULT_INITIAL_CAPACITY = 16;</span><br><span class="line"></span><br><span class="line">    public Stack() &#123;</span><br><span class="line">        elements = new E[DEFAULT_INITIAL_CAPACITY];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void push(E e) &#123;</span><br><span class="line">        ensureCapacity();</span><br><span class="line">        elements[size++] = e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public E pop() &#123;</span><br><span class="line">        if (size == 0)</span><br><span class="line">            throw new EmptyStackException();</span><br><span class="line">        E result = elements[--size];</span><br><span class="line">        elements[size] = null; // Eliminate obsolete reference</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    ... // no changes in isEmpty or ensureCapacity</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你通常会得到至少一个错误或警告，这个类也不例外。 幸运的是，这个类只产生一个错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stack.java:8: generic array creation</span><br><span class="line">        elements = new E[DEFAULT_INITIAL_CAPACITY];</span><br><span class="line">                   ^</span><br></pre></td></tr></table></figure><p>如条目 28所述，你不能创建一个不可具体化类型的数组，例如类型<code>E</code>。每当编写一个由数组支持的泛型时，就会出现此问题。 有两种合理的方法来解决它。 第一种解决方案直接规避了对泛型数组创建的禁用：创建一个Object数组并将其转换为泛型数组类型。 现在没有了错误，编译器会发出警告。 这种用法是合法的，但不是（一般）类型安全的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Stack.java:8: warning: [unchecked] unchecked cast</span><br><span class="line">found: Object[], required: E[]</span><br><span class="line">        elements = (E[]) new Object[DEFAULT_INITIAL_CAPACITY];</span><br><span class="line">                       ^</span><br></pre></td></tr></table></figure><p>编译器可能无法证明你的程序是类型安全的，但你可以。 你必须说服自己，不加限制的类型强制转换不会损害程序的类型安全。 有问题的数组（元素）保存在一个私有属性中，永远不会返回给客户端或传递给任何其他方法。 保存在数组中的唯一元素是那些传递给<code>push</code>方法的元素，它们是<code>E</code>类型的，所以未经检查的强制转换不会造成任何伤害。</p><p>一旦证明未经检查的强制转换是安全的，请尽可能缩小范围（条目 27）。 在这种情况下，构造方法只包含未经检查的数组创建，所以在整个构造方法中抑制警告是合适的。 通过添加一个注解来执行此操作，Stack可以干净地编译，并且可以在没有显式强制转换或担心ClassCastException异常的情况下使用它：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// The elements array will contain only E instances from push(E).</span><br><span class="line">// This is sufficient to ensure type safety, but the runtime</span><br><span class="line">// type of the array won&apos;t be E[]; it will always be Object[]!</span><br><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">public Stack() &#123;</span><br><span class="line">    elements = (E[]) new Object[DEFAULT_INITIAL_CAPACITY];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消除Stack中的泛型数组创建错误的第二种方法是将属性元素的类型从<code>E []</code>更改为<code>Object []</code>。 如果这样做，会得到一个不同的错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Stack.java:19: incompatible types</span><br><span class="line">found: Object, required: E</span><br><span class="line">        E result = elements[--size];</span><br><span class="line">                           ^</span><br></pre></td></tr></table></figure><p>可以通过将从数组中检索到的元素转换为<code>E</code>来将此错误更改为警告：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Stack.java:19: warning: [unchecked] unchecked cast</span><br><span class="line">found: Object, required: E</span><br><span class="line">        E result = (E) elements[--size];</span><br><span class="line">                               ^</span><br></pre></td></tr></table></figure><p>因为E是不可具体化的类型，编译器无法在运行时检查强制转换。 再一次，你可以很容易地向自己证明，不加限制的转换是安全的，所以可以适当地抑制警告。 根据条目 27的建议，我们只在包含未经检查的强制转换的分配上抑制警告，而不是在整个<code>pop</code>方法上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// Appropriate suppression of unchecked warning</span><br><span class="line">public E pop() &#123;</span><br><span class="line">    if (size == 0)</span><br><span class="line">        throw new EmptyStackException();</span><br><span class="line"></span><br><span class="line">    // push requires elements to be of type E, so cast is correct</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;) E result =</span><br><span class="line">        (E) elements[--size];</span><br><span class="line"></span><br><span class="line">    elements[size] = null; // Eliminate obsolete reference</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两种消除泛型数组创建的技术都有其追随者。 第一个更可读：数组被声明为<code>E []</code>类型，清楚地表明它只包含E实例。 它也更简洁：在一个典型的泛型类中，你从代码中的许多点读取数组; 第一种技术只需要一次转换（创建数组的地方），而第二种技术每次读取数组元素都需要单独转换。 因此，第一种技术是优选的并且在实践中更常用。 但是，它确实会造成堆污染（heap pollution）（条目 32）：数组的运行时类型与编译时类型不匹配（除非E碰巧是Object）。 这使得一些程序员非常不安，他们选择了第二种技术，尽管在这种情况下堆的污染是无害的。</p><p>下面的程序演示了泛型Stack类的使用。 该程序以相反的顺序打印其命令行参数，并将其转换为大写。 对从堆栈弹出的元素调用String的<code>toUpperCase</code>方法不需要显式强制转换，而自动生成的强制转换将保证成功：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// Little program to exercise our generic Stack</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Stack&lt;String&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">    for (String arg : args)</span><br><span class="line">        stack.push(arg);</span><br><span class="line">    while (!stack.isEmpty())</span><br><span class="line">        System.out.println(stack.pop().toUpperCase());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子似乎与条目 28相矛盾，条目 28中鼓励使用列表优先于数组。 在泛型类型中使用列表并不总是可行或可取的。 Java本身生来并不支持列表，所以一些泛型类型（如ArrayList）必须在数组上实现。 其他的泛型类型，比如HashMap，是为了提高性能而实现的。</p><p>绝大多数泛型类型就像我们的Stack示例一样，它们的类型参数没有限制：可以创建一个<code>Stack &lt;Object&gt;</code>，<code>Stack &lt;int []&gt;</code>，<code>Stack &lt;List &lt;String &gt;&gt;</code>或者其他任何对象的Stack引用类型。 请注意，不能创建基本类型的堆栈：尝试创建<code>Stack&lt;int&gt;</code>或<code>Stack&lt;double&gt;</code>将导致编译时错误。 这是Java泛型类型系统的一个基本限制。 可以使用基本类型的包装类（条目 61）来解决这个限制。</p><p>有一些泛型类型限制了它们类型参数的允许值。 例如，考虑<code>java.util.concurrent.DelayQueue</code>，它的声明如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class DelayQueue&lt;E extends Delayed&gt; implements BlockingQueue&lt;E&gt;</span><br></pre></td></tr></table></figure><p>类型参数列表（<code>&lt;E extends Delayed&gt;</code>）要求实际的类型参数<code>E</code>是<code>java.util.concurrent.Delayed</code>的子类型。 这使得<code>DelayQueue</code>实现及其客户端可以利用<code>DelayQueue</code>元素上的<code>Delayed</code>方法，而不需要显式的转换或ClassCastException异常的风险。 类型参数E被称为限定类型参数。 请注意，子类型关系被定义为每个类型都是自己的子类型[JLS，4.10]，因此创建<code>DelayQueue &lt;Delayed&gt;</code>是合法的。</p><p>总之，泛型类型比需要在客户端代码中强制转换的类型更安全，更易于使用。 当你设计新的类型时，确保它们可以在没有这种强制转换的情况下使用。 这通常意味着使类型泛型化。 如果你有任何现有的类型，应该是泛型的但实际上却不是，那么把它们泛型化。 这使这些类型的新用户的使用更容易，而不会破坏现有的客户端（条目 26）。</p><h2 id="30-优先使用泛型方法"><a href="#30-优先使用泛型方法" class="headerlink" title="30. 优先使用泛型方法"></a>30. 优先使用泛型方法</h2><p>正如类可以是泛型的，方法也可以是泛型的。 对参数化类型进行操作的静态工具方法通常都是泛型的。 集合中的所有“算法”方法（如<code>binarySearc</code>h和<code>sort</code>）都是泛型的。</p><p>编写泛型方法类似于编写泛型类型。 考虑这个方法，它返回两个集合的并集：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// Uses raw types - unacceptable! [Item 26]</span><br><span class="line"></span><br><span class="line">public static Set union(Set s1, Set s2) &#123;</span><br><span class="line"></span><br><span class="line">    Set result = new HashSet(s1);</span><br><span class="line"></span><br><span class="line">    result.addAll(s2);</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此方法可以编译但有两个警告：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Union.java:5: warning: [unchecked] unchecked call to</span><br><span class="line"></span><br><span class="line">HashSet(Collection&lt;? extends E&gt;) as a member of raw type HashSet</span><br><span class="line"></span><br><span class="line">        Set result = new HashSet(s1);</span><br><span class="line"></span><br><span class="line">                     ^</span><br><span class="line"></span><br><span class="line">Union.java:6: warning: [unchecked] unchecked call to</span><br><span class="line"></span><br><span class="line">addAll(Collection&lt;? extends E&gt;) as a member of raw type Set</span><br><span class="line"></span><br><span class="line">        result.addAll(s2);</span><br><span class="line"></span><br><span class="line">                     ^</span><br></pre></td></tr></table></figure><p>要修复这些警告并使方法类型安全，请修改其声明以声明表示三个集合（两个参数和返回值）的元素类型的类型参数，并在整个方法中使用此类型参数。 声明类型参数的类型参数列表位于方法的修饰符和返回类型之间。 在这个例子中，类型参数列表是<code>&lt;E&gt;</code>，返回类型是<code>Set&lt;E&gt;</code>。 类型参数的命名约定对于泛型方法和泛型类型是相同的（条目 29和68）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// Generic method</span><br><span class="line"></span><br><span class="line">public static &lt;E&gt; Set&lt;E&gt; union(Set&lt;E&gt; s1, Set&lt;E&gt; s2) &#123;</span><br><span class="line"></span><br><span class="line">    Set&lt;E&gt; result = new HashSet&lt;&gt;(s1);</span><br><span class="line"></span><br><span class="line">    result.addAll(s2);</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至少对于简单的泛型方法来说，就是这样。 此方法编译时不会生成任何警告，并提供类型安全性和易用性。 这是一个简单的程序来运行该方法。 这个程序不包含强制转换和编译时没有错误或警告：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// Simple program to exercise generic method</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">    Set&lt;String&gt; guys = Set.of(&quot;Tom&quot;, &quot;Dick&quot;, &quot;Harry&quot;);</span><br><span class="line"></span><br><span class="line">    Set&lt;String&gt; stooges = Set.of(&quot;Larry&quot;, &quot;Moe&quot;, &quot;Curly&quot;);</span><br><span class="line"></span><br><span class="line">    Set&lt;String&gt; aflCio = union(guys, stooges);</span><br><span class="line"></span><br><span class="line">    System.out.println(aflCio);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当运行这个程序时，它会打印<code>[Moe, Tom, Harry, Larry, Curly, Dick]</code>（输出中元素的顺序依赖于具体实现。）</p><p><code>union</code>方法的一个限制是所有三个集合（输入参数和返回值）的类型必须完全相同。 通过使用限定通配符类型（ bounded wildcard types）（条目 31），可以使该方法更加灵活。</p><p>有时，需要创建一个不可改变但适用于许多不同类型的对象。 因为泛型是通过擦除来实现的（条目 28），所以可以使用单个对象进行所有必需的类型参数化，但是需要编写一个静态工厂方法来重复地为每个请求的类型参数化分配对象。 这种称为泛型单例工厂（generic singleton factory）的模式用于方法对象（ function objects）（条目 42），比如<code>Collections.reverseOrder</code>方法，偶尔也用于<code>Collections.emptySet</code>之类的集合。</p><p>假设你想写一个恒等方法分配器（ identity function dispenser）。 类库提供了<code>Function.identity</code>方法，所以没有理由编写你自己的实现（条目 59），但它是有启发性的。 如果每次要求的时候都去创建一个新的恒等方法对象是浪费的，因为它是无状态的。 如果Java的泛型被具体化，那么每个类型都需要一个恒等方法，但是由于它们被擦除以后，所以泛型的单例就足够了。 以下是它的实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// Generic singleton factory pattern</span><br><span class="line"></span><br><span class="line">private static UnaryOperator&lt;Object&gt; IDENTITY_FN = (t) -&gt; t;</span><br><span class="line"></span><br><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line"></span><br><span class="line">public static &lt;T&gt; UnaryOperator&lt;T&gt; identityFunction() &#123;</span><br><span class="line"></span><br><span class="line">    return (UnaryOperator&lt;T&gt;) IDENTITY_FN;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将<code>IDENTITY_FN</code>转换为<code>(UnaryFunction &lt;T&gt;)</code>会生成一个未经检查的强制转换警告，因为<code>UnaryOperator &lt;Object&gt;</code>对于每个<code>T</code>都不是一个<code>UnaryOperator &lt;T&gt;</code>。但是恒等方法是特殊的：它返回未修改的参数，所以我们知道，使用它作为一个<code>UnaryFunction &lt;T&gt;</code>是类型安全的，无论<code>T</code>的值是多少。因此，我们可以放心地抑制由这个强制生成的未经检查的强制转换警告。 一旦我们完成了这些，代码编译没有错误或警告。</p><p>下面是一个示例程序，它使用我们的泛型单例作为<code>UnaryOperator &lt;String&gt;</code>和<code>UnaryOperator &lt;Number&gt;</code>。 像往常一样，它不包含强制转化，编译时也没有错误和警告：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// Sample program to exercise generic singleton</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">    String[] strings = &#123; &quot;jute&quot;, &quot;hemp&quot;, &quot;nylon&quot; &#125;;</span><br><span class="line"></span><br><span class="line">    UnaryOperator&lt;String&gt; sameString = identityFunction();</span><br><span class="line"></span><br><span class="line">    for (String s : strings)</span><br><span class="line"></span><br><span class="line">        System.out.println(sameString.apply(s));</span><br><span class="line"></span><br><span class="line">    Number[] numbers = &#123; 1, 2.0, 3L &#125;;</span><br><span class="line"></span><br><span class="line">    UnaryOperator&lt;Number&gt; sameNumber = identityFunction();</span><br><span class="line"></span><br><span class="line">    for (Number n : numbers)</span><br><span class="line"></span><br><span class="line">        System.out.println(sameNumber.apply(n));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然相对较少，类型参数受涉及该类型参数本身的某种表达式限制是允许的。 这就是所谓的递归类型限制（recursive type bound）。 递归类型限制的常见用法与<code>Comparable</code>接口有关，它定义了一个类型的自然顺序（条目 14）。 这个接口如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface Comparable&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    int compareTo(T o);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类型参数<code>T</code>定义了实现<code>Comparable &lt;T&gt;</code>的类型的元素可以比较的类型。 在实际中，几乎所有类型都只能与自己类型的元素进行比较。 所以，例如，<code>String</code>类实现了<code>Comparable &lt;String&gt;</code>，<code>Integer</code>类实现了<code>Comparable &lt;Integer&gt;</code>等等。</p><p>许多方法采用实现<code>Comparable</code>的元素的集合来对其进行排序，在其中进行搜索，计算其最小值或最大值等。 要做到这一点，要求集合中的每一个元素都可以与其中的每一个元素相比，换言之，这个元素是可以相互比较的。 以下是如何表达这一约束：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// Using a recursive type bound to express mutual comparability</span><br><span class="line"></span><br><span class="line">public static &lt;E extends Comparable&lt;E&gt;&gt; E max(Collection&lt;E&gt; c);</span><br></pre></td></tr></table></figure><p>限定的类型<code>&lt;E extends Comparable &lt;E &gt;&gt;</code>可以理解为“任何可以与自己比较的类型<code>E</code>”，这或多或少精确地对应于相互可比性的概念。</p><p>这里有一个与前面的声明相匹配的方法。它根据其元素的自然顺序来计算集合中的最大值，并编译没有错误或警告：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// Returns max value in a collection - uses recursive type bound</span><br><span class="line"></span><br><span class="line">public static &lt;E extends Comparable&lt;E&gt;&gt; E max(Collection&lt;E&gt; c) &#123;</span><br><span class="line"></span><br><span class="line">    if (c.isEmpty())</span><br><span class="line"></span><br><span class="line">        throw new IllegalArgumentException(&quot;Empty collection&quot;);</span><br><span class="line"></span><br><span class="line">    E result = null;</span><br><span class="line"></span><br><span class="line">    for (E e : c)</span><br><span class="line"></span><br><span class="line">        if (result == null || [e.compareTo(result](http://e.compareTo(result)) &gt; 0)</span><br><span class="line"></span><br><span class="line">            result = Objects.requireNonNull(e);</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，如果列表为空，则此方法将引发<code>IllegalArgumentException</code>异常。 更好的选择是返回一个<code>Optional&lt;E&gt;</code>（条目 55）。</p><p>递归类型限制可能变得复杂得多，但幸运的是他们很少这样做。 如果你理解了这个习惯用法，它的通配符变体（条目 31）和模拟的自我类型用法（条目 2），你将能够处理在实践中遇到的大多数递归类型限制。</p><p>总之，像泛型类型一样，泛型方法比需要客户端对输入参数和返回值进行显式强制转换的方法更安全，更易于使用。 像类型一样，你应该确保你的方法可以不用强制转换，这通常意味着它们是泛型的。 应该泛型化现有的方法，其使用需要强制转换。 这使得新用户的使用更容易，而不会破坏现有的客户端（条目 26）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;26-不要使用原始类型&quot;&gt;&lt;a href=&quot;#26-不要使用原始类型&quot; class=&quot;headerlink&quot; title=&quot;26. 不要使用原始类型&quot;&gt;&lt;/a&gt;26. 不要使用原始类型&lt;/h2&gt;&lt;p&gt;首先，有几个术语。一个类或接口，它的声明有一个或多个类型参数（ 
      
    
    </summary>
    
      <category term="java" scheme="http://luxiangdong.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>Effective Java 中文版(item:21-25)</title>
    <link href="http://luxiangdong.com/2018/05/09/effective-java-cn-21-25/"/>
    <id>http://luxiangdong.com/2018/05/09/effective-java-cn-21-25/</id>
    <published>2018-05-09T01:25:40.000Z</published>
    <updated>2018-05-09T03:02:54.716Z</updated>
    
    <content type="html"><![CDATA[<h2 id="21-为后代设计接口"><a href="#21-为后代设计接口" class="headerlink" title="21. 为后代设计接口"></a>21. 为后代设计接口</h2><p>在Java 8之前，不可能在不破坏现有实现的情况下为接口添加方法。 如果向接口添加了一个新方法，现有的实现通常会缺少该方法，从而导致编译时错误。 在Java 8中，添加了默认方法（ default method）构造[JLS 9.4]，目的是允许将方法添加到现有的接口。 但是增加新的方法到现有的接口是充满风险的。</p><p>默认方法的声明包含一个默认实现，该方法允许实现接口的类直接使用，而不必实现默认方法。 虽然在Java中添加默认方法可以将方法添加到现有接口，但不能保证这些方法可以在所有已有的实现中使用。 默认的方法被“注入（injected）”到现有的实现中，没有经过实现类的知道或同意。 在Java 8之前，这些实现是用默认的接口编写的，它们的接口永远不会获得任何新的方法。</p><p>许多新的默认方法被添加到Java 8的核心集合接口中，主要是为了方便使用lambda表达式（第6章）。 Java类库的默认方法是高质量的通用实现，在大多数情况下，它们工作正常。 但是，<strong>编写一个默认方法并不总是可能的，它保留了每个可能的实现的所有不变量</strong>。</p><p>例如，考虑在Java 8中添加到Collection接口的<code>removeIf</code>方法。例如，考虑在Java 8中添加到Collection接口的<code>removeIf</code>方法。此方法删除给定布尔方法（或<code>Predicate</code>函数式接口）返回true的所有元素。默认实现被指定为使用迭代器遍历集合，调用每个元素的谓词，并使用迭代器的<code>remove</code>方法删除谓词返回true的元素。 据推测，这个声明看起来像这样：默认实现被指定为使用迭代器遍历集合，调用每个元素的<code>Predicate</code>函数式接口，并使用迭代器的<code>remove</code>方法删除Predicate函数式接口返回true的元素。 根据推测，这个声明看起来像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// Default method added to the Collection interface in Java 8</span><br><span class="line"></span><br><span class="line">default boolean removeIf(Predicate&lt;? super E&gt; filter) &#123;</span><br><span class="line"></span><br><span class="line">    Objects.requireNonNull(filter);</span><br><span class="line"></span><br><span class="line">    boolean result = false;</span><br><span class="line"></span><br><span class="line">    for (Iterator&lt;E&gt; it = iterator(); it.hasNext(); ) &#123;</span><br><span class="line"></span><br><span class="line">        if (filter.test(it.next())) &#123;</span><br><span class="line"></span><br><span class="line">            it.remove();</span><br><span class="line"></span><br><span class="line">            result = true;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是可能为<code>removeIf</code>方法编写的最好的通用实现，但遗憾的是，它在一些实际的Collection实现中失败了。 例如，考虑<code>org.apache.commons.collections4.collection.SynchronizedCollection</code>方法。 这个类出自Apache Commons类库中，与java.util包中的静态工厂<code>Collections.synchronizedCollection</code>方法返回的类相似。 Apache版本还提供了使用客户端提供的对象进行锁定的能力，以代替集合。 换句话说，它是一个包装类（条目 18），它们的所有方法在委托给包装集合类之前在一个锁定对象上进行同步。</p><p>Apache的<code>SynchronizedCollection</code>类仍然在积极维护，但在撰写本文时，并未重写<code>removeIf</code>方法。 如果这个类与Java 8一起使用，它将继承<code>removeIf</code>的默认实现，但实际上不能保持类的基本承诺：自动同步每个方法调用。 默认实现对同步一无所知，并且不能访问包含锁定对象的属性。 如果客户端在另一个线程同时修改集合的情况下调用<code>SynchronizedCollection</code>实例上的<code>removeIf</code>方法，则可能会导致<code>ConcurrentModificationException</code>异常或其他未指定的行为。</p><p>为了防止在类似的Java平台类库实现中发生这种情况，比如<code>Collections.synchronizedCollection</code>返回的包级私有的类，JDK维护者必须重写默认的<code>removeIf</code>实现和其他类似的方法来在调用默认实现之前执行必要的同步。 原来不属于Java平台的集合实现没有机会与接口更改进行类似的改变，有些还没有这样做。</p><p><strong>在默认方法的情况下，接口的现有实现类可以在没有错误或警告的情况下编译，但在运行时会失败</strong>。 虽然不是非常普遍，但这个问题也不是一个孤立的事件。 在Java 8中添加到集合接口的一些方法已知是易受影响的，并且已知一些现有的实现会受到影响。</p><p>应该避免使用默认方法向现有的接口添加新的方法，除非这个需要是关键的，在这种情况下，你应该仔细考虑，以确定现有的接口实现是否会被默认的方法实现所破坏。然而，默认方法对于在创建接口时提供标准的方法实现非常有用，以减轻实现接口的任务（条目 20）。</p><p>还值得注意的是，默认方法不是被用来设计，来支持从接口中移除方法或者改变现有方法的签名的目的。在不破坏现有客户端的情况下，这些接口都不可能发生更改。</p><p>准则是清楚的。 尽管默认方法现在是Java平台的一部分，<strong>但是非常悉心地设计接口仍然是非常重要的</strong>。 虽然默认方法可以将方法添加到现有的接口，但这样做有很大的风险。 如果一个接口包含一个小缺陷，可能会永远惹怒用户。 如果一个接口严重缺陷，可能会破坏包含它的API。</p><p>因此，在发布之前测试每个新接口是非常重要的。 多个程序员应该以不同的方式实现每个接口。 至少，你应该准备三种不同的实现。 编写多个使用每个新接口的实例来执行各种任务的客户端程序同样重要。 这将大大确保每个接口都能满足其所有的预期用途。 这些步骤将允许你在发布之前发现接口中的缺陷，但仍然可以轻松地修正它们。 <strong>虽然在接口被发布后可能会修正一些存在的缺陷，但不要太指望这一点</strong>。</p><h2 id="22-接口仅用来定义类型"><a href="#22-接口仅用来定义类型" class="headerlink" title="22. 接口仅用来定义类型"></a>22. 接口仅用来定义类型</h2><p>当类实现接口时，该接口作为一种类型（type），可以用来引用类的实例。因此，一个类实现了一个接口，因此表明客户端可以如何处理类的实例。为其他目的定义接口是不合适的。</p><p>一种失败的接口就是所谓的常量接口（constant interface）。 这样的接口不包含任何方法; 它只包含静态final属性，每个输出一个常量。 使用这些常量的类实现接口，以避免需要用类名限定常量名。 这里是一个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// Constant interface antipattern - do not use!</span><br><span class="line">public interface PhysicalConstants &#123;</span><br><span class="line">    // Avogadro&apos;s number (1/mol)</span><br><span class="line">    static final double AVOGADROS_NUMBER   = 6.022_140_857e23;</span><br><span class="line"></span><br><span class="line">    // Boltzmann constant (J/K)</span><br><span class="line">    static final double BOLTZMANN_CONSTANT = 1.380_648_52e-23;</span><br><span class="line"></span><br><span class="line">    // Mass of the electron (kg)</span><br><span class="line">    static final double ELECTRON_MASS      = 9.109_383_56e-31;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>常量接口模式是对接口的糟糕使用</strong>。类在内部使用一些常量，完全属于实现细节。实现一个常量接口会导致这个实现细节泄漏到类的导出API中。对类的用户来说，类实现一个常量接口是没有意义的。事实上，它甚至可能使他们感到困惑。更糟糕的是，它代表了一个承诺：如果在将来的版本中修改了类，不再需要使用常量，那么它仍然必须实现接口，以确保二进制兼容性。如果一个非final类实现了常量接口，那么它的所有子类的命名空间都会被接口中的常量所污染。</p><p>Java平台类库中有多个常量接口，如<code>java.io.ObjectStreamConstants</code>。 这些接口应该被视为不规范的，不应该被效仿。</p><p>如果你想导出常量，有几个合理的选择方案。 如果常量与现有的类或接口紧密相关，则应将其添加到该类或接口中。 例如，所有数字基本类型的包装类，如<code>Integer</code>和<code>Double</code>，都会导出<code>MIN_VALUE</code>和<code>MAX_VALUE</code>常量。 如果常量最好被看作枚举类型的成员，则应该使用枚举类型（条目 34）导出它们。 否则，你应该用一个不可实例化的工具类来导出常量（条目 4）。 下是前面所示的<code>PhysicalConstants</code>示例的工具类的版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// Constant utility class</span><br><span class="line">package com.effectivejava.science;</span><br><span class="line"></span><br><span class="line">public class PhysicalConstants &#123;</span><br><span class="line">  private PhysicalConstants() &#123; &#125;  // Prevents instantiation</span><br><span class="line"></span><br><span class="line">  public static final double AVOGADROS_NUMBER = 6.022_140_857e23;</span><br><span class="line">  public static final double BOLTZMANN_CONST  = 1.380_648_52e-23;</span><br><span class="line">  public static final double ELECTRON_MASS    = 9.109_383_56e-31;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顺便提一下，请注意在数字文字中使用下划线字符（_）。 从Java 7开始，合法的下划线对数字字面量的值没有影响，但是如果使用得当的话可以使它们更容易阅读。 无论是固定的浮点数，如果他们包含五个或更多的连续数字，考虑将下划线添加到数字字面量中。 对于底数为10的数字，无论是整型还是浮点型的，都应该用下划线将数字分成三个数字组，表示一千的正负幂。</p><p>通常，实用工具类要求客户端使用类名来限定常量名，例如<code>PhysicalConstants.AVOGADROS_NUMBER</code>。 <strong>如果大量使用实用工具类导出的常量，则通过使用静态导入来限定具有类名的常量</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// Use of static import to avoid qualifying constants</span><br><span class="line">import static com.effectivejava.science.PhysicalConstants.*;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line">    double  atoms(double mols) &#123;</span><br><span class="line">        return AVOGADROS_NUMBER * mols;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    // Many more uses of PhysicalConstants justify static import</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总之，接口只能用于定义类型。 它们不应该仅用于导出常量。</p><h2 id="23-优先使用类层次而不是标签类"><a href="#23-优先使用类层次而不是标签类" class="headerlink" title="23. 优先使用类层次而不是标签类"></a>23. 优先使用类层次而不是标签类</h2><p>有时你可能会碰到一个类，它的实例有两个或更多的风格，并且包含一个标签属性（tag field），表示实例的风格。 例如，考虑这个类，它可以表示一个圆形或矩形：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">// Tagged class - vastly inferior to a class hierarchy!</span><br><span class="line">class Figure &#123;</span><br><span class="line">    enum Shape &#123; RECTANGLE, CIRCLE &#125;;</span><br><span class="line"></span><br><span class="line">    // Tag field - the shape of this figure</span><br><span class="line">    final Shape shape;</span><br><span class="line"></span><br><span class="line">    // These fields are used only if shape is RECTANGLE</span><br><span class="line">    double length;</span><br><span class="line">    double width;</span><br><span class="line"></span><br><span class="line">    // This field is used only if shape is CIRCLE</span><br><span class="line">    double radius;</span><br><span class="line"></span><br><span class="line">    // Constructor for circle</span><br><span class="line">    Figure(double radius) &#123;</span><br><span class="line">        shape = Shape.CIRCLE;</span><br><span class="line">        this.radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Constructor for rectangle</span><br><span class="line">    Figure(double length, double width) &#123;</span><br><span class="line">        shape = Shape.RECTANGLE;</span><br><span class="line">        this.length = length;</span><br><span class="line">        this.width = width;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    double area() &#123;</span><br><span class="line">        switch(shape) &#123;</span><br><span class="line">          case RECTANGLE:</span><br><span class="line">            return length * width;</span><br><span class="line">          case CIRCLE:</span><br><span class="line">            return Math.PI * (radius * radius);</span><br><span class="line">          default:</span><br><span class="line">            throw new AssertionError(shape);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的标签类具有许多缺点。 他们杂乱无章的样板代码，包括枚举声明，标签属性和switch语句。 可读性更差，因为多个实现在一个类中混杂在一起。 内存使用增加，因为实例负担属于其他风格不相关的领域。 属性不能成为final，除非构造方法初始化不相关的属性，导致更多的样板代码。 构造方法在编译器的帮助下，必须设置标签属性并初始化正确的数据属性：如果初始化错误的属性，程序将在运行时失败。 除非可以修改其源文件，否则不能将其添加到标记的类中。 如果你添加一个风格，你必须记得给每个switch语句添加一个case，否则这个类将在运行时失败。 最后，一个实例的数据类型没有提供任何关于风格的线索。 总之，<strong>标签类是冗长的，容易出错的，而且效率低下</strong>。</p><p>幸运的是，像Java这样的面向对象的语言为定义一个能够表示多种风格对象的单一数据类型提供了更好的选择：子类型化（subtyping）。标签类仅仅是一个类层次的简单的模仿。</p><p>要将标签类转换为类层次，首先定义一个包含抽象方法的抽象类，该标签类的行为取决于标签值。 在<code>Figure</code>类中，只有一个这样的方法，就是<code>area</code>方法。 这个抽象类是类层次的根。 如果有任何方法的行为不依赖于标签的值，把它们放在这个类中。 同样，如果有所有的方法使用的数据属性，把它们放在这个类。<code>Figure</code>类中不存在这种与类型无关的方法或属性。</p><p>接下来，为原始标签类的每种类型定义一个根类的具体子类。 在我们的例子中，有两个类型：圆形和矩形。 在每个子类中包含特定于改类型的数据字段。 在我们的例子中，半径属性是属于圆的，长度和宽度属性都是矩形的。 还要在每个子类中包含根类中每个抽象方法的适当实现。 这里是对应于Figure类的类层次：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// Class hierarchy replacement for a tagged class</span><br><span class="line">abstract class Figure &#123;</span><br><span class="line">    abstract double area();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Circle extends Figure &#123;</span><br><span class="line">    final double radius;</span><br><span class="line"></span><br><span class="line">    Circle(double radius) &#123; this.radius = radius; &#125;</span><br><span class="line"></span><br><span class="line">    @Override double area() &#123; return Math.PI * (radius * radius); &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Rectangle extends Figure &#123;</span><br><span class="line">    final double length;</span><br><span class="line">    final double width;</span><br><span class="line"></span><br><span class="line">    Rectangle(double length, double width) &#123;</span><br><span class="line">        this.length = length;</span><br><span class="line">        this.width  = width;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override double area() &#123; return length * width; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类层次纠正了之前提到的标签类的每个缺点。 代码简单明了，不包含原文中的样板文件。 每种类型的实现都是由自己的类来分配的，而这些类都没有被无关的数据属性所占用。 所有的属性是final的。 编译器确保每个类的构造方法初始化其数据属性，并且每个类都有一个针对在根类中声明的每个抽象方法的实现。 这消除了由于缺少switch-case语句而导致的运行时失败的可能性。 多个程序员可以独立地继承类层次，并且可以相互操作，而无需访问根类的源代码。 每种类型都有一个独立的数据类型与之相关联，允许程序员指出变量的类型，并将变量和输入参数限制为特定的类型。</p><p>类层次的另一个优点是可以使它们反映类型之间的自然层次关系，从而提高了灵活性，并提高了编译时类型检查的效率。 假设原始示例中的标签类也允许使用正方形。 类层次可以用来反映一个正方形是一种特殊的矩形（假设它们是不可变的）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lass Square extends Rectangle &#123;</span><br><span class="line">    Square(double side) &#123;</span><br><span class="line">        super(side, side);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，上述层中的属性是直接访问的，而不是访问方法。 这里是为了简洁起见，如果类层次是公开的（条目16），这将是一个糟糕的设计。</p><p>总之，标签类很少有适用的情况。 如果你想写一个带有明显标签属性的类，请考虑标签属性是否可以被删除，而类是否被类层次替换。 当遇到一个带有标签属性的现有类时，可以考虑将其重构为一个类层次中。</p><h2 id="24-优先考虑静态成员类"><a href="#24-优先考虑静态成员类" class="headerlink" title="24.优先考虑静态成员类"></a>24.优先考虑静态成员类</h2><p>嵌套类（nested class）是在另一个类中定义的类。 嵌套类应该只存在于其宿主类（enclosing class）中。 如果一个嵌套类在其他一些情况下是有用的，那么它应该是一个顶级类。 有四种嵌套类：静态成员类，非静态成员类，匿名类和局部类。 除了第一种以外，剩下的三种都被称为内部类（inner class）。 这个条目告诉你什么时候使用哪种类型的嵌套类以及为什么使用。</p><p>静态成员类是最简单的嵌套类。 最好把它看作是一个普通的类，恰好在另一个类中声明，并且可以访问所有宿主类的成员，甚至是那些被声明为私有类的成员。 静态成员类是其宿主类的静态成员，并遵循与其他静态成员相同的可访问性规则。 如果它被声明为private，则只能在宿主类中访问，等等。</p><p>静态成员类的一个常见用途是作为公共帮助类，仅在与其外部类一起使用时才有用。 例如，考虑一个描述计算器支持的操作的枚举类型（条目 34）。 <code>Operation</code>枚举应该是<code>Calculator</code>类的公共静态成员类。 <code>Calculator</code>客户端可以使用<code>Calculator.Operation.PLUS</code>和<code>Calculator.Operation.MINUS</code>等名称来引用操作。</p><p>在语法上，静态成员类和非静态成员类之间的唯一区别是静态成员类在其声明中具有static修饰符。 尽管句法相似，但这两种嵌套类是非常不同的。 非静态成员类的每个实例都隐含地与其包含的类的宿主实例相关联。 在非静态成员类的实例方法中，可以调用宿主实例上的方法，或者使用限定的构造[JLS，15.8.4]获得对宿主实例的引用。 如果嵌套类的实例可以与其宿主类的实例隔离存在，那么嵌套类必须是静态成员类：不可能在没有宿主实例的情况下创建非静态成员类的实例。</p><p>非静态成员类实例和其宿主实例之间的关联是在创建成员类实例时建立的，并且之后不能被修改。 通常情况下，通过在宿主类的实例方法中调用非静态成员类构造方法来自动建立关联。 尽管很少有可能使用表达式<code>enclosingInstance.new MemberClass(args)</code>手动建立关联。 正如你所预料的那样，该关联在非静态成员类实例中占用了空间，并为其构建添加了时间开销。</p><p>非静态成员类的一个常见用法是定义一个Adapter [Gamma95]，它允许将外部类的实例视为某个不相关类的实例。 例如，Map接口的实现通常使用非静态成员类来实现它们的集合视图，这些视图由Map的<code>keySet</code>，<code>entrySet</code>和<code>values</code>方法返回。 同样，集合接口（如Set和List）的实现通常使用非静态成员类来实现它们的迭代器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// Typical use of a nonstatic member class</span><br><span class="line">public class MySet&lt;E&gt; extends AbstractSet&lt;E&gt; &#123;</span><br><span class="line">    ... // Bulk of the class omitted</span><br><span class="line"></span><br><span class="line">    @Override public Iterator&lt;E&gt; iterator() &#123;</span><br><span class="line">        return new MyIterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private class MyIterator implements Iterator&lt;E&gt; &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如果你声明了一个不需要访问宿主实例的成员类，总是把static修饰符放在它的声明中，使它成为一个静态成员类，而不是非静态的成员类</strong>。 如果你忽略了这个修饰符，每个实例都会有一个隐藏的外部引用给它的宿主实例。 如前所述，存储这个引用需要占用时间和空间。 更严重的是，并且会导致即使宿主类在满足垃圾回收的条件时却仍然驻留在内存中（条目 7）。 由此产生的内存泄漏可能是灾难性的。 由于引用是不可见的，所以通常难以检测到。</p><p>私有静态成员类的常见用法是表示由它们的宿主类表示的对象的组件。 例如，考虑将键与值相关联的Map实例。 许多Map实现对于映射中的每个键值对都有一个内部的<code>Entr</code>y对象。 当每个<code>entry</code>都与Map关联时，<code>entry</code>上的方法(<code>getKey</code>，<code>getValue</code>和<code>setValue</code>)不需要访问Map。 因此，使用非静态成员类来表示entry将是浪费的：私有静态成员类是最好的。 如果意外地忽略了<code>entry</code>声明中的static修饰符，Map仍然可以工作，但是每个entry都会包含对Map的引用，浪费空间和时间。</p><p>如果所讨论的类是导出类的公共或受保护成员，则在静态和非静态成员类之间正确选择是非常重要的。 在这种情况下，成员类是导出的API元素，如果不违反向后兼容性，就不能在后续版本中从非静态变为静态成员类。</p><p>正如你所期望的，一个匿名类没有名字。 它不是其宿主类的成员。 它不是与其他成员一起声明，而是在使用时同时声明和实例化。 在表达式合法的代码中，匿名类是允许的。 当且仅当它们出现在非静态上下文中时，匿名类才会封装实例。 但是，即使它们出现在静态上下文中，它们也不能有除常量型变量之外的任何静态成员，这些常量型变量包括final的基本类型，或者初始化常量表达式的字符串属性[JLS，4.12.4]。</p><p>匿名类的适用性有很多限制。 除了在声明的时候之外，不能实例化它们。 你不能执行<code>instanceof</code>方法测试或者做任何其他需要你命名的类。 不能声明一个匿名类来实现多个接口，或者继承一个类并同时实现一个接口。 匿名类的客户端不能调用除父类型继承的成员以外的任何成员。 因为匿名类在表达式中出现，所以它们必须保持短——约十行或更少——否则可读性将受损。</p><p>在将lambda表达式添加到Java（第6章）之前，匿名类是创建小方法对象和处理对象的首选方法，但lambda表达式现在是首选（条目 42）。 匿名类的另一个常见用途是实现静态工厂方法（请参阅条目 20中的intArrayAsList）。</p><p>局部类是四种嵌套类中使用最少的。 一个局部类可以在任何可以声明局部变量的地方声明，并遵守相同的作用域规则。 局部类与其他类型的嵌套类具有共同的属性。 像成员类一样，他们有名字，可以重复使用。 就像匿名类一样，只有在非静态上下文中定义它们时，它们才会包含实例，并且它们不能包含静态成员。 像匿名类一样，应该保持简短，以免损害可读性。</p><p>回顾一下，有四种不同的嵌套类，每个都有它的用途。 如果一个嵌套的类需要在一个方法之外可见，或者太长而不能很好地适应一个方法，使用一个成员类。 如果一个成员类的每个实例都需要一个对其宿主实例的引用，使其成为非静态的; 否则，使其静态。 假设这个类属于一个方法内部，如果你只需要从一个地方创建实例，并且存在一个预置类型来说明这个类的特征，那么把它作为一个匿名类; 否则，把它变成局部类。</p><h2 id="25-将源文件限制为单个顶级类"><a href="#25-将源文件限制为单个顶级类" class="headerlink" title="25. 将源文件限制为单个顶级类"></a>25. 将源文件限制为单个顶级类</h2><p>虽然Java编译器允许在单个源文件中定义多个顶级类，但这样做没有任何好处，并且存在重大风险。 风险源于在源文件中定义多个顶级类使得为类提供多个定义成为可能。 使用哪个定义会受到源文件传递给编译器的顺序的影响。</p><p>为了具体说明，请考虑下面源文件，其中只包含一个引用其他两个顶级类（<code>Utensil</code>和<code>Dessert</code>类）的成员的<code>Main</code>类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(Utensil.NAME + [Dessert.NAME](http://Dessert.NAME));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在假设在<code>Utensil.java</code>的源文件中同时定义了<code>Utensil</code>和<code>Dessert</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// Two classes defined in one file. Don&apos;t ever do this!</span><br><span class="line"></span><br><span class="line">class Utensil &#123;</span><br><span class="line"></span><br><span class="line">    static final String NAME = &quot;pan&quot;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dessert &#123;</span><br><span class="line"></span><br><span class="line">    static final String NAME = &quot;cake&quot;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，main方法会打印<code>pancake</code>。</p><p>现在假设你不小心创建了另一个名为<code>Dessert.java</code>的源文件，它定义了相同的两个类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// Two classes defined in one file. Don&apos;t ever do this!</span><br><span class="line"></span><br><span class="line">class Utensil &#123;</span><br><span class="line"></span><br><span class="line">    static final String NAME = &quot;pot&quot;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dessert &#123;</span><br><span class="line"></span><br><span class="line">    static final String NAME = &quot;pie&quot;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你足够幸运，使用命令<code>javac Main.java Dessert.java</code>编译程序，编译将失败，编译器会告诉你，你已经多次定义了类<code>Utensil</code>和<code>Dessert</code>。 这是因为编译器首先编译<code>Main.java</code>，当它看到对<code>Utensil</code>的引用（它在<code>Dessert</code>的引用之前）时，它将在<code>Utensil.java</code>中查找这个类并找到<code>Utensil</code>和<code>Dessert</code>。 当编译器在命令行上遇到<code>Dessert.java</code>时，它也将拉入该文件，导致它遇到<code>Utensil</code>和<code>Dessert</code>的定义。</p><p>如果使用命令<code>javac Main.java</code>或<code>javac Main.java Utensil.java</code>编译程序，它的行为与在编写<code>Dessert.java</code>文件（即打印<code>pancake</code>）之前的行为相同。 但是，如果使用命令<code>javac Dessert.java Main.java</code>编译程序，它将打印<code>potpie</code>。 程序的行为因此受到源文件传递给编译器的顺序的影响，这显然是不可接受的。</p><p>解决这个问题很简单，将顶层类（如我们的例子中的<code>Utensil</code>和<code>Dessert</code>）分割成单独的源文件。 如果试图将多个顶级类放入单个源文件中，请考虑使用静态成员类（条目 24）作为将类拆分为单独的源文件的替代方法。 如果这些类从属于另一个类，那么将它们变成静态成员类通常是更好的选择，因为它提高了可读性，并且可以通过声明它们为私有（条目 15）来减少类的可访问性。下面是我们的例子看起来如何使用静态成员类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// Static member classes instead of multiple top-level classes</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(Utensil.NAME + [Dessert.NAME](http://Dessert.NAME));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class Utensil &#123;</span><br><span class="line"></span><br><span class="line">        static final String NAME = &quot;pan&quot;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class Dessert &#123;</span><br><span class="line"></span><br><span class="line">        static final String NAME = &quot;cake&quot;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个教训很清楚：<strong>永远不要将多个顶级类或接口放在一个源文件中</strong>。 遵循这个规则保证在编译时不能有多个定义。 这又保证了编译生成的类文件以及生成的程序的行为与源文件传递给编译器的顺序无关。</p><p>自Java 5以来，泛型已经成为该语言的一部分。 在泛型之前，你必须转换从集合中读取的每个对象。 如果有人不小心插入了错误类型的对象，则在运行时可能会失败。 使用泛型，你告诉编译器在每个集合中允许哪些类型的对象。 编译器会自动插入强制转换，并在编译时告诉你是否尝试插入错误类型的对象。 这样做的结果是既安全又清晰的程序，但这些益处，不限于集合，是有代价的。 本章告诉你如何最大限度地提高益处，并将并发症降至最低。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;21-为后代设计接口&quot;&gt;&lt;a href=&quot;#21-为后代设计接口&quot; class=&quot;headerlink&quot; title=&quot;21. 为后代设计接口&quot;&gt;&lt;/a&gt;21. 为后代设计接口&lt;/h2&gt;&lt;p&gt;在Java 8之前，不可能在不破坏现有实现的情况下为接口添加方法。 如果
      
    
    </summary>
    
      <category term="java" scheme="http://luxiangdong.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>Effective Java中文版(item:16-20)</title>
    <link href="http://luxiangdong.com/2018/05/09/effective-java-cn-16-20/"/>
    <id>http://luxiangdong.com/2018/05/09/effective-java-cn-16-20/</id>
    <published>2018-05-09T01:24:57.000Z</published>
    <updated>2018-05-09T02:56:36.215Z</updated>
    
    <content type="html"><![CDATA[<h2 id="16-在公共类中使用访问方法而不是公共属性"><a href="#16-在公共类中使用访问方法而不是公共属性" class="headerlink" title="16. 在公共类中使用访问方法而不是公共属性"></a>16. 在公共类中使用访问方法而不是公共属性</h2><p>有时候，你可能会试图写一些退化的类（degenerate classes），除了集中实例属性之外别无用处：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Degenerate classes like this should not be public!</span><br><span class="line">class Point &#123;</span><br><span class="line">    public double x;</span><br><span class="line">    public double y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于这些类的数据属性可以直接被访问，因此这些类不提供封装的好处（条目 15）。 如果不更改API，则无法更改其表示形式，无法强制执行不变量，并且在访问属性时无法执行辅助操作。 坚持面向对象的程序员觉得这样的类是厌恶的，应该被具有私有属性和公共访问方法的类（getter）所取代，而对于可变类来说，它们应该被替换为setter设值方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// Encapsulation of data by accessor methods and mutators</span><br><span class="line">class Point &#123;</span><br><span class="line">    private double x;</span><br><span class="line">    private double y;</span><br><span class="line"></span><br><span class="line">    public Point(double x, double y) &#123;</span><br><span class="line">        this.x = x;</span><br><span class="line">        this.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public double getX() &#123; return x; &#125;</span><br><span class="line"></span><br><span class="line">    public double getY() &#123; return y; &#125;</span><br><span class="line"></span><br><span class="line">    public void setX(double x) &#123; this.x = x; &#125;</span><br><span class="line"></span><br><span class="line">    public void setY(double y) &#123; this.y = y; &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，对于公共类来说，坚持面向对象是正确的：<strong>如果一个类在其包之外是可访问的，则提供访问方法</strong>来保留更改类内部表示的灵活性。如果一个公共类暴露其数据属性，那么以后更改其表示形式基本上没有可能，因为客户端代码可以散布在很多地方。</p><p>但是，<strong>如果一个类是包级私有的，或者是一个私有的内部类，那么暴露它的数据属性就没有什么本质上的错误</strong>——假设它们提供足够描述该类提供的抽象。在类定义和使用它的客户端代码中，这种方法比访问方法产生更少的视觉混乱。 虽然客户端代码绑定到类的内部表示，但是这些代码仅限于包含该类的包。 如果类的内部表示是可取的，可以在不触碰包外的任何代码的情况下进行更改。 在私有内部类的情况下，更改作用范围进一步限制在封闭类中。</p><p>Java平台类库中的几个类违反了公共类不应直接暴露属性的建议。 着名的例子包括java.awt包中的<code>Point</code>和<code>Dimension</code>类。 这些类别应该被视为警示性的示例，而不是模仿的例子。 如条目 67所述，暴露<code>Dimension</code>的内部结构的决定是一个严重的性能问题，这个问题在今天仍然存在。</p><p>虽然公共类直接暴露属性并不是一个好主意，但是如果属性是不可变的，那么危害就不那么大了。当一个属性是只读的时候，除了更改类的API外，你不能改变类的内部表示形式，也不能采取一些辅助的行为，但是可以加强不变性。例如，下面的例子中保证每个实例表示一个有效的时间：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// Public class with exposed immutable fields - questionable</span><br><span class="line"></span><br><span class="line">public final class Time &#123;</span><br><span class="line">    private static final int HOURS_PER_DAY    = 24;</span><br><span class="line">    private static final int MINUTES_PER_HOUR = 60;</span><br><span class="line">    public final int hour;</span><br><span class="line">    public final int minute;</span><br><span class="line"></span><br><span class="line">    public Time(int hour, int minute) &#123;</span><br><span class="line">        if (hour &lt; 0 || hour &gt;= HOURS_PER_DAY)</span><br><span class="line">           throw new IllegalArgumentException(&quot;Hour: &quot; + hour);</span><br><span class="line">        if (minute &lt; 0 || minute &gt;= MINUTES_PER_HOUR)</span><br><span class="line">           throw new IllegalArgumentException(&quot;Min: &quot; + minute);</span><br><span class="line">        this.hour = hour;</span><br><span class="line">        this.minute = minute;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ... // Remainder omitted</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总之，公共类不应该暴露可变属性。 公共累暴露不可变属性的危害虽然仍然存在问题，但其危害较小。 然而，有时需要包级私有或私有内部类来暴露属性，无论此类是否是可变的。</p><h2 id="17-最小化可变性"><a href="#17-最小化可变性" class="headerlink" title="17. 最小化可变性"></a>17. 最小化可变性</h2><p>不可变类简单来说是它的实例不能被修改的类。 包含在每个实例中的所有信息在对象的生命周期中是固定的，因此不会观察到任何变化。 Java平台类库包含许多不可变的类，包括String类，基本类型包装类以及BigInteger类和BigDecimal类。 有很多很好的理由：不可变类比可变类更容易设计，实现和使用。 他们不太容易出错，更安全。</p><p>要使一个类不可变，请遵循以下五条规则：</p><ol><li><strong>不要提供修改对象状态的方法</strong>（也称为mutators）。</li><li><strong>确保这个类不能被继承</strong>。 这可以防止粗心的或恶意的子类，假设对象的状态已经改变，从而破坏类的不可变行为。 防止子类化通常是通过final修饰类，但是我们稍后将讨论另一种方法。</li><li><strong>把所有属性设置为final</strong>。通过系统强制执行，清楚地表达了你的意图。 另外，如果一个新创建的实例的引用从一个线程传递到另一个线程而没有同步，就必须保证正确的行为，正如内存模型[JLS，17.5; Goetz06,16]所述。</li><li><strong>把所有的属性设置为private</strong>。 这可以防止客户端获得对属性引用的可变对象的访问权限并直接修改这些对象。 虽然技术上允许不可变类具有包含基本类型数值的公共final属性或对不可变对象的引用，但不建议这样做，因为它不允许在以后的版本中更改内部表示（项目15和16）。</li><li><strong>确保对任何可变组件的互斥访问</strong>。 如果你的类有任何引用可变对象的属性，请确保该类的客户端无法获得对这些对象的引用。 切勿将这样的属性初始化为客户端提供的对象引用，或从访问方法返回属性。 在构造方法，访问方法和<code>readObject方法</code>（条目 88）中进行防御性拷贝（条目 50）。</li></ol><p>以前条目中的许多示例类都是不可变的。 其中这样的类是条目 11中的<code>PhoneNumber</code>类，它具有每个属性的访问方法（accessors），但没有相应的设值方法（mutators）。 这是一个稍微复杂一点的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">// Immutable complex number class</span><br><span class="line"></span><br><span class="line">public final class Complex &#123;</span><br><span class="line"></span><br><span class="line">    private final double re;</span><br><span class="line"></span><br><span class="line">    private final double im;</span><br><span class="line"></span><br><span class="line">    public Complex(double re, double im) &#123;</span><br><span class="line"></span><br><span class="line">        this.re = re;</span><br><span class="line"></span><br><span class="line">        this.im = im;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public double realPart() &#123;</span><br><span class="line"></span><br><span class="line">        return re;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public double imaginaryPart() &#123;</span><br><span class="line"></span><br><span class="line">        return im;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Complex plus(Complex c) &#123;</span><br><span class="line"></span><br><span class="line">        return new Complex(re + c.re, im + c.im);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Complex minus(Complex c) &#123;</span><br><span class="line"></span><br><span class="line">        return new Complex(re - c.re, im - c.im);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Complex times(Complex c) &#123;</span><br><span class="line"></span><br><span class="line">        return new Complex(re * c.re - im * c.im,</span><br><span class="line"></span><br><span class="line">                re * c.im + im * c.re);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Complex dividedBy(Complex c) &#123;</span><br><span class="line"></span><br><span class="line">        double tmp = c.re * c.re + c.im * c.im;</span><br><span class="line"></span><br><span class="line">        return new Complex((re * c.re + im * c.im) / tmp,</span><br><span class="line"></span><br><span class="line">                (im * c.re - re * c.im) / tmp);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line"></span><br><span class="line">    public boolean equals(Object o) &#123;</span><br><span class="line"></span><br><span class="line">        if (o == this) &#123;</span><br><span class="line"></span><br><span class="line">            return true;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!(o instanceof Complex)) &#123;</span><br><span class="line"></span><br><span class="line">            return false;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Complex c = (Complex) o;</span><br><span class="line"></span><br><span class="line">        // See page 47 to find out why we use compare instead of ==</span><br><span class="line"></span><br><span class="line">        return Double.compare(c.re, re) == 0</span><br><span class="line"></span><br><span class="line">                &amp;&amp; Double.compare(c.im, im) == 0;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line"></span><br><span class="line">    public int hashCode() &#123;</span><br><span class="line"></span><br><span class="line">        return 31 * Double.hashCode(re) + Double.hashCode(im);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line"></span><br><span class="line">    public String toString() &#123;</span><br><span class="line"></span><br><span class="line">        return &quot;(&quot; + re + &quot; + &quot; + im + &quot;i)&quot;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类代表了一个复数（包含实部和虚部的数字）。 除了标准的Object方法之外，它还为实部和虚部提供访问方法，并提供四个基本的算术运算：加法，减法，乘法和除法。 注意算术运算如何创建并返回一个新的<code>Complex</code>实例，而不是修改这个实例。 这种模式被称为函数式方法，因为方法返回将操作数应用于函数的结果，而不修改它们。 与其对应的过程（procedural）或命令（imperative）的方法相对比，在这种方法中，将一个过程作用在操作数上，导致其状态改变。 请注意，方法名称是介词（如plus）而不是动词（如add）。 这强调了方法不会改变对象的值的事实。 <code>BigInteger</code>和<code>BigDecimal</code>类没有遵守这个命名约定，并导致许多使用错误。</p><p>如果你不熟悉函数式方法，可能会显得不自然，但它具有不变性，具有许多优点。 <strong>不可变对象很简单</strong>。 一个不可变的对象可以完全处于一种状态，也就是被创建时的状态。 如果确保所有的构造方法都建立了类不变量，那么就保证这些不变量在任何时候都保持不变，使用此类的程序员无需再做额外的工作。 另一方面，可变对象可以具有任意复杂的状态空间。 如果文档没有提供由设置（mutator）方法执行的状态转换的精确描述，那么可靠地使用可变类可能是困难的或不可能的。</p><p><strong>不可变对象本质上是线程安全的; 它们不需要同步</strong>。 被多个线程同时访问它们时并不会被破坏。 这是实现线程安全的最简单方法。 由于没有线程可以观察到另一个线程对不可变对象的影响，所以<strong>不可变对象可以被自由地共享</strong>。 因此，不可变类应鼓励客户端尽可能重用现有的实例。 一个简单的方法是为常用的值提供公共的静态 final常量。 例如，<code>Complex</code>类可能提供这些常量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static final Complex ZERO = new Complex(0, 0);</span><br><span class="line">public static final Complex ONE  = new Complex(1, 0);</span><br><span class="line">public static final Complex I    = new Complex(0, 1);</span><br></pre></td></tr></table></figure><p>这种方法可以更进一步。 一个不可变的类可以提供静态的工厂（条目 1）来缓存经常被请求的实例，以避免在现有的实例中创建新的实例。 所有基本类型的包装类和<code>BigInteger</code>类都是这样做的。 使用这样的静态工厂会使客户端共享实例而不是创建新实例，从而减少内存占用和垃圾回收成本。 在设计新类时，选择静态工厂代替公共构造方法，可以在以后增加缓存的灵活性，而不需要修改客户端。</p><p>不可变对象可以自由分享的结果是，你永远不需要做出防御性拷贝（ defensive copies）（条目 50）。 事实上，永远不需要做任何拷贝，因为这些拷贝永远等于原始对象。 因此，你不需要也不应该在一个不可变的类上提供一个clone方法或拷贝构造方法（copy constructor）（条目 13）。 这一点在Java平台的早期阶段还不是很好理解，所以String类有一个拷贝构造方法，但是它应该尽量很少使用（条目 6）。</p><p><strong>不仅可以共享不可变的对象，而且可以共享内部信息</strong>。 例如，<code>BigInteger</code>类在内部使用符号数值表示法。 符号用int值表示，数值用int数组表示。 <code>negate</code>方法生成了一个数值相同但符号相反的新<code>BigInteger</code>实例。 即使它是可变的，也不需要复制数组；新创建的<code>BigInteger</code>指向与原始相同的内部数组。</p><p><strong>不可变对象为其他对象提供了很好的构件（building blocks）</strong>，无论是可变的还是不可变的。 如果知道一个复杂组件的内部对象不会发生改变，那么维护复杂对象的不变量就容易多了。这一原则的特例是，不可变对象可以构成<code>Map</code>对象的键和<code>Set</code>的元素，一旦不可变对象作为<code>Map</code>的键或<code>Set</code>里的元素，即使破坏了<code>Map</code>和<code>Set</code>的不可变性，但不用担心它们的值会发生变化。</p><p><strong>不可变对象提供了免费的原子失败机制</strong>（条目 76）。它们的状态永远不会改变，所以不可能出现临时的不一致。</p><p><strong>不可变类的主要缺点是对于每个不同的值都需要一个单独的对象</strong>。 创建这些对象可能代价很高，特别是如果是大型的对象下。 例如，假设你有一个百万位的<code>BigInteger</code>    ，你想改变它的低位：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BigInteger moby = ...;</span><br><span class="line"></span><br><span class="line">moby = moby.flipBit(0);</span><br></pre></td></tr></table></figure><p><code>flipBit</code>方法创建一个新的<code>BigInteger</code>实例，也是一百万位长，与原始位置只有一位不同。 该操作需要与<code>BigInteger</code>大小成比例的时间和空间。 将其与<code>java.util.BitSet</code>对比。 像<code>BigIntege</code>r一样，<code>BitSet</code>表示一个任意长度的位序列，但与<code>BigInteger</code>不同，<code>BitSe</code>t是可变的。 <code>BitSet</code>类提供了一种方法，允许你在固定时间内更改百万位实例中单个位的状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BitSet moby = ...;</span><br><span class="line"></span><br><span class="line">moby.flip(0);</span><br></pre></td></tr></table></figure><p>如果执行一个多步操作，在每一步生成一个新对象，除最终结果之外丢弃所有对象，则性能问题会被放大。这里有两种方式来处理这个问题。第一种办法，先猜测一下会经常用到哪些多步的操作，然后讲它们作为基本类型提供。如果一个多步操作是作为一个基本类型提供的，那么不可变类就不必在每一步创建一个独立的对象。在内部，不可变的类可以是任意灵活的。 例如，<code>BigInteger</code>有一个包级私有的可变的“伙伴类（companion class）”，它用来加速多步操作，比如模幂运算（ modular exponentiation）。出于前面所述的所有原因，使用可变伙伴类比使用BigInteger要困难得多。 幸运的是，你不必使用它：<code>BigInteger</code>类的实现者为你做了很多努力。</p><p>如果你可以准确预测客户端要在你的不可变类上执行哪些复杂的操作，那么包级私有可变伙伴类的方式可以正常工作。如果不是的话，那么最好的办法就是提供一个公开的可变伙伴类。 这种方法在Java平台类库中的主要例子是String类，它的可变伙伴类是<code>StringBuilder</code>（及其过时的前身<code>StringBuffer</code>类）。</p><p>现在你已经知道如何创建一个不可改变类，并且了解不变性的优点和缺点，下面我们来讨论几个设计方案。 回想一下，为了保证不变性，一个类不得允许子类化。 这可以通过使类用 final 修饰，但是还有另外一个更灵活的选择。 而不是使不可变类设置为 final，可以使其所有的构造方法私有或包级私有，并添加公共静态工厂，而不是公共构造方法（条目 1）。 为了具体说明这种方法，下面以<code>Complex</code>为例，看看如何使用这种方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// Immutable class with static factories instead of constructors</span><br><span class="line"></span><br><span class="line">public class Complex &#123;</span><br><span class="line"></span><br><span class="line">    private final double re;</span><br><span class="line"></span><br><span class="line">    private final double im;</span><br><span class="line"></span><br><span class="line">    private Complex(double re, double im) &#123;</span><br><span class="line"></span><br><span class="line">        [this.re](http://this.re) = re;</span><br><span class="line"></span><br><span class="line">        [this.im](http://this.im) = im;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Complex valueOf(double re, double im) &#123;</span><br><span class="line"></span><br><span class="line">        return new Complex(re, im);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ... // Remainder unchanged</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法往往是最好的选择。 这是最灵活的，因为它允许使用多个包级私有实现类。 对于驻留在包之外的客户端，不可变类实际上是final的，因为不可能继承来自另一个包的类，并且缺少公共或受保护的构造方法。 除了允许多个实现类的灵活性以外，这种方法还可以通过改进静态工厂的对象缓存功能来调整后续版本中类的性能。</p><p>当<code>BigInteger</code>和<code>BigDecimal</code>被写入时，不可变类必须是有效的final，因此它们的所有方法都可能被重写。不幸的是，在保持向后兼容性的同时，这一事实无法纠正。如果你编写一个安全性取决于来自不受信任的客户端的<code>BigIntege</code>r或<code>BigDecimal</code>参数的不变类时，则必须检查该参数是“真实的”<code>BigInteger</code>还是<code>BigDecimal</code>，而不应该是不受信任的子类的实例。如果是后者，则必须在假设可能是可变的情况下保护性拷贝（defensively copy）（条目 50）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static BigInteger safeInstance(BigInteger val) &#123;</span><br><span class="line"></span><br><span class="line">    return val.getClass() == BigInteger.class ?</span><br><span class="line">            val : new BigInteger(val.toByteArray());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在本条目开头关于不可变类的规则说明，没有方法可以修改对象，并且它的所有属性必须是final的。事实上，这些规则比实际需要的要强硬一些，其实可以有所放松来提高性能。 事实上，任何方法都不能在对象的状态中产生外部可见的变化。 然而，一些不可变类具有一个或多个非final属性，在第一次需要时将开销昂贵的计算结果缓存在这些属性中。 如果再次请求相同的值，则返回缓存的值，从而节省了重新计算的成本。 这个技巧的作用恰恰是因为对象是不可变的，这保证了如果重复的话，计算会得到相同的结果。</p><p>例如，<code>PhoneNumber</code>类的<code>hashCode</code>方法（第53页的条目 11）在第一次调用改方法时计算哈希码，并在再次调用时对其进行缓存。 这种延迟初始化（条目 83）的一个例子，String类也使用到了。</p><p>关于序列化应该加上一个警告。 如果你选择使您的不可变类实现Serializable接口，并且它包含一个或多个引用可变对象的属性，则必须提供显式的<code>readObject</code>或<code>readResolve</code>方法，或者使用<code>ObjectOutputStream.writeUnshared</code>和<code>ObjectInputStream.readUnshared</code>方法，即默认的序列化形式也是可以接受的。 否则攻击者可能会创建一个可变的类的实例。 这个主题会在条目 88中会详细介绍。</p><p>总而言之，坚决不要为每个属性编写一个get方法后再编写一个对应的set方法。 <strong>除非有充分的理由使类成为可变类，否则类应该是不可变的</strong>。 不可变类提供了许多优点，唯一的缺点是在某些情况下可能会出现性能问题。 你应该始终使用较小的值对象（如<code>PhoneNumber</code>和<code>Complex</code>），使其不可变。 （Java平台类库中有几个类，如<code>java.util.Date</code>和<code>java.awt.Point</code>，本应该是不可变的，但实际上并不是）。你应该认真考虑创建更大的值对象，例如<code>String</code>和<code>BigInteger</code> ，设成不可改变的。 只有当你确认有必要实现令人满意的性能（条目 67）时，才应该为不可改变类提供一个公开的可变伙伴类。</p><p>对于一些类来说，不变性是不切实际的。<strong>如果一个类不能设计为不可变类，那么也要尽可能地限制它的可变性</strong>。减少对象可以存在的状态数量，可以更容易地分析对象，以及降低出错的可能性。因此，除非有足够的理由把属性设置为非 final 的情况下，否则应该每个属性都设置为 final 的。把本条目的建议与条目15的建议结合起来，你自然的倾向就是：<strong>除非有充分的理由不这样做，否则应该把每个属性声明为私有final的</strong>。</p><p><strong>构造方法应该创建完全初始化的对象，并建立所有的不变性</strong>。 除非有令人信服的理由，否则不要提供独立于构造方法或静态工厂的公共初始化方法。 同样，不要提供一个“reinitialize”方法，使对象可以被重用，就好像它是用不同的初始状态构建的。 这样的方法通常以增加的复杂度为代价，仅仅提供很少的性能优势。</p><p><code>CountDownLatch</code>类是这些原理的例证。 它是可变的，但它的状态空间有意保持最小范围内。 创建一个实例，使用它一次，并完成：一旦countdown锁的计数器已经达到零，不能再重用它。</p><p>在这个条目中，应该添加关于<code>Complex</code>类的最后一个注释。 这个例子只是为了说明不变性。 这不是一个工业强度复杂的复数实现。 它对复数使用了乘法和除法的标准公式，这些公式不正确会进行不正确的四舍五入，没有为复数的NaN和无穷大提供良好的语义[Kahan91，Smith62，Thomas94]。</p><h2 id="18-组合优于继承"><a href="#18-组合优于继承" class="headerlink" title="18. 组合优于继承"></a>18. 组合优于继承</h2><p>继承是实现代码重用的有效方式，但并不总是最好的工具。使用不当，会导致脆弱的软件。 在包中使用继承是安全的，其中子类和父类的实现都在同一个程序员的控制之下。对应专门为了继承而设计的，并且有文档说明的类来说（条目 19），使用继承也是安全的。 然而，从普通的具体类跨越包级边界继承，是危险的。 提醒一下，本书使用“继承”一词来表示实现继承（当一个类继承另一个类时）。 在这个项目中讨论的问题不适用于接口继承（当类实现接口或当接口继承另一个接口时）。</p><p><strong>与方法调用不同，继承打破了封装</strong>[Snyder86]。 换句话说，一个子类依赖于其父类的实现细节来保证其正确的功能。 父类的实现可能会从发布版本不断变化，如果是这样，子类可能会被破坏，即使它的代码没有任何改变。 因此，一个子类必须与其超类一起更新而变化，除非父类的作者为了继承的目的而专门设计它，并对应有文档的说明。</p><p>为了具体说明，假设有一个使用<code>HashSet</code>的程序。 为了调整程序的性能，需要查询<code>HashSe</code>，从创建它之后已经添加了多少个元素（不要和当前的元素数量混淆，当元素被删除时数量也会下降）。 为了提供这个功能，编写了一个<code>HashSet</code>变体，它保留了尝试元素插入的数量，并导出了这个插入数量的一个访问方法。 <code>HashSet</code>类包含两个添加元素的方法，分别是<code>add</code>和<code>addAll</code>，所以我们重写这两个方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// Broken - Inappropriate use of inheritance!</span><br><span class="line">public class InstrumentedHashSet&lt;E&gt; extends HashSet&lt;E&gt; &#123;</span><br><span class="line">    // The number of attempted element insertions</span><br><span class="line">    private int addCount = 0;</span><br><span class="line"></span><br><span class="line">    public InstrumentedHashSet() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public InstrumentedHashSet(int initCap, float loadFactor) &#123;</span><br><span class="line">        super(initCap, loadFactor);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override public boolean add(E e) &#123;</span><br><span class="line">        addCount++;</span><br><span class="line">        return super.add(e);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override public boolean addAll(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">        addCount += c.size();</span><br><span class="line">        return super.addAll(c);</span><br><span class="line">    &#125;</span><br><span class="line">    public int getAddCount() &#123;</span><br><span class="line">        return addCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类看起来很合理，但是不能正常工作。 假设创建一个实例并使用<code>addAll</code>方法添加三个元素。 顺便提一句，请注意，下面代码使用在Java 9中添加的静态工厂方法<code>List.of</code>来创建一个列表；如果使用的是早期版本，请改为使用<code>Arrays.asList</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InstrumentedHashSet&lt;String&gt; s = new InstrumentedHashSet&lt;&gt;();</span><br><span class="line">s.addAll(List.of(&quot;Snap&quot;, &quot;Crackle&quot;, &quot;Pop&quot;));</span><br></pre></td></tr></table></figure><p>我们期望<code>getAddCount</code>方法返回的结果是3，但实际上返回了6。哪里出来问题？在<code>HashSet</code>内部，<code>addAll</code>方法是基于它的<code>add</code>方法来实现的，即使<code>HashSet</code>文档中没有指名其实现细节，倒也是合理的。<code>InstrumentedHashSet</code>中的<code>addAll</code>方法首先给<code>addCount</code>属性设置为3，然后使用<code>super.addAll</code>方法调用了<code>HashSet</code>的<code>addAll</code>实现。然后反过来又调用在<code>InstrumentedHashSet</code>类中重写的<code>add</code>方法，每个元素调用一次。这三次调用又分别给<code>addCount</code>加1，所以，一共增加了6：通过<code>addAll</code>方法每个增加的元素都被计算了两次。</p><p>我们可以通过消除<code>addAll</code>方法的重写来“修复”子类。 尽管生成的类可以正常工作，但是它依赖于它的正确方法，因为<code>HashSet</code>的<code>addAll</code>方法是在其<code>add</code>方法之上实现的。 这个“自我使用（self-use）”是一个实现细节，并不保证在Java平台的所有实现中都可以适用，并且可以随发布版本而变化。 因此，产生的<code>InstrumentedHashSet</code>类是脆弱的。</p><p>稍微好一点的做法是，重写<code>addAll</code>方法遍历指定集合，为每个元素调用<code>add</code>方法一次。 不管<code>HashSet</code>的<code>addAll</code>方法是否在其<code>add</code>方法上实现，都会保证正确的结果，因为<code>HashSet</code>的<code>addAll</code>实现将不再被调用。然而，这种技术并不能解决所有的问题。 这相当于重新实现了父类方法，这样的方法可能不能确定到底是否时自用（self-use）的，实现起来也是困难的，耗时的，容易出错的，并且可能会降低性能。 此外，这种方式并不能总是奏效，因为子类无法访问一些私有属性，所以有些方法就无法实现。</p><p>导致子类脆弱的一个相关原因是，它们的父类在后续的发布版本中可以添加新的方法。假设一个程序的安全性依赖于这样一个事实：所有被插入到集中的元素都满足一个先决条件。可以通过对集合进行子类化，然后并重写所有添加元素的方法，以确保在添加每个元素之前满足这个先决条件，来确保这一问题。如果在后续的版本中，父类没有新增添加元素的方法，那么这样做没有问题。但是，一旦父类增加了这样的新方法，则很有肯能由于调用了未被重写的新方法，将非法的元素添加到子类的实例中。这不是个纯粹的理论问题。在把<code>Hashtable</code>和<code>Vector</code>类加入到Collections框架中的时候，就修复了几个类似性质的安全漏洞。</p><p>这两个问题都源于重写方法。 如果仅仅添加新的方法并且不要重写现有的方法，可能会认为继承一个类是安全的。 虽然这种扩展更为安全，但这并非没有风险。 如果父类在后续版本中添加了一个新的方法，并且你不幸给了子类一个具有相同签名和不同返回类型的方法，那么你的子类编译失败[JLS，8.4.8.3]。 如果已经为子类提供了一个与新的父类方法具有相同签名和返回类型的方法，那么你现在正在重写它，因此将遇到前面所述的问题。 此外，你的方法是否会履行新的父类方法的约定，这是值得怀疑的，因为在你编写子类方法时，这个约定还没有写出来。</p><p>幸运的是，有一种方法可以避免上述所有的问题。不要继承一个现有的类，而应该给你的新类增加一个私有属性，该属性是 现有类的实例引用，这种设计被称为组合（composition），因为现有的类成为新类的组成部分。新类中的每个实例方法调用现有类的包含实例上的相应方法并返回结果。这被称为转发（forwarding），而新类中的方法被称为转发方法。由此产生的类将坚如磐石，不依赖于现有类的实现细节。即使将新的方法添加到现有的类中，也不会对新类产生影响。为了具体说用，下面代码使用组合和转发方法替代<code>InstrumentedHashSet</code>类。请注意，实现分为两部分，类本身和一个可重用的转发类，其中包含所有的转发方法，没有别的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">// Reusable forwarding class</span><br><span class="line">import java.util.Collection;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line">import java.util.Set;</span><br><span class="line"></span><br><span class="line">public class ForwardingSet&lt;E&gt; implements Set&lt;E&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private final Set&lt;E&gt; s;</span><br><span class="line"></span><br><span class="line">    public ForwardingSet(Set&lt;E&gt; s) &#123;</span><br><span class="line">        this.s = s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void clear() &#123;</span><br><span class="line">        s.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean contains(Object o) &#123;</span><br><span class="line">        return s.contains(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isEmpty() &#123;</span><br><span class="line">        return s.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int size() &#123;</span><br><span class="line">        return s.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Iterator&lt;E&gt; iterator() &#123;</span><br><span class="line">        return s.iterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean add(E e) &#123;</span><br><span class="line">        return s.add(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean remove(Object o) &#123;</span><br><span class="line">        return s.remove(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean containsAll(Collection&lt;?&gt; c) &#123;</span><br><span class="line">        return s.containsAll(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean addAll(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">        return s.addAll(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean removeAll(Collection&lt;?&gt; c) &#123;</span><br><span class="line">        return s.removeAll(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean retainAll(Collection&lt;?&gt; c) &#123;</span><br><span class="line">        return s.retainAll(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object[] toArray() &#123;</span><br><span class="line">        return s.toArray();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">        return s.toArray(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean equals(Object o) &#123;</span><br><span class="line">        return s.equals(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int hashCode() &#123;</span><br><span class="line">        return s.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return s.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// Wrapper class - uses composition in place of inheritance</span><br><span class="line">import java.util.Collection;</span><br><span class="line">import java.util.Set;</span><br><span class="line"></span><br><span class="line">public class InstrumentedSet&lt;E&gt; extends ForwardingSet&lt;E&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private int addCount = 0;</span><br><span class="line"></span><br><span class="line">    public InstrumentedSet(Set&lt;E&gt; s) &#123;</span><br><span class="line">        super(s);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override public boolean add(E e) &#123;</span><br><span class="line">        addCount++;</span><br><span class="line">        return super.add(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override public boolean addAll(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">        addCount += c.size();</span><br><span class="line">        return super.addAll(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAddCount() &#123;</span><br><span class="line">        return addCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>InstrumentedSet</code>类的设计是通过存在的Set接口来实现的，该接口包含<code>HashSet</code>类的功能特性。除了功能强大，这个设计是非常灵活的。<code>InstrumentedSet</code>类实现了Set接口，并有一个构造方法，其参数也是Set类型的。本质上，这个类把<code>Set</code>转换为另一个类型<code>Set</code>， 同时添加了计数的功能。与基于继承的方法不同，该方法仅适用于单个具体类，并且父类中每个需要支持构造方法，提供单独的构造方法，所以可以使用包装类来包装任何<code>Set</code>实现，并且可以与任何预先存在的构造方法结合使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Instant&gt; times = new InstrumentedSet&lt;&gt;(new TreeSet&lt;&gt;(cmp));</span><br><span class="line">Set&lt;E&gt; s = new InstrumentedSet&lt;&gt;(new HashSet&lt;&gt;(INIT_CAPACITY));</span><br></pre></td></tr></table></figure><p><code>InstrumentedSet</code>类甚至可以用于临时替换没有计数功能下使用的集合实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static void walk(Set&lt;Dog&gt; dogs) &#123;</span><br><span class="line">    InstrumentedSet&lt;Dog&gt; iDogs = new InstrumentedSet&lt;&gt;(dogs);</span><br><span class="line">    ... // Within this method use iDogs instead of dogs</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>InstrumentedSet</code>类被称为包装类，因为每个<code>InstrumentedSet</code>实例都包含（“包装”）另一个<code>Set</code>实例。 这也被称为装饰器模式[Gamma95]，因为<code>InstrumentedSet</code>类通过添加计数功能来“装饰”一个集合。 有时组合和转发的结合被不精确地地称为委托（delegation）。 从技术上讲，除非包装对象把自身传递给被包装对象，否则不是委托[Lieberman86;Gamma95]。</p><p>包装类的缺点很少。 一个警告是包装类不适合在回调框架（callback frameworks）中使用，其中对象将自我引用传递给其他对象以用于后续调用（“回调”）。 因为一个被包装的对象不知道它外面的包装对象，所以它传递一个指向自身的引用（this），回调时并不记得外面的包装对象。 这被称为SELF问题[Lieberman86]。 有些人担心转发方法调用的性能影响，以及包装对象对内存占用。 两者在实践中都没有太大的影响。 编写转发方法有些繁琐，但是只需为每个接口编写一次可重用的转发类，并且提供转发类。 例如，Guava为所有的Collection接口提供转发类[Guava]。</p><p>只有在子类真的是父类的子类型的情况下，继承才是合适的。 换句话说，只有在两个类之间存在“is-a”关系的情况下，B类才能继承A类。 如果你试图让B类继承A类时，问自己这个问题：每个B都是A吗？ 如果你不能如实回答这个问题，那么B就不应该继承A。如果答案是否定的，那么B通常包含一个A的私有实例，并且暴露一个不同的API：A不是B的重要部分 ，只是其实现细节。</p><p>在Java平台类库中有一些明显的违反这个原则的情况。 例如，stacks实例并不是vector实例，所以<code>Stack</code>类不应该继承<code>Vector</code>类。 同样，一个属性列表不是一个哈希表，所以<code>Properties</code>不应该继承<code>Hashtable</code>类。 在这两种情况下，组合方式更可取。</p><p>如果在合适组合的地方使用继承，则会不必要地公开实现细节。由此产生的API将与原始实现联系在一起，永远限制类的性能。更严重的是，通过暴露其内部，客户端可以直接访问它们。至少，它可能导致混淆语义。例如，属性p指向<code>Properties</code>实例，那么 <code>p.getProperty(key)</code>和<code>p.get(key)</code>就有可能返回不同的结果：前者考虑了默认的属性表，而后者是继承<code>Hashtable</code>的，它则没有考虑默认属性列表。最严重的是，客户端可以通过直接修改超父类来破坏子类的不变性。在<code>Properties</code>类，设计者希望只有字符串被允许作为键和值，但直接访问底层的<code>Hashtable</code>允许违反这个不变性。一旦违反，就不能再使用属性API的其他部分（<code>load</code>和<code>store</code>方法）。在发现这个问题的时候，纠正这个问题为时已晚，因为客户端依赖于使用非字符串键和值了。</p><p>在决定使用继承来代替组合之前，你应该问自己最后一组问题。对于试图继承的类，它的API有没有缺陷呢？ 如果有，你是否愿意将这些缺陷传播到你的类的API中？继承传播父类的API中的任何缺陷，而组合可以让你设计一个隐藏这些缺陷的新API。</p><p>总之，继承是强大的，但它是有问题的，因为它违反封装。 只有在子类和父类之间存在真正的子类型关系时才适用。 即使如此，如果子类与父类不在同一个包中，并且父类不是为继承而设计的，继承可能会导致脆弱性。 为了避免这种脆弱性，使用合成和转发代替继承，特别是如果存在一个合适的接口来实现包装类。 包装类不仅比子类更健壮，而且更强大。</p><h2 id="19-如果使用继承则设计，并文档说明，否则不该使用"><a href="#19-如果使用继承则设计，并文档说明，否则不该使用" class="headerlink" title="19. 如果使用继承则设计，并文档说明，否则不该使用"></a>19. 如果使用继承则设计，并文档说明，否则不该使用</h2><p>条目 18中提醒你注意继承没有设计和文档说明的“外来”类的子类化的危险。 那么为了继承而设计和文档说明一个类是什么意思呢？</p><p>首先，这个类必须准确地描述重写这个方法带来的影响。 换句话说，该类必须文档说明可重写方法的自用性（self-use）。 对于每个公共或受保护的方法，文档必须指明方法调用哪些重写方法，以何种顺序以及每次调用的结果如何影响后续处理。 （重写方法，这里是指非final修饰的方法，无论是公开还是保护的。）更一般地说，一个类必须文档说明任何可能调用可重写方法的情况。 例如，后台线程或者静态初始化代码块可能会调用这样的方法。</p><p>调用可重写方法的方法在文档注释结束时包含对这些调用的描述。 这些描述在规范中特定部分，标记为“Implementation Requirements,”，由Javadoc标签<code>@implSpec</code>生成。 本节介绍该方法的内部工作原理。 下面是从<code>java.util.AbstractCollection</code>类的规范中拷贝的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public boolean remove(Object o)</span><br><span class="line">Removes a single instance of the specified element from this collection, if it is present (optional operation). More formally, removes an element e such that Objects.equals(o, e), if this collection contains one or more such elements. Returns true if this collection contained the specified element (or equivalently, if this collection changed as a result of the call).</span><br><span class="line"></span><br><span class="line">Implementation Requirements: This implementation iterates over the collection looking for the specified element. If it finds the element, it removes the element from the collection using the iterator’s remove method. Note that this implementation throws an UnsupportedOperationException if the iterator returned by this collection’s iterator method does not implement the remove method and this collection contains the specified object.</span><br></pre></td></tr></table></figure><p>从该集合中删除指定元素的单个实例（如果存在，<code>optional</code>实例操作）。 更正式地说，如果这个集合包含一个或多个这样的元素，删除使得<code>Objects.equals(o, e)</code>的一个元素e。 如果此集合包含指定的元素（或者等同于此集合因调用而发生了更改），则返回true。</p><p><strong>实现要求</strong>：这个实现迭代遍历集合查找指定元素。 如果找到元素，则使用迭代器的<code>remove</code>方法从集合中删除元素。 请注意，如果此集合的<code>iterator</code>方法返回的迭代器未实现<code>remove</code>方法，并且此集合包含指定的对象，则此实现将引发<code>UnsupportedOperationException</code>异常。</p><p>这个文档毫无疑问地说明，重写<code>iterator</code>方法会影响<code>remove</code>方法的行为。 它还描述了<code>iterator</code>方法返回的Iterator行为将如何影响<code>remove</code>方法的行为。 与条目 18中的情况相反，在这种情况下，程序员继承<code>HashSet</code>并不能说明重写add方法是否会影响addAll方法的行为。</p><p>但是，这是否违背了一个良好的API文档应该描述给定的方法是什么，而不是它是如何做的呢？ 是的，它确实！这是继承违反封装这一事实的不幸后果。要文档说明一个类以便可以安全地进行子类化，必须描述清楚那些没有详细说明的实现细节。</p><p><code>@implSpec</code>标签是在Java 8中添加的，并且在Java 9中被大量使用。这个标签应该默认启用，但是从Java 9开始，除非通过命令行开关<code>-tag &quot;apiNote:a:API Note:”</code>，否则Javadoc实用工具仍然会忽略它。</p><p>设计继承涉及的不仅仅是文档说明自用的模式。 为了让程序员能够写出有效的子类而不会带来不适当的痛苦，一个类可能以明智选择的受保护方法的形式提供内部工作，或者在罕见的情况下，提供受保护的属性。 例如，考虑<code>java.util.AbstractList</code>中的<code>removeRange</code>方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">protected void removeRange(int fromIndex, int toIndex)</span><br><span class="line">Removes from this list all of the elements whose index is between fromIndex, inclusive, and toIndex, exclusive. Shifts any succeeding elements to the left (reduces their index). This call shortens the list by (toIndex - fromIndex) elements. (If toIndex == fromIndex, this operation has no effect.)</span><br><span class="line">This method is called by the clear operation on this list and its sublists. Overriding this method to take advantage of the internals of the list implementation can substantially improve the performance of the clear operation on this list and its sublists.</span><br><span class="line">Implementation Requirements: This implementation gets a list iterator positioned before fromIndex and repeatedly calls ListIterator.nextfollowed by ListIterator.remove, until the entire range has been removed. Note: If ListIterator.remove requires linear time, this implementation requires quadratic time.</span><br><span class="line">Parameters:</span><br><span class="line">fromIndex       index of first element to be removed.</span><br><span class="line"></span><br><span class="line">toIndex           index after last element to be removed.</span><br></pre></td></tr></table></figure><p>从此列表中删除索引介于<code>fromIndex</code>（包含）和<code>inclusive</code>（不含）之间的所有元素。 将任何后续元素向左移（减少索引）。 这个调用通过<code>（toIndex - fromIndex）</code>元素来缩短列表。 （如果<code>toIndex == fromIndex</code>，则此操作无效。）</p><p>这个方法是通过列表及其子类的clear操作来调用的。重写这个方法利用列表内部实现的优势，可以大大提高列表和子类的clear操作性能。</p><p>实现要求：这个实现获取一个列表迭代器，它位于<code>fromIndex</code>之前，并重复调用<code>ListIterator.remove</code>和<code>ListIterator.next</code>方法，直到整个范围被删除。 注意：如果<code>ListIterator.remove</code>需要线性时间，则此实现需要平方级时间。</p><p>参数：<br>fromIndex 要移除的第一个元素的索引<br>toIndex 要移除的最后一个元素之后的索引</p><p>这个方法对List实现的最终用户来说是没有意义的。 它仅仅是为了使子类很容易提供一个快速clear方法。 在没有<code>removeRange</code>方法的情况下，当在子列表上调用clear方法，子类将不得不使用平方级的时间，否则，或从头重写整个subList机制——这不是一件容易的事情！</p><p>那么当你设计一个继承类的时候，你如何决定暴露哪些的受保护的成员呢？ 不幸的是，没有灵丹妙药。 所能做的最好的就是努力思考，做出最好的测试，然后通过编写子类来进行测试。 应该尽可能少地暴露受保护的成员，因为每个成员都表示对实现细节的承诺。 另一方面，你不能暴露太少，因为失去了保护的成员会导致一个类几乎不能用于继承。</p><p><strong>测试为继承而设计的类的唯一方法是编写子类</strong>。 如果你忽略了一个关键的受保护的成员，试图编写一个子类将会使得遗漏痛苦地变得明显。 相反，如果编写的几个子类，而且没有一个使用受保护的成员，那么应该将其设为私有。 经验表明，三个子类通常足以测试一个可继承的类。 这些子类应该由父类作者以外的人编写。</p><p>当你为继承设计一个可能被广泛使用的类的时候，要意识到你永远承诺你文档说明的自用模式以及隐含在其保护的方法和属性中的实现决定。 这些承诺可能会使后续版本中改善类的性能或功能变得困难或不可能。 因此，<strong>在发布它之前，你必须通过编写子类来测试你的类</strong>。</p><p>另外，请注意，继承所需的特殊文档混乱了正常的文档，这是为创建类的实例并在其上调用方法的程序员设计的。 在撰写本文时，几乎没有工具将普通的API文档从和仅仅针对子类实现的信息，分离出来。</p><p>还有一些类必须遵守允许继承的限制。 <strong>构造方法绝不能直接或间接调用可重写的方法</strong>。 如果违反这个规则，将导致程序失败。 父类构造方法在子类构造方法之前运行，所以在子类构造方法运行之前，子类中的重写方法被调用。 如果重写方法依赖于子类构造方法执行的任何初始化，则此方法将不会按预期运行。 为了具体说明，这是一个违反这个规则的类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Super &#123;</span><br><span class="line">    // Broken - constructor invokes an overridable method</span><br><span class="line">    public Super() &#123;</span><br><span class="line">        overrideMe();</span><br><span class="line">    &#125;</span><br><span class="line">    public void overrideMe() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是一个重写<code>overrideMe</code>方法的子类，Super类的唯一构造方法会错误地调用它：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public final class Sub extends Super &#123;</span><br><span class="line">    // Blank final, set by constructor</span><br><span class="line">    private final Instant instant;</span><br><span class="line"></span><br><span class="line">    Sub() &#123;</span><br><span class="line">        instant = Instant.now();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Overriding method invoked by superclass constructor</span><br><span class="line">    @Override public void overrideMe() &#123;</span><br><span class="line">        System.out.println(instant);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Sub sub = new Sub();</span><br><span class="line">        sub.overrideMe();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可能期望这个程序打印两次<code>instant</code>实例，但是它第一次打印出null，因为在Sub构造方法有机会初始化<code>instant</code>属性之前，<code>overrideMe</code>被Super构造方法调用。 请注意，这个程序观察两个不同状态的final属性！ 还要注意的是，如果<code>overrideMe</code>方法调用了<code>instant</code>实例中任何方法，那么当父类构造方法调用<code>overrideMe</code>时，它将抛出一个<code>NullPointerException</code>异常。 这个程序不会抛出<code>NullPointerException</code>的唯一原因是<code>println</code>方法容忍null参数。</p><p>请注意，从构造方法中调用私有方法，其中任何一个方法都不可重写的，那么final方法和静态方法是安全的。</p><p><code>Cloneable</code>和<code>Serializable</code>接口在设计继承时会带来特殊的困难。 对于为继承而设计的类来说，实现这些接口通常不是一个好主意，因为这会给继承类的程序员带来很大的负担。 然而，可以采取特殊的行动来允许子类实现这些接口，而不需要强制这样做。 这些操作在条目 13和条目 86中有描述。</p><p>如果你决定在为继承而设计的类中实现<code>Cloneable</code>或<code>Serializable</code>接口，那么应该知道，由于<code>clone</code>和<code>readObjec</code>t方法与构造方法相似，所以也有类似的限制：<strong>clone和readObject都不会直接或间接调用可重写的方法</strong>。在<code>readObject</code>的情况下，重写方法将在子类的状态被反序列化之前运行。 在<code>clone</code>的情况下，重写方法将在子类的<code>clone</code>方法有机会修复克隆的状态之前运行。 在任何一种情况下，都可能会出现程序故障。 在<code>clone</code>的情况下，故障可能会损坏原始对象以及被克隆对象本身。 例如，如果重写方法假定它正在修改对象的深层结构的拷贝，但是尚未创建拷贝，则可能发生这种情况。</p><p>最后，如果你决定在为继承设计的类中实现<code>Serializable</code>接口，并且该类有一个<code>readResolve</code>或<code>writeReplace</code>方法，则必须使<code>readResolve</code>或<code>writeReplace</code>方法设置为受保护而不是私有。 如果这些方法是私有的，它们将被子类无声地忽略。 这是另一种情况，把实现细节成为类的API的一部分，以允许继承。</p><p>到目前为止，<strong>设计一个继承类需要很大的努力，并且对这个类有很大的限制</strong>。 这不是一个轻率的决定。 有些情况显然是正确的，比如抽象类，包括接口的骨架实现（skeletal implementations）（条目 20）。 还有其他的情况显然是错误的，比如不可变的类（条目 17）。</p><p>但是普通的具体类呢？ 传统上，它们既不是final的，也不是为了子类化而设计和文档说明的，但是这种情况是危险的。每次修改这样的类，则继承此类的子类将被破坏。 这不仅仅是一个理论问题。 在修改非final的具体类的内部之后，接收与子类相关的错误报告并不少见，这些类没有为继承而设计和文档说明。</p><p><strong>解决这个问题的最好办法是，在没有想要安全地子类化的设计和文档说明的类中禁止子类化</strong>。 有两种方法禁止子类化。 两者中较容易的是声明类为final。 另一种方法是使所有的构造方法都是私有的或包级私有的，并且添加公共静态工厂来代替构造方法。 这个方案在内部提供了使用子类的灵活性，在条目 17中讨论过。两种方法都是可以接受的。</p><p>这个建议可能有些争议，因为许多程序员已经习惯于继承普通的具体类来增加功能，例如通知和同步等功能，或限制原有类的功能。 如果一个类实现了捕获其本质的一些接口，比如Set，List或Map，那么不应该为了禁止子类化而感到愧疚。 在条目 18中描述的包装类模式为增强功能提供了继承的优越选择。</p><p>如果一个具体的类没有实现一个标准的接口，那么你可能会通过禁止继承来给一些程序员带来不便。 如果你觉得你必须允许从这样的类继承，一个合理的方法是确保类从不调用任何可重写的方法，并文档说明这个事实。 换句话说，完全消除类的自用（self-use）的可重写的方法。 这样做，你将创建一个合理安全的子类。 重写一个方法不会影响任何其他方法的行为。</p><p>你可以机械地消除类的自我使用的重写方法，而不会改变其行为。 将每个可重写的方法的主体移动到一个私有的“帮助器方法”，并让每个可重写的方法调用其私有的帮助器方法。 然后用直接调用可重写方法的专用帮助器方法来替换每个自用的可重写方法。</p><p>你可以机械地消除类的自用的重写方法，而不会改变其行为。 将每个可重写的方法的主体移到一个私有的“辅助方法（helper method）”，并让每个可重写的方法调用其私有的辅助方法。 然后用直接调用可重写方法的专用辅助方法来替换每个自用的可重写方法。</p><p>总之，设计一个继承类是一件很辛苦的事情。 你必须文档说明所有的自用模式，一旦你文档说明了它们，必须承诺为他们的整个生命周期。 如果你不这样做，子类可能会依赖于父类的实现细节，并且如果父类的实现发生改变，子类可能会损坏。 为了允许其他人编写高效的子类，可能还需要导出一个或多个受保护的方法。 除非你知道有一个真正的子类需要，否则你可能最好是通过声明你的类为final禁止继承，或者确保没有可访问的构造方法。</p><h2 id="20-接口优于抽象类"><a href="#20-接口优于抽象类" class="headerlink" title="20. 接口优于抽象类"></a>20. 接口优于抽象类</h2><p>Java有两种机制来定义允许多个实现的类型：接口和抽象类。 由于在Java 8 [JLS 9.4.3]中引入了接口的默认方法（default methods ），因此这两种机制都允许为某些实例方法提供实现。 一个主要的区别是要实现由抽象类定义的类型，类必须是抽象类的子类。 因为Java只允许单一继承，所以对抽象类的这种限制严格限制了它们作为类型定义的使用。 任何定义所有必需方法并服从通用约定的类都可以实现一个接口，而不管类在类层次结构中的位置。</p><p><strong>现有的类可以很容易地进行改进来实现一个新的接口</strong>。 你只需添加所需的方法（如果尚不存在的话），并向类声明中添加一个<code>implements</code>子句。 例如，当<code>Comparable</code>, <code>Iterable</code>， 和<code>Autocloseable</code>接口添加到Java平台时，很多现有类需要实现它们来加以改进。 一般来说，现有的类不能改进以继承一个新的抽象类。 如果你想让两个类继承相同的抽象类，你必须把它放在类型层级结构中的上面位置，它是两个类的祖先。 不幸的是，这会对类型层级结构造成很大的附带损害，迫使新的抽象类的所有后代对它进行子类化，无论这些后代类是否合适。</p><p><strong>接口是定义混合类型（mixin）的理想选择</strong>。 一般来说，mixin是一个类，除了它的“主类型”之外，还可以声明它提供了一些可选的行为。 例如，<code>Comparable</code>是一个类型接口，它允许一个类声明它的实例相对于其他可相互比较的对象是有序的。 这样的接口被称为类型，因为它允许可选功能被“混合”到类型的主要功能。 抽象类不能用于定义混合类，这是因为它们不能被加载到现有的类中：一个类不能有多个父类，并且在类层次结构中没有合理的位置来插入一个类型。</p><p><strong>接口允许构建非层级类型的框架</strong>。 类型层级对于组织某些事物来说是很好的，但是其他的事物并不是整齐地落入严格的层级结构中。 例如，假设我们有一个代表歌手的接口，另一个代表作曲家的接口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface Singer &#123;</span><br><span class="line">    AudioClip sing(Song s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface Songwriter &#123;</span><br><span class="line">    Song compose(int chartPosition);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在现实生活中，一些歌手也是作曲家。 因为我们使用接口而不是抽象类来定义这些类型，所以单个类实现歌手和作曲家两个接口是完全允许的。 事实上，我们可以定义一个继承歌手和作曲家的第三个接口，并添加适合于这个组合的新方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface SingerSongwriter extends Singer, Songwriter &#123;</span><br><span class="line">    AudioClip strum();</span><br><span class="line"></span><br><span class="line">    void actSensitive();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你并不总是需要这种灵活性，但是当你这样做的时候，接口是一个救星。 另一种方法是对于每个受支持的属性组合，包含一个单独的类的臃肿类层级结构。 如果类型系统中有n个属性，则可能需要支持2n种可能的组合。 这就是所谓的组合爆炸（combinatorial explosion）。 臃肿的类层级结构可能会导致具有许多方法的臃肿类，这些方法仅在参数类型上有所不同，因为类层级结构中没有类型来捕获通用行为。</p><p><strong>接口通过包装类模式确保安全的，强大的功能增强成为可能（条目 18）</strong>。 如果使用抽象类来定义类型，那么就让程序员想要添加功能，只能继承。 生成的类比包装类更弱，更脆弱。</p><p>当其他接口方法有明显的接口方法实现时，可以考虑向程序员提供默认形式的方法实现帮助。 有关此技术的示例，请参阅第104页的<code>removeIf</code>方法。如果提供默认方法，请确保使用<code>@implSpec</code> Javadoc标记（条目19）将它们文档说明为继承。</p><p>使用默认方法可以提供实现帮助多多少少是有些限制的。 尽管许多接口指定了<code>Object</code>类中方法（如<code>equals</code>和<code>hashCode</code>）的行为，但不允许为它们提供默认方法。 此外，接口不允许包含实例属性或非公共静态成员（私有静态方法除外）。 最后，不能将默认方法添加到不受控制的接口中。</p><p>但是，你可以通过提供一个抽象的骨架实现类（abstract skeletal implementation class）来与接口一起使用，将接口和抽象类的优点结合起来。 接口定义了类型，可能提供了一些默认的方法，而骨架实现类在原始接口方法的顶层实现了剩余的非原始接口方法。 继承骨架实现需要大部分的工作来实现一个接口。 这就是模板方法设计模式[Gamma95]。</p><p>按照惯例，骨架实现类被称为AbstractInterface，其中Interface是它们实现的接口的名称。 例如，集合框架（ Collections Framework）提供了一个框架实现以配合每个主要集合接口：<code>AbstractCollection</code>，<code>AbstractSet</code>，<code>AbstractList</code>和<code>AbstractMap</code>。 可以说，将它们称为<code>SkeletalCollection</code>，<code>SkeletalSet</code>，<code>SkeletalList</code>和<code>SkeletalMap</code>是有道理的，但是现在已经确立了抽象约定。 如果设计得当，骨架实现（无论是单独的抽象类还是仅由接口上的默认方法组成）可以使程序员非常容易地提供他们自己的接口实现。 例如，下面是一个静态工厂方法，在<code>AbstractList</code>的顶层包含一个完整的功能齐全的List实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// Concrete implementation built atop skeletal implementation</span><br><span class="line"></span><br><span class="line">static List&lt;Integer&gt; intArrayAsList(int[] a) &#123;</span><br><span class="line"></span><br><span class="line">    Objects.requireNonNull(a);</span><br><span class="line"></span><br><span class="line">    // The diamond operator is only legal here in Java 9 and later</span><br><span class="line"></span><br><span class="line">    // If you&apos;re using an earlier release, specify &lt;Integer&gt;</span><br><span class="line"></span><br><span class="line">    return new AbstractList&lt;&gt;() &#123;</span><br><span class="line"></span><br><span class="line">        @Override public Integer get(int i) &#123;</span><br><span class="line"></span><br><span class="line">            return a[i];  // Autoboxing ([Item 6](https://www.safaribooksonline.com/library/view/effective-java-third/9780134686097/ch2.xhtml#lev6))</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override public Integer set(int i, Integer val) &#123;</span><br><span class="line"></span><br><span class="line">            int oldVal = a[I];</span><br><span class="line"></span><br><span class="line">            a[i] = val;     // Auto-unboxing</span><br><span class="line"></span><br><span class="line">            return oldVal;  // Autoboxing</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override public int size() &#123;</span><br><span class="line"></span><br><span class="line">            return a.length;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当你考虑一个List实现为你做的所有事情时，这个例子是一个骨架实现的强大的演示。 顺便说一句，这个例子是一个适配器（Adapter ）[Gamma95]，它允许一个int数组被看作<code>Integer</code>实例列表。 由于int值和整数实例（装箱和拆箱）之间的来回转换，其性能并不是非常好。 请注意，实现采用匿名类的形式（条目 24）。</p><p>骨架实现类的优点在于，它们提供抽象类的所有实现的帮助，而不会强加抽象类作为类型定义时的严格约束。对于具有骨架实现类的接口的大多数实现者来说，继承这个类是显而易见的选择，但它不是必需的。如果一个类不能继承骨架的实现，这个类可以直接实现接口。该类仍然受益于接口本身的任何默认方法。此外，骨架实现类仍然可以协助接口的实现。实现接口的类可以将接口方法的调用转发给继承骨架实现的私有内部类的包含实例。这种被称为模拟多重继承的技术与条目 18讨论的包装类模式密切相关。它提供了多重继承的许多好处，同时避免了缺陷。</p><p>编写一个骨架的实现是一个相对简单的过程，虽然有些乏味。 首先，研究接口，并确定哪些方法是基本的，其他方法可以根据它们来实现。 这些基本方法是你的骨架实现类中的抽象方法。 接下来，为所有可以直接在基本方法之上实现的方法提供接口中的默认方法，回想一下，你可能不会为诸如<code>Object</code>类中<code>equals</code>和<code>hashCode</code>等方法提供默认方法。 如果基本方法和默认方法涵盖了接口，那么就完成了，并且不需要骨架实现类。 否则，编写一个声明实现接口的类，并实现所有剩下的接口方法。 为了适合于该任务，此类可能包含任何的非公共属性和方法。</p><p>作为一个简单的例子，考虑一下<code>Map.Entry接口。 显而易见的基本方法是</code>getKey<code>，getValue</code>和（可选的）<code>setValue</code>。 接口指定了<code>equals</code>和<code>hashCode</code>的行为，并且在基本方面方面有一个<code>toString</code>的明显的实现。 由于不允许为Object类方法提供默认实现，因此所有实现均放置在骨架实现类中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">// Skeletal implementation class</span><br><span class="line"></span><br><span class="line">public abstract class AbstractMapEntry&lt;K,V&gt;</span><br><span class="line"></span><br><span class="line">        implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    // Entries in a modifiable map must override this method</span><br><span class="line"></span><br><span class="line">    @Override public V setValue(V value) &#123;</span><br><span class="line"></span><br><span class="line">        throw new UnsupportedOperationException();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Implements the general contract of Map.Entry.equals</span><br><span class="line"></span><br><span class="line">    @Override public boolean equals(Object o) &#123;</span><br><span class="line"></span><br><span class="line">        if (o == this)</span><br><span class="line"></span><br><span class="line">            return true;</span><br><span class="line"></span><br><span class="line">        if (!(o instanceof Map.Entry))</span><br><span class="line"></span><br><span class="line">            return false;</span><br><span class="line"></span><br><span class="line">        Map.Entry&lt;?,?&gt; e = (Map.Entry) o;</span><br><span class="line"></span><br><span class="line">        return Objects.equals(e.getKey(),  getKey())</span><br><span class="line"></span><br><span class="line">            &amp;&amp; Objects.equals(e.getValue(), getValue());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Implements the general contract of Map.Entry.hashCode</span><br><span class="line"></span><br><span class="line">    @Override public int hashCode() &#123;</span><br><span class="line"></span><br><span class="line">        return Objects.hashCode(getKey())</span><br><span class="line"></span><br><span class="line">             ^ Objects.hashCode(getValue());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override public String toString() &#123;</span><br><span class="line"></span><br><span class="line">        return getKey() + &quot;=&quot; + getValue();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，这个骨架实现不能在<code>Map.Entry</code>接口中实现，也不能作为子接口实现，因为默认方法不允许重写诸如<code>equals</code>，<code>hashCode</code>和<code>toString</code>等<code>Object</code>类方法。</p><p>由于骨架实现类是为了继承而设计的，所以你应该遵循条目 19中的所有设计和文档说明。为了简洁起见，前面的例子中省略了文档注释，但是<strong>好的文档在骨架实现中是绝对必要的</strong>，无论它是否包含 一个接口或一个单独的抽象类的默认方法。</p><p>与骨架实现有稍许不同的是简单实现，以<code>AbstractMap.SimpleEntry</code>为例。 一个简单的实现就像一个骨架实现，它实现了一个接口，并且是为了继承而设计的，但是它的不同之处在于它不是抽象的：它是最简单的工作实现。 你可以按照情况使用它，也可以根据情况进行子类化。</p><p>总而言之，一个接口通常是定义允许多个实现的类型的最佳方式。 如果你导出一个重要的接口，应该强烈考虑提供一个骨架的实现类。 在可能的情况下，应该通过接口上的默认方法提供骨架实现，以便接口的所有实现者都可以使用它。 也就是说，对接口的限制通常要求骨架实现类采用抽象类的形式。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;16-在公共类中使用访问方法而不是公共属性&quot;&gt;&lt;a href=&quot;#16-在公共类中使用访问方法而不是公共属性&quot; class=&quot;headerlink&quot; title=&quot;16. 在公共类中使用访问方法而不是公共属性&quot;&gt;&lt;/a&gt;16. 在公共类中使用访问方法而不是公共属性
      
    
    </summary>
    
      <category term="java" scheme="http://luxiangdong.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>Effective Java 中文版(item:11-15)</title>
    <link href="http://luxiangdong.com/2018/05/09/effective-java-cn-11-15/"/>
    <id>http://luxiangdong.com/2018/05/09/effective-java-cn-11-15/</id>
    <published>2018-05-09T01:24:50.000Z</published>
    <updated>2018-05-09T03:03:27.941Z</updated>
    
    <content type="html"><![CDATA[<h2 id="11-重写equals方法时同时也要重写hashcode方法"><a href="#11-重写equals方法时同时也要重写hashcode方法" class="headerlink" title="11. 重写equals方法时同时也要重写hashcode方法"></a>11. 重写equals方法时同时也要重写hashcode方法</h2><p><strong>在每个类中，在重写 equals 方法的时侯，一定要重写 hashcode 方法</strong>。如果不这样做，你的类违反了hashCode的通用约定，这会阻止它在HashMap和HashSet这样的集合中正常工作。根据 Object 规范，以下时具体约定。</p><ol><li>当在一个应用程序执行过程中，如果在equals方法比较中没有修改任何信息，在一个对象上重复调用hashCode方法时，它必须始终返回相同的值。从一个应用程序到另一个应用程序的每一次执行返回的值可以是不一致的。</li><li>如果两个对象根据equals(Object)方法比较是相等的，那么在两个对象上调用hashCode就必须产生的结果是相同的整数。</li><li>如果两个对象根据equals(Object)方法比较并不相等，则不要求在每个对象上调用hashCode都必须产生不同的结果。 但是，程序员应该意识到，为不相等的对象生成不同的结果可能会提高散列表（hash tables）的性能。</li></ol><p><strong>当无法重写hashCode时，所违反第二个关键条款是：相等的对象必须具有相等的哈希码（ hash codes）</strong>。根据类的equals方法，两个不同的实例可能在逻辑上是相同的，但是对于Object 类的hashCode方法，它们只是两个没有什么共同之处的对象。因此， Object 类的hashCode方法返回两个看似随机的数字，而不是按约定要求的两个相等的数字。</p><p>举例说明，假设你使用条目 10中的<code>PhoneNumber</code>类的实例做为HashMap的键（key）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;PhoneNumber, String&gt; m = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">m.put(new PhoneNumber(707, 867, 5309), &quot;Jenny&quot;);</span><br></pre></td></tr></table></figure><p>你可能期望<code>m.get(new PhoneNumber(707, 867, 5309))</code>方法返回<code>Jenny</code>字符串，但实际上，返回了 null。注意，这里涉及到两个<code>PhoneNumber</code>实例：一个实例插入到 HashMap 中，另一个作为判断相等的实例用来检索。<code>PhoneNumber</code>类没有重写 hashCode 方法导致两个相等的实例返回了不同的哈希码，违反了 hashCode 约定。put 方法把<code>PhoneNumber</code>实例保存在了一个哈希桶（ hash bucket）中，但get方法却是从不同的哈希桶中去查找，即使恰好两个实例放在同一个哈希桶中，get 方法几乎肯定也会返回 null。因为HashMap 做了优化，缓存了与每一项（entry）相关的哈希码，如果哈希码不匹配，则不会检查对象是否相等了。</p><p>解决这个问题很简单，只需要为<code>PhoneNumber</code>类重写一个合适的 hashCode 方法。hashCode方法是什么样的？写一个不规范的方法的是很简单的。以下示例，虽然永远是合法的，但绝对不能这样使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// The worst possible legal hashCode implementation - never use!</span><br><span class="line"></span><br><span class="line">@Override public int hashCode() &#123; return 42; &#125;</span><br></pre></td></tr></table></figure><p>这是合法的，因为它确保了相等的对象具有相同的哈希码。这很糟糕，因为它确保了每个对象都有相同的哈希码。因此，每个对象哈希到同一个桶中，哈希表退化为链表。应该在线性时间内运行的程序，运行时间变成了平方级别。对于数据很大的哈希表而言，会影响到能够正常工作。</p><p>一个好的 hash 方法趋向于为不相等的实例生成不相等的哈希码。这也正是 hashCode 约定中第三条的表达。理想情况下，hash 方法为集合中不相等的实例均匀地分配int 范围内的哈希码。实现这种理想情况可能是困难的。 幸运的是，要获得一个合理的近似的方式并不难。 以下是一个简单的配方：</p><ol><li><p>声明一个 int 类型的变量result，并将其初始化为对象中第一个重要属性<code>c</code>的哈希码，如下面步骤2.a中所计算的那样。（回顾条目10，重要的属性是影响比较相等的领域。）</p></li><li><p>对于对象中剩余的重要属性<code>f</code>，请执行以下操作：</p><p>a. 比较属性<code>f</code>与属性<code>c</code>的 int 类型的哈希码：<br>– i. 如果这个属性是基本类型的，使用<code>Type.hashCode(f)</code>方法计算，其中<code>Type</code>类是对应属性 f 基本类型的包装类。<br>– ii 如果该属性是一个对象引用，并且该类的equals方法通过递归调用equals来比较该属性，并递归地调用hashCode方法。 如果需要更复杂的比较，则计算此字段的“范式（“canonical representation）”，并在范式上调用hashCode。 如果该字段的值为空，则使用0（也可以使用其他常数，但通常来使用0表示）。<br>– iii 如果属性<code>f</code>是一个数组，把它看作每个重要的元素都是一个独立的属性。 也就是说，通过递归地应用这些规则计算每个重要元素的哈希码，并且将每个步骤2.b的值合并。 如果数组没有重要的元素，则使用一个常量，最好不要为0。如果所有元素都很重要，则使用<code>Arrays.hashCode</code>方法。</p><p>b. 将步骤2.a中属性<code>c</code>计算出的哈希码合并为如下结果：<code>result = 31 * result + c;</code></p></li><li><p>返回 result 值。</p></li></ol><p>当你写完hashCode方法后，问自己是否相等的实例有相同的哈希码。 编写单元测试来验证你的直觉（除非你使用AutoValue框架来生成你的equals和hashCode方法，在这种情况下，你可以放心地忽略这些测试）。 如果相同的实例有不相等的哈希码，找出原因并解决问题。</p><p>可以从哈希码计算中排除派生属性（derived fields）。换句话说，如果一个属性的值可以根据参与计算的其他属性值计算出来，那么可以忽略这样的属性。您必须排除在equals比较中没有使用的任何属性，否则可能会违反hashCode约定的第二条。</p><p>步骤2.b中的乘法计算结果取决于属性的顺序，如果类中具有多个相似属性，则产生更好的散列函数。 例如，如果乘法计算从一个String散列函数中被省略，则所有的字符将具有相同的散列码。 之所以选择31，因为它是一个奇数的素数。 如果它是偶数，并且乘法溢出，信息将会丢失，因为乘以2相当于移位。 使用素数的好处不太明显，但习惯上都是这么做的。 31的一个很好的特性，是在一些体系结构中乘法可以被替换为移位和减法以获得更好的性能：<code>31 * i ==（i &lt;&lt; 5） - i</code>。 现代JVM可以自动进行这种优化。</p><p>让我们把上述办法应用到PhoneNumber类中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// Typical hashCode method</span><br><span class="line"></span><br><span class="line">@Override public int hashCode() &#123;</span><br><span class="line"></span><br><span class="line">    int result = Short.hashCode(areaCode);</span><br><span class="line"></span><br><span class="line">    result = 31 * result + Short.hashCode(prefix);</span><br><span class="line"></span><br><span class="line">    result = 31 * result + Short.hashCode(lineNum);</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为这个方法返回一个简单的确定性计算的结果，它的唯一的输入是<code>PhoneNumber</code>实例中的三个重要的属性，所以显然相等的<code>PhoneNumber</code>实例具有相同的哈希码。 实际上，这个方法是<code>PhoneNumber</code>的一个非常好的hashCode实现，与Java平台类库中的实现一样。 它很简单，速度相当快，并且合理地将不相同的电话号码分散到不同的哈希桶中。</p><p>虽然在这个项目的方法产生相当好的哈希函数，但并不是最先进的。 它们的质量与Java平台类库的值类型中找到的哈希函数相当，对于大多数用途来说都是足够的。 如果真的需要哈希函数而不太可能产生碰撞，请参阅Guava框架的的<a href="http://com.google.common.hash.hashing/" target="_blank" rel="noopener">com.google.common.hash.Hashing</a> [Guava]方法。</p><p><code>Objects</code>类有一个静态方法，它接受任意数量的对象并为它们返回一个哈希码。 这个名为hash的方法可以让你编写一行hashCode方法，其质量与根据这个项目中的上面编写的方法相当。 不幸的是，它们的运行速度更慢，因为它们需要创建数组以传递可变数量的参数，以及如果任何参数是基本类型，则进行装箱和取消装箱。 这种哈希函数的风格建议仅在性能不重要的情况下使用。 以下是使用这种技术编写的<code>PhoneNumber</code>的哈希函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// One-line hashCode method - mediocre performance</span><br><span class="line"></span><br><span class="line">@Override public int hashCode() &#123;</span><br><span class="line"></span><br><span class="line">   return Objects.hash(lineNum, prefix, areaCode);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一个类是不可变的，并且计算哈希码的代价很大，那么可以考虑在对象中缓存哈希码，而不是在每次请求时重新计算哈希码。 如果你认为这种类型的大多数对象将被用作哈希键，那么应该在创建实例时计算哈希码。 否则，可以选择在首次调用hashCode时延迟初始化（lazily initialize）哈希码。 需要注意确保类在存在延迟初始化属性的情况下保持线程安全（项目83）。 <code>PhoneNumber</code>类不适合这种情况，但只是为了展示它是如何完成的。 请注意，属性hashCode的初始值（在本例中为0）不应该是通常创建的实例的哈希码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// hashCode method with lazily initialized cached hash code</span><br><span class="line"></span><br><span class="line">private int hashCode; // Automatically initialized to 0</span><br><span class="line"></span><br><span class="line">@Override public int hashCode() &#123;</span><br><span class="line"></span><br><span class="line">    int result = hashCode;</span><br><span class="line"></span><br><span class="line">    if (result == 0) &#123;</span><br><span class="line"></span><br><span class="line">        result = Short.hashCode(areaCode);</span><br><span class="line"></span><br><span class="line">        result = 31 * result + Short.hashCode(prefix);</span><br><span class="line"></span><br><span class="line">        result = 31 * result + Short.hashCode(lineNum);</span><br><span class="line"></span><br><span class="line">        hashCode = result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>不要试图从哈希码计算中排除重要的属性来提高性能</strong>。 由此产生的哈希函数可能运行得更快，但其质量较差可能会降低哈希表的性能，使其无法使用。 具体来说，哈希函数可能会遇到大量不同的实例，这些实例主要在你忽略的区域中有所不同。 如果发生这种情况，哈希函数将把所有这些实例映射到少许哈希码上，而应该以线性时间运行的程序将会运行平方级的时间。</p><p>这不仅仅是一个理论问题。 在Java 2之前，String 类哈希函数在整个字符串中最多使用16个字符，从第一个字符开始，在整个字符串中均匀地选取。 对于大量的带有层次名称的集合（如URL），此功能正好显示了前面描述的病态行为。</p><p><strong>不要为hashCode返回的值提供详细的规范，因此客户端不能合理地依赖它； 你可以改变它的灵活性</strong>。 Java类库中的许多类（例如String和Integer）都将hashCode方法返回的确切值指定为实例值的函数。 这不是一个好主意，而是一个我们不得不忍受的错误：它妨碍了在未来版本中改进哈希函数的能力。 如果未指定细节并在散列函数中发现缺陷，或者发现了更好的哈希函数，则可以在后续版本中对其进行更改。</p><p>总之，每次重写equals方法时都必须重写hashCode方法，否则程序将无法正常运行。你的hashCode方法必须遵从Object类指定的常规约定，并且必须执行合理的工作，将不相等的哈希码分配给不相等的实例。如果使用第51页的配方，这很容易实现。如条目 10所述，AutoValue框架为手动编写equals和hashCode方法提供了一个很好的选择，IDE也提供了一些这样的功能。</p><h2 id="12-始终重写-toString-方法"><a href="#12-始终重写-toString-方法" class="headerlink" title="12. 始终重写 toString 方法"></a>12. 始终重写 toString 方法</h2><p>虽然Object类提供了toString方法的实现，但它返回的字符串通常不是你的类的用户想要看到的。 它由类名后跟一个“at”符号（@）和哈希码的无符号十六进制表示组成，例如<code>PhoneNumber@163b91</code>。 toString的通用约定要求，返回的字符串应该是“一个简洁但内容丰富的表示，对人们来说是很容易阅读的”。虽然可以认为<code>PhoneNumber@163b91</code>简洁易读，但相比于<code>707-867-5309</code>，但并不是很丰富 。 toString通用约定“建议所有的子类重写这个方法”。好的建议，的确如此！</p><p>虽然它并不像遵守equals和hashCode约定那样重要(条目 10和11)，但是提供一个良好的toString实现使你的类更易于使用，并对使用此类的系统更易于调试。当对象被传递到println、printf、字符串连接操作符或断言，或者由调试器打印时，toString方法会自动被调用。即使你从不调用对象上的toString，其他人也可以。例如，对对象有引用的组件可能包含在日志错误消息中对象的字符串表示。如果未能重写toString，则消息可能是无用的。</p><p>如果为<code>PhoneNumber</code>提供了一个很好的toString方法，那么生成一个有用的诊断消息就像下面这样简单：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(&quot;Failed to connect to &quot; + phoneNumber);</span><br></pre></td></tr></table></figure><p>程序员将以这种方式生成诊断消息，不管你是否重写toString，但是除非你这样做，否则这些消息将不会有用。 提供一个很好的toString方法的好处不仅包括类的实例，同样有益于包含实例引用的对象，特别是集合。 打印map 对象时你会看到哪一个，<code>{Jenny=PhoneNumber@163b91}</code>还是<code>{Jenny=707-867-5309}</code>?</p><p>实际上，toString方法应该返回对象中包含的所有需要关注的信息，如电话号码示例中所示。 如果对象很大或者包含不利于字符串表示的状态，这是不切实际的。 在这种情况下，toString应该返回一个摘要，如 <code>Manhattan residential phone directory (1487536 listings)</code>或线程<code>[main，5，main]</code>。 理想情况下，字符串应该是不言自明的（线程示例并没有遵守这点）。 如果未能将所有对象的值得关注的信息包含在字符串表示中，则会导致一个特别烦人的处罚：测试失败报告如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Assertion failure: expected &#123;abc, 123&#125;, but was &#123;abc, 123&#125;.</span><br></pre></td></tr></table></figure><p>实现toString方法时，必须做出的一个重要决定是：在文档中指定返回值的格式。 建议你对值类进行此操作，例如电话号码或矩阵类。 指定格式的好处是它可以作为标准的，明确的，可读的对象表示。 这种表示形式可以用于输入、输出以及持久化可读性的数据对象，如CSV文件。 如果指定了格式，通常提供一个匹配的静态工厂或构造方法，是个好主意，所以程序员可以轻松地在对象和字符串表示之间来回转换。 Java平台类库中的许多值类都采用了这种方法，包括BigInteger，BigDecimal和大部分基本类型包装类。</p><p>指定toString返回值的格式的缺点是，假设你的类被广泛使用，一旦指定了格式，就会终身使用。程序员将编写代码来解析表达式，生成它，并将其嵌入到持久数据中。如果在将来的版本中更改了格式的表示，那么会破坏他们的代码和数据，并且还会抱怨。但通过选择不指定格式，就可以保留在后续版本中添加信息或改进格式的灵活性。</p><p>无论是否决定指定格式，你都应该清楚地在文档中表明你的意图。如果指定了格式，则应该这样做。例如，这里有一个toString方法，该方法在条目 11中使用<code>PhoneNumber</code>类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Returns the string representation of this phone number.</span><br><span class="line"> * The string consists of twelve characters whose format is</span><br><span class="line"> * &quot;XXX-YYY-ZZZZ&quot;, where XXX is the area code, YYY is the</span><br><span class="line"> * prefix, and ZZZZ is the line number. Each of the capital</span><br><span class="line"> * letters represents a single decimal digit.</span><br><span class="line"> *</span><br><span class="line"> * If any of the three parts of this phone number is too small</span><br><span class="line"> * to fill up its field, the field is padded with leading zeros.</span><br><span class="line"> * For example, if the value of the line number is 123, the last</span><br><span class="line"> * four characters of the string representation will be &quot;0123&quot;.</span><br><span class="line"> */</span><br><span class="line">@Override public String toString() &#123;</span><br><span class="line">    return String.format(&quot;%03d-%03d-%04d&quot;,</span><br><span class="line">            areaCode, prefix, lineNum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你决定不指定格式，那么文档注释应该是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Returns a brief description of this potion. The exact details</span><br><span class="line"> * of the representation are unspecified and subject to change,</span><br><span class="line"> * but the following may be regarded as typical:</span><br><span class="line"> *</span><br><span class="line"> * &quot;[Potion #9: type=love, smell=turpentine, look=india ink]&quot;</span><br><span class="line"> */</span><br><span class="line">@Override public String toString() &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>在阅读了这条注释之后，那些生成依赖于格式细节的代码或持久化数据的程序员，在这种格式发生改变的时候，只能怪他们自己。</p><p>无论是否指定格式，都可以通过编程方式访问toString返回的值中包含的信息。 例如，<code>PhoneNumber</code>类应该包含 areaCode, prefix, lineNum这三个属性。 如果不这样做，就会强迫程序员需要这些信息来解析字符串。 除了降低性能和程序员做不必要的工作之外，这个过程很容易出错，如果改变格式就会中断，并导致脆弱的系统。 由于未能提供访问器，即使已指定格式可能会更改，也可以将字符串格式转换为事实上的API。</p><p>在静态工具类（条目 4）中编写toString方法是没有意义的。 你也不应该在大多数枚举类型（条目 34）中写一个toString方法，因为Java为你提供了一个非常好的方法。 但是，你应该在任何抽象类中定义toString方法，该类的子类共享一个公共字符串表示形式。 例如，大多数集合实现上的toString方法都是从抽象集合类继承的。</p><p>Google的开放源代码AutoValue工具在条目 10中讨论过，它为你生成一个toString方法，就像大多数IDE工具一样。 这些方法非常适合告诉你每个属性的内容，但并不是专门针对类的含义。 因此，例如，为我们的<code>PhoneNumber</code>类使用自动生成的toString方法是不合适的（因为电话号码具有标准的字符串表示形式），但是对于我们的<code>Potion</code>类来说，这是完全可以接受的。 也就是说，自动生成的toString方法比从Object继承的方法要好得多，它不会告诉你对象的值。</p><p>回顾一下，除非父类已经这样做了，否则在每个实例化的类中重写Object的toString实现。 它使得类更加舒适地使用和协助调试。 toString方法应该以一种美观的格式返回对象的简明有用的描述。</p><h2 id="13-谨慎地重写-clone-方法"><a href="#13-谨慎地重写-clone-方法" class="headerlink" title="13. 谨慎地重写 clone 方法"></a>13. 谨慎地重写 clone 方法</h2><p>Cloneable接口的目的是作为一个mixin接口(条目 20)，公布这样的类允许克隆。不幸的是，它没有达到这个目的。它的主要缺点是缺少clone方法，而Object的clone方法是受保护的。你不能，不借助反射(条目 65)，仅仅因为它实现了Cloneable接口，就调用对象上的 clone 方法。即使是反射调用也可能失败，因为不能保证对象具有可访问的 clone方法。尽管存在许多缺陷，该机制在合理的范围内使用，所以理解它是值得的。这个条目告诉你如何实现一个行为良好的 clone方法，在适当的时候讨论这个方法，并提出替代方案。</p><p>既然Cloneable接口不包含任何方法，那它用来做什么？ 它决定了Object的受保护的clone 方法实现的行为：如果一个类实现了Cloneable接口，那么Object的clone方法将返回该对象的逐个属性（field-by-field）拷贝；否则会抛出<code>CloneNotSupportedException</code>异常。这是一个非常反常的接口使用，而不应该被效仿。 通常情况下，实现一个接口用来表示可以为客户做什么。但对于Cloneable接口，它会修改父类上受保护方法的行为。</p><p>虽然规范并没有说明，但在实践中，实现Cloneable接口的类希望提供一个正常运行的公共 clone方法。为了实现这一目标，该类及其所有父类必须遵循一个复杂的、不可执行的、稀疏的文档协议。由此产生的机制是脆弱的、危险的和不受语言影响的（extralinguistic）：它创建对象而不需要调用构造方法。</p><p>clone方法的通用规范很薄弱的。 以下内容是从 Object 规范中复制出来的：</p><p>创建并返回此对象的副本。 “复制（copy）”的确切含义可能取决于对象的类。 一般意图是，对于任何对象x，表达式<code>x.clone() != x</code>返回 true，并且<code>x.clone().getClass() == x.getClass()</code>也返回 true，但它们不是绝对的要求，但通常情况下，<code>x.clone().equals(x)</code>返回 true，当然这个要求也不是绝对的。</p><p>根据约定，这个方法返回的对象应该通过调用<code>super.clone</code>方法获得的。 如果一个类和它的所有父类（Object除外）都遵守这个约定，情况就是如此，<code>x.clone().getClass() == x.getClass()</code>。</p><p>根据约定，返回的对象应该独立于被克隆的对象。 为了实现这种独立性，在返回对象之前，可能需要修改由super.clone返回的对象的一个或多个属性。</p><p>这种机制与构造方法链（chaining）很相似，只是它没有被强制执行；如果一个类的clone方法返回一个通过调用构造方法获得而不是通过调用super.clone的实例，那么编译器不会抱怨，但是如果一个类的子类调用了super.clone，那么返回的对象包含错误的类，从而阻止子类 clone 方法正常执行。如果一个类重写的 clone 方法是有 final 修饰的，那么这个约定可以被安全地忽略，因为子类不需要担心。但是，如果一个final类有一个不调用super.clone的clone方法，那么这个类没有理由实现Cloneable接口，因为它不依赖于Object的clone实现的行为。</p><p>假设你希望在一个类中实现Cloneable接口，它的父类提供了一个行为良好的 clone方法。首先调用super.clone。 得到的对象将是原始的完全功能的复制品。 在你的类中声明的任何属性将具有与原始属性相同的值。 如果每个属性包含原始值或对不可变对象的引用，则返回的对象可能正是你所需要的，在这种情况下，不需要进一步的处理。 例如，对于条目 11中的<code>PhoneNumber</code>类，情况就是这样，但是请注意，不可变类永远不应该提供clone方法，因为这只会浪费复制。 有了这个警告，以下是<code>PhoneNumber</code>类的clone方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// Clone method for class with no references to mutable state</span><br><span class="line">@Override public PhoneNumber clone() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        return (PhoneNumber) super.clone();</span><br><span class="line">    &#125; catch (CloneNotSupportedException e) &#123;</span><br><span class="line">        throw new AssertionError();  // Can&apos;t happen</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了使这个方法起作用，<code>PhoneNumber</code>的类声明必须被修改，以表明它实现了Cloneable接口。 虽然Object类的clone方法返回Object类，但是这个clone方法返回<code>PhoneNumber</code>类。 这样做是合法和可取的，因为Java支持协变返回类型。 换句话说，重写方法的返回类型可以是重写方法的返回类型的子类。 这消除了在客户端转换的需要。 在返回之前，我们必须将Object的super.clone的结果强制转换为<code>PhoneNumber</code>，但保证强制转换成功。</p><p>super.clone的调用包含在一个try-catch块中。 这是因为Object声明了它的clone方法来抛出<code>CloneNotSupportedException</code>异常，这是一个检查时异常。 由于<code>PhoneNumber</code>实现了Cloneable接口，所以我们知道调用super.clone会成功。 这里引用的需要表明<code>CloneNotSupportedException</code>应该是未被检查的（条目 71）。</p><p>如果对象包含引用可变对象的属性，则前面显示的简单clone实现可能是灾难性的。 例如，考虑条目 7中的Stack类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class Stack &#123;</span><br><span class="line"></span><br><span class="line">    private Object[] elements;</span><br><span class="line">    private int size = 0;</span><br><span class="line">    private static final int DEFAULT_INITIAL_CAPACITY = 16;</span><br><span class="line"></span><br><span class="line">    public Stack() &#123;</span><br><span class="line">        this.elements = new Object[DEFAULT_INITIAL_CAPACITY];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void push(Object e) &#123;</span><br><span class="line">        ensureCapacity();</span><br><span class="line">        elements[size++] = e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object pop() &#123;</span><br><span class="line">        if (size == 0)</span><br><span class="line">            throw new EmptyStackException();</span><br><span class="line">        Object result = elements[--size];</span><br><span class="line"></span><br><span class="line">        elements[size] = null; // Eliminate obsolete reference</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Ensure space for at least one more element.</span><br><span class="line">    private void ensureCapacity() &#123;</span><br><span class="line">        if (elements.length == size)</span><br><span class="line">            elements = Arrays.copyOf(elements, 2 * size + 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设你想让这个类可以克隆。 如果clone方法仅返回super.clone()调用的对象，那么生成的Stack实例在其size 属性中具有正确的值，但elements属性引用与原始Stack实例相同的数组。 修改原始实例将破坏克隆中的不变量，反之亦然。 你会很快发现你的程序产生了无意义的结果，或者抛出<code>NullPointerException</code>异常。</p><p>这种情况永远不会发生，因为调用Stack类中的唯一构造方法。 实际上，clone方法作为另一种构造方法; 必须确保它不会损坏原始对象，并且可以在克隆上正确建立不变量。 为了使Stack上的clone方法正常工作，它必须复制stack 对象的内部。 最简单的方法是对元素数组递归调用clone方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// Clone method for class with references to mutable state</span><br><span class="line">@Override public Stack clone() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        Stack result = (Stack) super.clone();</span><br><span class="line">        result.elements = elements.clone();</span><br><span class="line">        return result;</span><br><span class="line">    &#125; catch (CloneNotSupportedException e) &#123;</span><br><span class="line">        throw new AssertionError();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，我们不必将elements.clone的结果转换为Object[]数组。 在数组上调用clone会返回一个数组，其运行时和编译时类型与被克隆的数组相同。 这是复制数组的首选习语。 事实上，数组是clone 机制的唯一有力的用途。</p><p>还要注意，如果elements属性是final的，则以前的解决方案将不起作用，因为克隆将被禁止向该属性分配新的值。 这是一个基本的问题：像序列化一样，Cloneable体系结构与引用可变对象的final 属性的正常使用不兼容，除非可变对象可以在对象和其克隆之间安全地共享。 为了使一个类可以克隆，可能需要从一些属性中移除 final修饰符。</p><p>仅仅递归地调用clone方法并不总是足够的。 例如，假设您正在为哈希表编写一个clone方法，其内部包含一个哈希桶数组，每个哈希桶都指向“键-值”对链表的第一项。 为了提高性能，该类实现了自己的轻量级单链表，而没有使用java内部提供的java.util.LinkedList：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class HashTable implements Cloneable &#123;</span><br><span class="line">    private Entry[] buckets = ...;</span><br><span class="line">    private static class Entry &#123;</span><br><span class="line">        final Object key;</span><br><span class="line">        Object value;</span><br><span class="line">        Entry  next;</span><br><span class="line"></span><br><span class="line">        Entry(Object key, Object value, Entry next) &#123;</span><br><span class="line">            this.key   = key;</span><br><span class="line">            this.value = value;</span><br><span class="line">            this.next  = next;  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ... // Remainder omitted</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设你只是递归地克隆哈希桶数组，就像我们为Stack所做的那样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// Broken clone method - results in shared mutable state!</span><br><span class="line">@Override public HashTable clone() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        HashTable result = (HashTable) super.clone();</span><br><span class="line">        result.buckets = buckets.clone();</span><br><span class="line">        return result;</span><br><span class="line">    &#125; catch (CloneNotSupportedException e) &#123;</span><br><span class="line">        throw new AssertionError();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然被克隆的对象有自己的哈希桶数组，但是这个数组引用与原始数组相同的链表，这很容易导致克隆对象和原始对象中的不确定性行为。 要解决这个问题，你必须复制包含每个桶的链表。 下面是一种常见的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// Recursive clone method for class with complex mutable state</span><br><span class="line">public class HashTable implements Cloneable &#123;</span><br><span class="line">    private Entry[] buckets = ...;</span><br><span class="line"></span><br><span class="line">    private static class Entry &#123;</span><br><span class="line">        final Object key;</span><br><span class="line">        Object value;</span><br><span class="line">        Entry  next;</span><br><span class="line"></span><br><span class="line">        Entry(Object key, Object value, Entry next) &#123;</span><br><span class="line">            this.key   = key;</span><br><span class="line">            this.value = value;</span><br><span class="line">            this.next  = next;  </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Recursively copy the linked list headed by this Entry</span><br><span class="line">        Entry deepCopy() &#123;</span><br><span class="line">            return new Entry(key, value,</span><br><span class="line">                next == null ? null : next.deepCopy());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override public HashTable clone() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            HashTable result = (HashTable) super.clone();</span><br><span class="line">            result.buckets = new Entry[buckets.length];</span><br><span class="line">            for (int i = 0; i &lt; buckets.length; i++)</span><br><span class="line">                if (buckets[i] != null)</span><br><span class="line">                    result.buckets[i] = buckets[i].deepCopy();</span><br><span class="line">            return result;</span><br><span class="line">        &#125; catch (CloneNotSupportedException e) &#123;</span><br><span class="line">            throw new AssertionError();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ... // Remainder omitted</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>私有类HashTable.Entry已被扩充以支持“深度复制”方法。 HashTable上的clone方法分配一个合适大小的新哈希桶数组，迭代原来哈希桶数组，深度复制每个非空的哈希桶。 Entry上的deepCopy方法递归地调用它自己以复制由头节点开始的整个链表。 如果哈希桶不是太长，这种技术很聪明并且工作正常。但是，克隆链表不是一个好方法，因为它为列表中的每个元素消耗一个栈帧（stack frame）。 如果列表很长，这很容易导致堆栈溢出。 为了防止这种情况发生，可以用迭代来替换deepCopy中的递归：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// Iteratively copy the linked list headed by this Entry</span><br><span class="line">Entry deepCopy() &#123;</span><br><span class="line">   Entry result = new Entry(key, value, next);</span><br><span class="line">   for (Entry p = result; p.next != null; p = p.next)</span><br><span class="line">      p.next = new Entry(p.next.key, p.next.value, p.next.next);</span><br><span class="line">   return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>克隆复杂可变对象的最后一种方法是调用super.clone，将结果对象中的所有属性设置为其初始状态，然后调用更高级别的方法来重新生成原始对象的状态。 以HashTable为例，bucket属性将被初始化为一个新的bucket数组，并且 put(key, value)方法（未示出）被调用用于被克隆的哈希表中的键值映射。 这种方法通常产生一个简单，合理的优雅clone方法，其运行速度不如直接操纵克隆内部的方法快。 虽然这种方法是干净的，但它与整个Cloneable体系结构是对立的，因为它会盲目地重写构成体系结构基础的逐个属性对象复制。</p><p>与构造方法一样，clone 方法绝对不可以在构建过程中，调用一个可以重写的方法（条目 19）。如果 clone 方法调用一个在子类中重写的方法，则在子类有机会在克隆中修复它的状态之前执行该方法，很可能导致克隆和原始对象的损坏。因此，我们在前面讨论的 put(key, value)方法应该时 final 或 private 修饰的。（如果时 private 修饰，那么大概是一个非 final 公共方法的辅助方法）。</p><p>Object 类的 clone方法被声明为抛出CloneNotSupportedException异常，但重写方法时不需要。 公共clone方法应该省略throws子句，因为不抛出检查时异常的方法更容易使用（条目 71）。</p><p>在为继承设计一个类时（条目 19），通常有两种选择，但无论选择哪一种，都不应该实现 Clonable 接口。你可以选择通过实现正确运行的受保护的 clone方法来模仿Object的行为，该方法声明为抛出CloneNotSupportedException异常。 这给了子类实现Cloneable接口的自由，就像直接继承Object一样。 或者，可以选择不实现工作的 clone方法，并通过提供以下简并clone实现来阻止子类实现它：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// clone method for extendable class not supporting Cloneable</span><br><span class="line">@Override</span><br><span class="line">protected final Object clone() throws CloneNotSupportedException &#123;</span><br><span class="line">    throw new CloneNotSupportedException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一个值得注意的细节。 如果你编写一个实现了Cloneable的线程安全的类，记得它的clone方法必须和其他方法一样（条目 78）需要正确的同步。 Object 类的clone方法是不同步的，所以即使它的实现是令人满意的，也可能需要编写一个返回super.clone()的同步clone方法。</p><p>回顾一下，实现Cloneable的所有类应该重写公共clone方法，而这个方法的返回类型是类本身。 这个方法应该首先调用super.clone，然后修复任何需要修复的属性。 通常，这意味着复制任何包含内部“深层结构”的可变对象，并用指向新对象的引用来代替原来指向这些对象的引用。虽然这些内部拷贝通常可以通过递归调用clone来实现，但这并不总是最好的方法。 如果类只包含基本类型或对不可变对象的引用，那么很可能是没有属性需要修复的情况。 这个规则也有例外。 例如，表示序列号或其他唯一ID的属性即使是基本类型的或不可变的，也需要被修正。</p><p>这么复杂是否真的有必要？很少。 如果你继承一个已经实现了Cloneable接口的类，你别无选择，只能实现一个行为良好的clone方法。 否则，通常你最好提供另一种对象复制方法。 对象复制更好的方法是提供一个复制构造方法或复制工厂。 复制构造方法接受参数，其类型为包含此构造方法的类，例如，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// Copy constructor</span><br><span class="line">public Yum(Yum yum) &#123; ... &#125;;</span><br></pre></td></tr></table></figure><p>复制工厂类似于复制构造方法的静态工厂：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// Copy factory</span><br><span class="line">public static Yum newInstance(Yum yum) &#123; ... &#125;;</span><br></pre></td></tr></table></figure><p>复制构造方法及其静态工厂变体与Cloneable/clone相比有许多优点：它们不依赖风险很大的语言外的对象创建机制；不要求遵守那些不太明确的惯例；不会与final 属性的正确使用相冲突; 不会抛出不必要的检查异常; 而且不需要类型转换。</p><p>此外，复制构造方法或复制工厂可以接受类型为该类实现的接口的参数。 例如，按照惯例，所有通用集合实现都提供了一个构造方法，其参数的类型为Collection或Map。 基于接口的复制构造方法和复制工厂（更适当地称为转换构造方法和转换工厂）允许客户端选择复制的实现类型，而不是强制客户端接受原始实现类型。 例如，假设你有一个HashSet，并且你想把它复制为一个TreeSet。 clone方法不能提供这种功能，但使用转换构造方法很容易：<code>new TreeSet&lt;&gt;(s)</code>。</p><p>考虑到与Cloneable接口相关的所有问题，新的接口不应该继承它，新的可扩展类不应该实现它。 虽然实现Cloneable接口对于final类没有什么危害，但应该将其视为性能优化的角度，仅在极少数情况下才是合理的（条目67）。 通常，复制功能最好由构造方法或工厂提供。 这个规则的一个明显的例外是数组，它最好用 clone方法复制。</p><h2 id="14-考虑实现Comparable接口"><a href="#14-考虑实现Comparable接口" class="headerlink" title="14.考虑实现Comparable接口"></a>14.考虑实现Comparable接口</h2><p>与本章讨论的其他方法不同，<code>compareTo</code>方法并没有在<code>Object</code>类中声明。 相反，它是<code>Comparable</code>接口中的唯一方法。 它与<code>Object</code>类的<code>equals</code>方法在性质上是相似的，除了它允许在简单的相等比较之外的顺序比较，它是泛型的。 通过实现<code>Comparable</code>接口，一个类表明它的实例有一个自然顺序（ natural ordering）。 对实现<code>Comparable</code>接口的对象数组排序非常简单，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(a);</span><br></pre></td></tr></table></figure><p>它很容易查找，计算极端数值，以及维护<code>Comparable</code>对象集合的自动排序。例如，在下面的代码中，依赖于<code>String</code>类实现了<code>Comparable</code>接口，去除命令行参数输入重复的字符串，并按照字母顺序排序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class WordList &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Set&lt;String&gt; s = new TreeSet&lt;&gt;();</span><br><span class="line">        Collections.addAll(s, args);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过实现<code>Comparable</code>接口，可以让你的类与所有依赖此接口的通用算法和集合实现进行互操作。 只需少量的努力就可以获得巨大的能量。 几乎Java平台类库中的所有值类以及所有枚举类型（条目 34）都实现了<code>Comparable</code>接口。 如果你正在编写具有明显自然顺序（如字母顺序，数字顺序或时间顺序）的值类，则应该实现<code>Comparable</code>接口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Comparable&lt;T&gt; &#123;</span><br><span class="line">    int compareTo(T t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>compareTo</code>方法的通用约定与<code>equals</code>相似：</p><p>将此对象与指定的对象按照排序进行比较。 返回值可能为负整数，零或正整数，因为此对象对应小于，等于或大于指定的对象。 如果指定对象的类型与此对象不能进行比较，则引发<code>ClassCastException</code>异常。</p><p>下面的描述中，符号sgn(expression)表示数学中的 signum 函数，它根据表达式的值为负数、零、正数，对应返回-1、0和1。</p><ul><li>实现类必须确保所有<code>x</code>和<code>y</code>都满足<code>sgn(x.compareTo(y)) == -sgn(y. compareTo(x))</code>。 （这意味着当且仅当<code>y.compareTo(x)</code>抛出异常时，<code>x.compareTo(y)</code>必须抛出异常。）</li><li>实现类还必须确保该关系是可传递的：<code>(x. compareTo(y) &gt; 0 &amp;&amp; y.compareTo(z) &gt; 0)</code>意味着<code>x.compareTo(z) &gt; 0</code>。</li><li>最后，对于所有的z，实现类必须确保<code>[x.compareTo(y) == 0</code>意味着<code>sgn(x.compareTo(z)) == sgn(y.compareTo(z))</code>。</li><li>强烈推荐<code>x.compareTo(y) == 0) == (x.equals(y))</code>，但不是必需的。 一般来说，任何实现了<code>Comparable</code>接口的类违反了这个条件都应该清楚地说明这个事实。 推荐的语言是“注意：这个类有一个自然顺序，与<code>equals</code>不一致”。</li></ul><p>与<code>equals</code>方法一样，不要被上述约定的数学特性所退缩。这个约定并不像看起来那么复杂。 与<code>equals</code>方法不同，<code>equals</code>方法在所有对象上施加了全局等价关系，<code>compareTo</code>不必跨越不同类型的对象：当遇到不同类型的对象时，<code>compareTo</code>被允许抛出<code>ClassCastException</code>异常。 通常，这正是它所做的。 约定确实允许进行不同类型间比较，这种比较通常在由被比较的对象实现的接口中定义。</p><p>正如一个违反<code>hashCode</code>约定的类可能会破坏依赖于哈希的其他类一样，违反<code>compareTo</code>约定的类可能会破坏依赖于比较的其他类。 依赖于比较的类，包括排序后的集合<code>TreeSet</code>和<code>TreeMap</code>类，以及包含搜索和排序算法的实用程序类<code>Collections</code>和<code>Arrays</code>。</p><p>我们来看看<code>compareTo</code>约定的规定。 第一条规定，如果反转两个对象引用之间的比较方向，则会发生预期的事情：如果第一个对象小于第二个对象，那么第二个对象必须大于第一个; 如果第一个对象等于第二个，那么第二个对象必须等于第一个; 如果第一个对象大于第二个，那么第二个必须小于第一个。 第二项约定说，如果一个对象大于第二个对象，而第二个对象大于第三个对象，则第一个对象必须大于第三个对象。 最后一条规定，所有比较相等的对象与任何其他对象相比，都必须得到相同的结果。</p><p>这三条规定的一个结果是，<code>compareTo</code>方法所实施的平等测试必须遵守<code>equals</code>方法约定所施加的相同限制：自反性，对称性和传递性。 因此，同样需要注意的是：除非你愿意放弃面向对象抽象（条目 10）的好处，否则无法在保留<code>compareTo</code>约定的情况下使用新的值组件继承可实例化的类。 同样的解决方法也适用。 如果要将值组件添加到实现<code>Comparable</code>的类中，请不要继承它；编写一个包含第一个类实例的不相关的类。 然后提供一个返回包含实例的“视图”方法。 这使你可以在包含类上实现任何<code>compareTo</code>方法，同时客户端在需要时，把包含类的实例视同以一个类的实例。</p><p><code>compareTo</code>约定的最后一段是一个强烈的建议，而不是一个真正的要求，只是声明<code>compareTo</code>方法施加的相等性测试，通常应该返回与<code>equals</code>方法相同的结果。 如果遵守这个约定，则<code>compareTo</code>方法施加的顺序被认为与<code>equals</code>相一致。 如果违反，顺序关系被认为与<code>equals</code>不一致。 其<code>compareTo</code>方法施加与<code>equals</code>不一致顺序关系的类仍然有效，但包含该类元素的有序集合可能不服从相应集合接口（<code>Collection</code>，<code>Set</code>或<code>Map</code>）的一般约定。 这是因为这些接口的通用约定是用<code>equals</code>方法定义的，但是排序后的集合使用<code>compareTo</code>强加的相等性测试来代替<code>equals</code>。 如果发生这种情况，虽然不是一场灾难，但仍是一件值得注意的事情。</p><p>例如，考虑<code>BigDecimal</code>类，其<code>compareTo</code>方法与<code>equals</code>不一致。 如果你创建一个空的<code>HashSet</code>实例，然后添加<code>new BigDecimal(&quot;1.0&quot;)</code>和<code>new BigDecimal(&quot;1.00&quot;)</code>，则该集合将包含两个元素，因为与<code>equals</code>方法进行比较时，添加到集合的两个<code>BigDecimal</code>实例是不相等的。 但是，如果使用<code>TreeSet</code>而不是<code>HashSet</code>执行相同的过程，则该集合将只包含一个元素，因为使用<code>compareTo</code>方法进行比较时，两个<code>BigDecimal</code>实例是相等的。 （有关详细信息，请参阅<code>BigDecimal</code>文档。）</p><p>编写<code>compareTo</code>方法与编写<code>equals</code>方法类似，但是有一些关键的区别。 因为<code>Comparable</code>接口是参数化的，<code>compareTo</code>方法是静态类型的，所以你不需要输入检查或者转换它的参数。 如果参数是错误的类型，那么调用将不会编译。 如果参数为null，则调用应该抛出一个<code>NullPointerException</code>异常，并且一旦该方法尝试访问其成员，它就会立即抛出这个异常。</p><p>在<code>compareTo</code>方法中，比较属性的顺序而不是相等。 要比较对象引用属性，请递归调用<code>compareTo</code>方法。 如果一个属性没有实现<code>Comparable</code>，或者你需要一个非标准的顺序，那么使用<code>Comparator</code>接口。 可以编写自己的比较器或使用现有的比较器，如在条目 10中的<code>CaseInsensitiveString</code>类的<code>compareTo</code>方法中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// Single-field Comparable with object reference field</span><br><span class="line">public final class CaseInsensitiveString</span><br><span class="line">        implements Comparable&lt;CaseInsensitiveString&gt; &#123;</span><br><span class="line">    public int compareTo(CaseInsensitiveString cis) &#123;</span><br><span class="line">        return String.CASE_INSENSITIVE_[ORDER.compare(s](http://ORDER.compare(s), cis.s);</span><br><span class="line">    &#125;</span><br><span class="line">    ... // Remainder omitted</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，<code>CaseInsensitiveString</code>类实现了<code>Comparable &lt;CaseInsensitiveString&gt;</code>接口。 这意味着<code>CaseInsensitiveString</code>引用只能与另一个<code>CaseInsensitiveString</code>引用进行比较。 当声明一个类来实现<code>Comparable</code>接口时，这是正常模式。</p><p>在本书第二版中，曾经推荐如果比较整型基本类型的属性，使用关系运算符“&lt;” 和 “&gt;”，对于浮点类型基本类型的属性，使用<code>Double.compare</code>和[<code>Float.compare</code>静态方法。在Java 7中，静态比较方法被添加到Java的所有包装类中。 在<code>compareTo</code>方法中使用关系运算符“&lt;” 和“&gt;”是冗长且容易出错的，不再推荐。</p><p>如果一个类有多个重要的属性，那么比较他们的顺序是至关重要的。 从最重要的属性开始，逐步比较所有的重要属性。 如果比较结果不是零（零表示相等），则表示比较完成; 只是返回结果。 如果最重要的字段是相等的，比较下一个重要的属性，依此类推，直到找到不相等的属性或比较剩余不那么重要的属性。 以下是条目 11中<code>PhoneNumber</code>类的<code>compareTo</code>方法，演示了这种方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// Multiple-field Comparable with primitive fields</span><br><span class="line">public int compareTo(PhoneNumber pn) &#123;</span><br><span class="line">    int result = [Short.compare(areaCode](http://Short.compare(areaCode), pn.areaCode);</span><br><span class="line">    if (result == 0)  &#123;</span><br><span class="line">        result = [Short.compare(prefix](http://Short.compare(prefix), pn.prefix);</span><br><span class="line">        if (result == 0)</span><br><span class="line">            result = [Short.compare(lineNum](http://Short.compare(lineNum), pn.lineNum);</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Java 8中<code>Comparator</code>接口提供了一系列比较器方法，可以使比较器流畅地构建。 这些比较器可以用来实现<code>compareTo</code>方法，就像<code>Comparable</code>接口所要求的那样。 许多程序员更喜欢这种方法的简洁性，尽管它的性能并不出众：在我的机器上排序<code>PhoneNumber</code>实例的数组速度慢了大约10％。 在使用这种方法时，考虑使用Java的静态导入，以便可以通过其简单名称来引用比较器静态方法，以使其清晰简洁。 以下是<code>PhoneNumber</code>的<code>compareTo</code>方法的使用方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// Comparable with comparator construction methods</span><br><span class="line">private static final Comparator&lt;PhoneNumber&gt; COMPARATOR =</span><br><span class="line">        comparingInt((PhoneNumber pn) -&gt; pn.areaCode)</span><br><span class="line">          .thenComparingInt(pn -&gt; pn.prefix)</span><br><span class="line">          .thenComparingInt(pn -&gt; pn.lineNum);</span><br><span class="line"></span><br><span class="line">public int compareTo(PhoneNumber pn) &#123;</span><br><span class="line">    return [COMPARATOR.compare(this](http://COMPARATOR.compare(this), pn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此实现在类初始化时构建比较器，使用两个比较器构建方法。第一个是<code>comparingInt</code>方法。它是一个静态方法，它使用一个键提取器函数式接口（ key extractor function）作为参数，将对象引用映射为int类型的键，并返回一个根据该键排序的实例的比较器。在前面的示例中，<code>comparingInt</code>方法使用lambda表达式，它从<code>PhoneNumber</code>中提取区域代码，并返回一个<code>Comparator&lt;PhoneNumber&gt;</code>，根据它们的区域代码来排序电话号码。注意，lambda表达式显式指定了其输入参数的类型<code>(PhoneNumber pn)</code>。事实证明，在这种情况下，Java的类型推断功能不够强大，无法自行判断类型，因此我们不得不帮助它以使程序编译。</p><p>如果两个电话号码实例具有相同的区号，则需要进一步细化比较，这正是第二个比较器构建方法，即<code>thenComparingInt</code>方法做的。 它是<code>Comparator</code>上的一个实例方法，接受一个int类型键提取器函数式接口（ key extractor function）作为参数，并返回一个比较器，该比较器首先应用原始比较器，然后使用提取的键来打破连接。 你可以按照喜欢的方式多次调用<code>thenComparingIn</code>t方法，从而产生一个字典顺序。 在上面的例子中，我们将两个调用叠加到<code>thenComparingInt</code>，产生一个排序，它的二级键是<code>prefix</code>，而其三级键是<code>lineNum</code>。 请注意，我们不必指定传递给<code>thenComparingInt</code>的任何一个调用的键提取器函数式接口的参数类型：Java的类型推断足够聪明，可以自己推断出参数的类型。</p><p><code>Comparator</code>类具有完整的构建方法。对于<code>long</code>和<code>double</code>基本类型，也有对应的类似于<code>comparingInt</code>和<code>thenComparingInt的</code>方法，<code>int</code>版本的方法也可以应用于取值范围小于 <code>int</code>的类型上，如<code>short</code>类型，如<code>PhoneNumber</code>实例中所示。对于<code>double</code>版本的方法也可以用在<code>float</code>类型上。这提供了所有Java的基本数字类型的覆盖。</p><p>也有对象引用类型的比较器构建方法。静态方法<code>comparing</code>有两个重载方式。第一个方法使用键提取器函数式接口并按键的自然顺序。第二种方法是键提取器函数式接口和比较器，用于键的排序。<code>thenComparing</code>方法有三种重载。第一个重载只需要一个比较器，并使用它来提供一个二级排序。第二次重载只需要一个键提取器函数式接口，并使用键的自然顺序作为二级排序。最后的重载方法同时使用一个键提取器函数式接口和一个比较器来用在提取的键上。</p><p>有时，你可能会看到<code>compareTo</code>或<code>compare</code>方法依赖于两个值之间的差值，如果第一个值小于第二个值，则为负；如果两个值相等则为零，如果第一个值大于，则为正值。这是一个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// BROKEN difference-based comparator - violates transitivity!</span><br><span class="line"></span><br><span class="line">static Comparator&lt;Object&gt; hashCodeOrder = new Comparator&lt;&gt;() &#123;</span><br><span class="line">    public int compare(Object o1, Object o2) &#123;</span><br><span class="line">        return o1.hashCode() - o2.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>不要使用这种技术！它可能会导致整数最大长度溢出和IEEE 754浮点运算失真的危险[JLS 15.20.1,15.21.1]。 此外，由此产生的方法不可能比使用上述技术编写的方法快得多。 使用静态<code>compare</code>方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">**// Comparator based on static compare method**</span><br><span class="line">static Comparator&lt;Object&gt; hashCodeOrder = new Comparator&lt;&gt;() &#123;</span><br><span class="line">    public int compare(Object o1, Object o2) &#123;</span><br><span class="line">        return Integer.compare(o1.hashCode(), o2.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>或者使用<code>Comparator</code>的构建方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// Comparator based on Comparator construction method</span><br><span class="line">static Comparator&lt;Object&gt; hashCodeOrder =</span><br><span class="line">        Comparator.comparingInt(o -&gt; o.hashCode());</span><br></pre></td></tr></table></figure><p>总而言之，无论何时实现具有合理排序的值类，你都应该让该类实现<code>Comparable</code>接口，以便在基于比较的集合中轻松对其实例进行排序，搜索和使用。 比较<code>compareTo</code>方法的实现中的字段值时，请避免使用”&lt;”和”&gt;”运算符。 相反，使用包装类中的静态<code>compare</code>方法或<code>Comparator</code>接口中的构建方法。</p><h2 id="15-使类和成员的可访问性最小化"><a href="#15-使类和成员的可访问性最小化" class="headerlink" title="15. 使类和成员的可访问性最小化"></a>15. 使类和成员的可访问性最小化</h2><p>将设计良好的组件与设计不佳的组件区分开来的最重要的因素是，组件将其内部数据和其他组件的其他实现细节隐藏起来。一个设计良好的组件隐藏了它的所有实现细节，干净地将它的API与它的实现分离开来。然后，组件只通过它们的API进行通信，并且对彼此的内部工作一无所知。这一概念，被称为信息隐藏或封装，是软件设计的基本原则[Parnas72]。</p><p>信息隐藏很重要有很多原因，其中大部分来源于它将组成系统的组件分离开来，允许它们被独立地开发，测试，优化，使用，理解和修改。这加速了系统开发，因为组件可以并行开发。它减轻了维护的负担，因为可以更快速地理解组件，调试或更换组件，而不用担心损害其他组件。虽然信息隐藏本身并不会导致良好的性能，但它可以有效地进行性能调整：一旦系统完成并且分析确定了哪些组件导致了性能问题（条目 67），则可以优化这些组件，而不会影响别人的正确的组件。信息隐藏增加了软件重用，因为松耦合的组件通常在除开发它们之外的其他环境中证明是有用的。最后，隐藏信息降低了构建大型系统的风险，因为即使系统不能运行，各个独立的组件也可能是可用的。</p><p>Java提供了许多机制来帮助信息隐藏。 访问控制机制（access control mechanism）[JLS，6.6]指定了类，接口和成员的可访问性。 实体的可访问性取决于其声明的位置，以及声明中存在哪些访问修饰符（private，protected和public）。 正确使用这些修饰符对信息隐藏至关重要。</p><p>经验法则很简单：<strong>让每个类或成员尽可能地不可访问</strong>。换句话说，使用尽可能低的访问级别，与你正在编写的软件的对应功能保持一致。</p><p>对于顶层(非嵌套的)类和接口，只有两个可能的访问级别:包级私有（package-private）和公共的（public）。如果你使用public修饰符声明顶级类或接口，那么它是公开的；否则，它是包级私有的。如果一个顶层类或接口可以被做为包级私有，那么它应该是。通过将其设置为包级私有，可以将其作为实现的一部分，而不是导出的API，你可以修改它、替换它，或者在后续版本中消除它，而不必担心损害现有的客户端。如果你把它公开，你就有义务永远地支持它，以保持兼容性。</p><p>如果一个包级私有顶级类或接口只被一个类使用，那么可以考虑这个类作为使用它的唯一类的私有静态嵌套类(条目 24)。这将它的可访问性从包级的所有类减少到使用它的一个类。但是，减少不必要的公共类的可访问性要比包级私有的顶级类更重要：公共类是包的API的一部分，而包级私有的顶级类已经是这个包实现的一部分了。</p><p>对于成员(属性、方法、嵌套类和嵌套接口)，有四种可能的访问级别，在这里，按照可访问性从小到大列出：</p><ul><li>private——该成员只能在声明它的顶级类内访问。</li><li>package-private——成员可以从被声明的包中的任何类中访问。从技术上讲，如果没有指定访问修饰符(接口成员除外，它默认是公共的)，这是默认访问级别。</li><li>protected——成员可以从被声明的类的子类中访问(受一些限制，JLS，6.6.2)，以及它声明的包中的任何类。</li><li>public——该成员可以从任何地方被访问。</li></ul><p>在仔细设计你的类的公共API之后，你的反应应该是让所有其他成员设计为私有的。 只有当同一个包中的其他类真的需要访问成员时，需要删除私有修饰符，从而使成员包成为包级私有的。 如果你发现自己经常这样做，你应该重新检查你的系统的设计，看看另一个分解可能产生更好的解耦的类。 也就是说，私有成员和包级私有成员都是类实现的一部分，通常不会影响其导出的API。 但是，如果类实现Serializable接口（条目 86和87），则这些属性可以“泄漏（leak）”到导出的API中。</p><p>对于公共类的成员，当访问级别从包私有到受保护级时，可访问性会大大增加。 受保护（protected）的成员是类导出的API的一部分，并且必须永远支持。 此外，导出类的受保护成员表示对实现细节的公开承诺（条目 19）。 对受保护成员的需求应该相对较少。</p><p>有一个关键的规则限制了你减少方法访问性的能力。 如果一个方法重写一个超类方法，那么它在子类中的访问级别就不能低于父类中的访问级别[JLS，8.4.8.3]。 这对于确保子类的实例在父类的实例可用的地方是可用的（Liskov替换原则，见条目 15）是必要的。 如果违反此规则，编译器将在尝试编译子类时生成错误消息。 这个规则的一个特例是，如果一个类实现了一个接口，那么接口中的所有类方法都必须在该类中声明为public。</p><p>为了便于测试你的代码，你可能会想要让一个类，接口或者成员更容易被访问。 这没问题。 为了测试将公共类的私有成员指定为包级私有是可以接受的，但是提高到更高的访问级别却是不可接受的。 换句话说，将类，接口或成员作为包级导出的API的一部分来促进测试是不可接受的。 幸运的是，这不是必须的，因为测试可以作为被测试包的一部分运行，从而获得对包私有元素的访问。</p><p><strong>公共类的实例属性很少公开(条目 16)</strong>。如果一个实例属性是非final的，或者是对可变对象的引用，那么通过将其公开，你就放弃了限制可以存储在属性中的值的能力。这意味着你放弃了执行涉及该属性的不变量的能力。另外，当属性被修改时，就放弃了采取任何操作的能力，因此<strong>公共可变属性的类通常不是线程安全的</strong>。即使属性是final的，并且引用了一个不可变的对象，通过使它公开，你就放弃切换到不存在属性的新的内部数据表示的灵活性。</p><p>同样的建议适用于静态属性，但有一个例外。 假设常量是类的抽象的一个组成部分，你可以通过<code>public static final</code>属性暴露常量。 按照惯例，这些属性的名字由大写字母组成，字母用下划线分隔（条目 68）。 很重要的一点是，这些属性包含基本类型的值或对不可变对象的引用（条目 17）。 包含对可变对象的引用的属性具有非final属性的所有缺点。 虽然引用不能被修改，但引用的对象可以被修改，并会带来灾难性的结果。</p><p>请注意，非零长度的数组总是可变的，所以<strong>类具有公共静态final数组属性，或返回这样一个属性的访问器是错误的</strong>。 如果一个类有这样的属性或访问方法，客户端将能够修改数组的内容。 这是安全漏洞的常见来源：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// Potential security hole!</span><br><span class="line">public static final Thing[] VALUES = &#123; ... &#125;;</span><br></pre></td></tr></table></figure><p>要小心这样的事实，一些IDE生成的访问方法返回对私有数组属性的引用，导致了这个问题。 有两种方法可以解决这个问题。 你可以使公共数组私有并添加一个公共的不可变列表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private static final Thing[] PRIVATE_VALUES = &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line">public static final List&lt;Thing&gt; VALUES =</span><br><span class="line"></span><br><span class="line">Collections.unmodifiableList(Arrays.asList(PRIVATE_VALUES));</span><br></pre></td></tr></table></figure><p>或者，可以将数组设置为private，并添加一个返回私有数组拷贝的公共方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private static final Thing[] PRIVATE_VALUES = &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line">public static final Thing[] values() &#123;</span><br><span class="line">    return PRIVATE_VALUES.clone();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要在这些方法之间进行选择，请考虑客户端可能如何处理返回的结果。 哪种返回类型会更方便？ 哪个会更好的表现？</p><p>在Java 9中，作为模块系统（module system）的一部分引入了两个额外的隐式访问级别。模块包含一组包，就像一个包包含一组类一样。模块可以通过模块声明中的导出（export）声明显式地导出某些包(这是module-info.java的源文件中包含的约定)。模块中的未导出包的公共和受保护成员在模块之外是不可访问的；在模块中，可访问性不受导出（export）声明的影响。使用模块系统允许你在模块之间共享类，而不让它们对整个系统可见。在未导出的包中，公共和受保护的公共类的成员会产生两个隐式访问级别，这是普通公共和受保护级别的内部类似的情况。这种共享的需求是相对少见的，并且可以通过重新安排包中的类来消除。</p><p>与四个主要访问级别不同，这两个基于模块的级别主要是建议（advisory）。 如果将模块的JAR文件放在应用程序的类路径而不是其模块路径中，那么模块中的包将恢复为非模块化行为：包的公共类的所有公共类和受保护成员都具有其普通的可访问性，不管包是否由模块导出[Reinhold，1.2]。 新引入的访问级别严格执行的地方是JDK本身：Java类库中未导出的包在模块之外真正无法访问。</p><p>对于典型的Java程序员来说，不仅程序模块所提供的访问保护存在局限性，而且在本质上是很大程度上建议性的；为了利用它，你必须把你的包组合成模块，在模块声明中明确所有的依赖关系，重新安排你的源码树层级，并采取特殊的行动来适应你的模块内任何对非模块化包的访问[Reinhold ，3]。 现在说模块是否会在JDK之外得到广泛的使用还为时尚早。 与此同时，除非你有迫切的需要，否则似乎最好避免它们。</p><p>总而言之，应该尽可能地减少程序元素的可访问性（在合理范围内）。 在仔细设计一个最小化的公共API之后，你应该防止任何散乱的类，接口或成员成为API的一部分。 除了作为常量的公共静态final属性之外，公共类不应该有公共属性。 确保<code>public static final</code>属性引用的对象是不可变的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;11-重写equals方法时同时也要重写hashcode方法&quot;&gt;&lt;a href=&quot;#11-重写equals方法时同时也要重写hashcode方法&quot; class=&quot;headerlink&quot; title=&quot;11. 重写equals方法时同时也要重写hashcode方法&quot;
      
    
    </summary>
    
      <category term="java" scheme="http://luxiangdong.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>Effective Java中文版(item:06-10)</title>
    <link href="http://luxiangdong.com/2018/05/09/effective-java-cn-06-10/"/>
    <id>http://luxiangdong.com/2018/05/09/effective-java-cn-06-10/</id>
    <published>2018-05-09T01:24:43.000Z</published>
    <updated>2018-05-09T01:32:47.919Z</updated>
    
    <content type="html"><![CDATA[<h2 id="6-避免创建不必要的对象"><a href="#6-避免创建不必要的对象" class="headerlink" title="6. 避免创建不必要的对象"></a>6. 避免创建不必要的对象</h2><p>在每次需要时重用一个对象而不是创建一个新的相同功能对象通常是恰当的。重用可以更快更流行。如果对象是不可变的(条目 17)，它总是可以被重用。</p><p>作为一个不应该这样做的极端例子，请考虑以下语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s = new String(&quot;bikini&quot;);  // DON&apos;T DO THIS!</span><br></pre></td></tr></table></figure><p>语句每次执行时都会创建一个新的String实例，而这些对象的创建都不是必需的。String构造方法<code>(“bikini”)</code>的参数本身就是一个<code>bikini</code>实例，它与构造方法创建的所有对象的功能相同。如果这种用法发生在循环中，或者在频繁调用的方法中，就可以毫无必要地创建数百万个String实例。</p><p>改进后的版本如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s = &quot;bikini&quot;;</span><br></pre></td></tr></table></figure><p>该版本使用单个String实例，而不是每次执行时创建一个新实例。此外，它可以保证对象运行在同一虚拟机上的任何其他代码重用，而这些代码恰好包含相同的字符串字面量[JLS,3.10.5]。</p><p>通过使用静态工厂方法(static factory methods(项目1)，可以避免创建不需要的对象。例如，工厂方法<code>Boolean.valueOf(String)</code>比构造方法<code>Boolean(String</code>)更可取，后者在Java 9中被弃用。构造方法每次调用时都必须创建一个新对象，而工厂方法永远不需要这样做，在实践中也不需要。除了重用不可变对象，如果知道它们不会被修改，还可以重用可变对象。</p><p>一些对象的创建比其他对象的创建要昂贵得多。 如果要重复使用这样一个“昂贵的对象”，建议将其缓存起来以便重复使用。 不幸的是，当创建这样一个对象时并不总是很直观明显的。 假设你想写一个方法来确定一个字符串是否是一个有效的罗马数字。 以下是使用正则表达式完成此操作时最简单方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Performance can be greatly improved!</span><br><span class="line">static boolean isRomanNumeral(String s) &#123;</span><br><span class="line">    return s.matches(&quot;^(?=.)M*(C[MD]|D?C&#123;0,3&#125;)&quot;</span><br><span class="line">            + &quot;(X[CL]|L?X&#123;0,3&#125;)(I[XV]|V?I&#123;0,3&#125;)$&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个实现的问题在于它依赖于<code>String.matches</code>方法。 虽然<code>String.matches</code>是检查字符串是否与正则表达式匹配的最简单方法，但它不适合在性能临界的情况下重复使用。 问题是它在内部为正则表达式创建一个<code>Pattern</code>实例，并且只使用它一次，之后它就有资格进行垃圾收集。 创建<code>Pattern</code>实例是昂贵的，因为它需要将正则表达式编译成有限状态机（finite state machine）。</p><p>为了提高性能，作为类初始化的一部分，将正则表达式显式编译为一个<code>Pattern</code>实例（不可变），缓存它，并在<code>isRomanNumeral</code>方法的每个调用中重复使用相同的实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// Reusing expensive object for improved performance</span><br><span class="line">public class RomanNumerals &#123;</span><br><span class="line">    private static final Pattern ROMAN = Pattern.compile(</span><br><span class="line">            &quot;^(?=.)M*(C[MD]|D?C&#123;0,3&#125;)&quot;</span><br><span class="line">            + &quot;(X[CL]|L?X&#123;0,3&#125;)(I[XV]|V?I&#123;0,3&#125;)$&quot;);</span><br><span class="line"></span><br><span class="line">    static boolean isRomanNumeral(String s) &#123;</span><br><span class="line">        return ROMAN.matcher(s).matches();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果经常调用，<code>isRomanNumera</code>l的改进版本的性能会显著提升。 在我的机器上，原始版本在输入8个字符的字符串上需要1.1微秒，而改进的版本则需要0.17微秒，速度提高了6.5倍。 性能上不仅有所改善，而且更明确清晰了。 为不可见的Pattern实例创建静态final修饰的属性，并允许给它一个名字，这个名字比正则表达式本身更具可读性。</p><p>如果包含<code>isRomanNumeral</code>方法的改进版本的类被初始化，但该方法从未被调用，则<code>ROMAN</code>属性则没必要初始化。 在第一次调用<code>isRomanNumeral</code>方法时，可以通过延迟初始化（ lazily initializing）属性（条目 83）来排除初始化，但一般不建议这样做。 延迟初始化常常会导致实现复杂化，而性能没有可衡量的改进（条目 67）。</p><p>当一个对象是不可变的时，很明显它可以被安全地重用，但是在其他情况下，它远没有那么明显，甚至是违反直觉的。考虑适配器（adapters）的情况[Gamma95]，也称为视图（views）。一个适配器是一个对象，它委托一个支持对象（backing object），提供一个可替代的接口。由于适配器没有超出其支持对象的状态，因此不需要为给定对象创建多个给定适配器的实例。</p><p>例如，Map接口的<code>keySet方法</code>返回Map对象的Set视图，包含Map中的所有key。 天真地说，似乎每次调用keySet都必须创建一个新的Set实例，但是对给定Map对象的<code>keySet</code>的每次调用都返回相同的Set实例。 尽管返回的Set实例通常是可变的，但是所有返回的对象在功能上都是相同的：当其中一个返回的对象发生变化时，所有其他对象也都变化，因为它们全部由相同的Map实例支持。 虽然创建<code>keySet</code>视图对象的多个实例基本上是无害的，但这是没有必要的，也没有任何好处。</p><p>另一种创建不必要的对象的方法是自动装箱（autoboxing），它允许程序员混用基本类型和包装的基本类型，根据需要自动装箱和拆箱。 自动装箱模糊不清，但不会消除基本类型和装箱基本类型之间的区别。 有微妙的语义区别和不那么细微的性能差异（条目 61）。 考虑下面的方法，它计算所有正整数的总和。 要做到这一点，程序必须使用<code>long</code>类型，因为<code>int</code>类型不足以保存所有正整数的总和：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// Hideously slow! Can you spot the object creation?</span><br><span class="line">private static long sum() &#123;</span><br><span class="line">    Long sum = 0L;</span><br><span class="line">    for (long i = 0; i &lt;= Integer.MAX_VALUE; i++)</span><br><span class="line">        sum += i;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序的结果是正确的，但由于写错了一个字符，运行的结果要比实际慢很多。变量<code>sum</code>被声明成了<code>Long</code>而不是<code>long</code>，这意味着程序构造了大约231不必要的<code>Long</code>实例（大约每次往<code>Long</code>类型的 <code>sum</code>变量中增加一个<code>long</code>类型构造的实例），把<code>sum</code>变量的类型由<code>Long</code>改为<code>long</code>，在我的机器上运行时间从6.3秒降低到0.59秒。这个教训很明显：<strong>优先使用基本类型而不是装箱的基本类型，也要注意无意识的自动装箱</strong>。</p><p>这个条目不应该被误解为暗示对象创建是昂贵的，应该避免创建对象。 相反，使用构造方法创建和回收小的对象是非常廉价，构造方法只会做很少的显示工作，，尤其是在现代JVM实现上。 创建额外的对象以增强程序的清晰度，简单性或功能性通常是件好事。</p><p>相反，除非池中的对象非常重量级，否则通过维护自己的对象池来避免对象创建是一个坏主意。对象池的典型例子就是数据库连接。建立连接的成本非常高，因此重用这些对象是有意义的。但是，一般来说，维护自己的对象池会使代码混乱，增加内存占用，并损害性能。现代JVM实现具有高度优化的垃圾收集器，它们在轻量级对象上轻松胜过此类对象池。</p><p>这个条目的对应点是针对条目 50的防御性复制（defensive copying）。 目前的条目说：“当你应该重用一个现有的对象时，不要创建一个新的对象”，而条目 50说：“不要重复使用现有的对象，当你应该创建一个新的对象时。”请注意，重用防御性复制所要求的对象所付出的代价，要远远大于不必要地创建重复的对象。 未能在需要的情况下防御性复制会导致潜在的错误和安全漏洞；而不必要地创建对象只会影响程序的风格和性能。</p><h2 id="7-消除过期的对象引用"><a href="#7-消除过期的对象引用" class="headerlink" title="7. 消除过期的对象引用"></a>7. 消除过期的对象引用</h2><p>如果你从使用手动内存管理的语言(如C或c++)切换到像Java这样的带有垃圾收集机制的语言，那么作为程序员的工作就会变得容易多了，因为你的对象在使用完毕以后就自动回收了。当你第一次体验它的时候，它就像魔法一样。这很容易让人觉得你不需要考虑内存管理，但这并不完全正确。</p><p>考虑以下简单的堆栈实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// Can you spot the &quot;memory leak&quot;?</span><br><span class="line">public class Stack &#123;</span><br><span class="line">    private Object[] elements;</span><br><span class="line">    private int size = 0;</span><br><span class="line">    private static final int DEFAULT_INITIAL_CAPACITY = 16;</span><br><span class="line"></span><br><span class="line">    public Stack() &#123;</span><br><span class="line">        elements = new Object[DEFAULT_INITIAL_CAPACITY];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void push(Object e) &#123;</span><br><span class="line">        ensureCapacity();</span><br><span class="line">        elements[size++] = e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object pop() &#123;</span><br><span class="line">        if (size == 0)</span><br><span class="line">            throw new EmptyStackException();</span><br><span class="line">        return elements[--size];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Ensure space for at least one more element, roughly</span><br><span class="line">     * doubling the capacity each time the array needs to grow.</span><br><span class="line">     */</span><br><span class="line">    private void ensureCapacity() &#123;</span><br><span class="line">        if (elements.length == size)</span><br><span class="line">            elements = Arrays.copyOf(elements, 2 * size + 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序没有什么明显的错误（但是对于泛型版本，请参阅条目 29）。 你可以对它进行详尽的测试，它都会成功地通过每一项测试，但有一个潜在的问题。 笼统地说，程序有一个“内存泄漏”，由于垃圾回收器的活动的增加，或内存占用的增加，静默地表现为性能下降。 在极端的情况下，这样的内存泄漏可能会导致磁盘分页（ disk paging），甚至导致内存溢出（OutOfMemoryError）的失败，但是这样的故障相对较少。</p><p>那么哪里发生了内存泄漏？ 如果一个栈增长后收缩，那么从栈弹出的对象不会被垃圾收集，即使使用栈的程序不再引用这些对象。 这是因为栈维护对这些对象的过期引用（ obsolete references）。 过期引用简单来说就是永远不会解除的引用。 在这种情况下，元素数组“活动部分（active portion）”之外的任何引用都是过期的。 活动部分是由索引下标小于size的元素组成。</p><p>垃圾收集语言中的内存泄漏（更适当地称为无意的对象保留 unintentional object retentions）是隐蔽的。 如果无意中保留了对象引用，那么不仅这个对象排除在垃圾回收之外，而且该对象引用的任何对象也是如此。 即使只有少数对象引用被无意地保留下来，也可以阻止垃圾回收机制对许多对象的回收，这对性能产生很大的影响。</p><p>这类问题的解决方法很简单：一旦对象引用过期，将它们设置为 null。 在我们的<code>Stack</code>类的情景下，只要从栈中弹出，元素的引用就设置为过期。 <code>pop</code>方法的修正版本如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public Object pop() &#123;</span><br><span class="line">    if (size == 0)</span><br><span class="line">        throw new EmptyStackException();</span><br><span class="line">    Object result = elements[--size];</span><br><span class="line">    elements[size] = null; // Eliminate obsolete reference</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>取消过期引用的另一个好处是，如果它们随后被错误地引用，程序立即抛出<code>NullPointerException</code>异常，而不是悄悄地做继续做错误的事情。尽可能快地发现程序中的错误是有好处的。</p><p>当程序员第一次被这个问题困扰时，他们可能会在程序结束后立即清空所有对象引用。这既不是必要的，也不是可取的；它不必要地搞乱了程序。<strong>清空对象引用应该是例外而不是规范</strong>。消除过期引用的最好方法是让包含引用的变量超出范围。如果在最近的作用域范围内定义每个变量(条目 57)，这种自然就会出现这种情况。</p><p>那么什么时候应该清空一个引用呢？<code>Stack</code>类的哪个方面使它容易受到内存泄漏的影响？简单地说，它管理自己的内存。存储池（storage pool）由<code>elements</code>数组的元素组成(对象引用单元，而不是对象本身)。数组中活动部分的元素(如前面定义的)被分配，其余的元素都是空闲的。垃圾收集器没有办法知道这些；对于垃圾收集器来说，<code>elements</code>数组中的所有对象引用都同样有效。只有程序员知道数组的非活动部分不重要。程序员可以向垃圾收集器传达这样一个事实，一旦数组中的元素变成非活动的一部分，就可以手动清空这些元素的引用。</p><p>一般来说，<strong>当一个类自己管理内存时，程序员应该警惕内存泄漏问题</strong>。 每当一个元素被释放时，元素中包含的任何对象引用都应该被清除。</p><p><strong>另一个常见的内存泄漏来源是缓存</strong>。一旦将对象引用放入缓存中，很容易忘记它的存在，并且在它变得无关紧要之后，仍然保留在缓存中。对于这个问题有几种解决方案。如果你正好想实现了一个缓存：只要在缓存之外存在对某个项（entry）的键（key）引用，那么这项就是明确有关联的，就可以用<code>WeakHashMap</code>来表示缓存；这些项在过期之后自动删除。记住，只有当缓存中某个项的生命周期是由外部引用到键（key）而不是值（value）决定时，<code>WeakHashMap</code>才有用。</p><p>更常见的情况是，缓存项有用的生命周期不太明确，随着时间的推移一些项变得越来越没有价值。在这种情况下，缓存应该偶尔清理掉已经废弃的项。这可以通过一个后台线程(也许是<code>ScheduledThreadPoolExecutor</code>)或将新的项添加到缓存时顺便清理。<code>LinkedHashMap</code>类使用它的<code>removeEldestEntry</code>方法实现了后一种方案。对于更复杂的缓存，可能直接需要使用<code>java.lang.ref</code>。</p><p>第三个常见的内存泄漏来源是监听器和其他回调。如果你实现了一个API，其客户端注册回调，但是没有显式地撤销注册回调，除非采取一些操作，否则它们将会累积。确保回调是垃圾收集的一种方法是只存储弱引用（weak references），例如，仅将它们保存在<code>WeakHashMap</code>的键（key）中。</p><p>因为内存泄漏通常不会表现为明显的故障，所以它们可能会在系统中保持多年。 通常仅在仔细的代码检查或借助堆分析器（ heap profiler）的调试工具才会被发现。 因此，学习如何预见这些问题，并防止这些问题发生，是非常值得的。</p><h2 id="8-避免使用Finalizer和Cleaner机制"><a href="#8-避免使用Finalizer和Cleaner机制" class="headerlink" title="8. 避免使用Finalizer和Cleaner机制"></a>8. 避免使用Finalizer和Cleaner机制</h2><p>Finalizer机制是不可预知的，往往是危险的，而且通常是不必要的。 它们的使用会导致不稳定的行为，糟糕的性能和移植性问题。 Finalizer机制有一些特殊的用途，我们稍后会在这个条目中介绍，但是通常应该避免它们。 从Java 9开始，Finalizer机制已被弃用，但仍被Java类库所使用。 Java 9中 Cleaner机制代替了Finalizer机制。 Cleaner机制不如Finalizer机制那样危险，但仍然是不可预测，运行缓慢并且通常是不必要的。</p><p>提醒C++程序员不要把Java中的Finalizer或Cleaner机制当成的C ++析构函数的等价物。 在C++中，析构函数是回收对象相关资源的正常方式，是与构造方法相对应的。 在Java中，当一个对象变得不可达时，垃圾收集器回收与对象相关联的存储空间，不需要开发人员做额外的工作。 C ++析构函数也被用来回收其他非内存资源。 在Java中，try-with-resources或try-finally块用于此目的（条目 9）。</p><p>Finalizer和Cleaner机制的一个缺点是不能保证他们能够及时执行[JLS，12.6]。 在一个对象变得无法访问时，到Finalizer和Cleaner机制开始运行时，这期间的时间是任意长的。 这意味着你永远不应该Finalizer和Cleaner机制做任何时间敏感（time-critical）的事情。 例如，依赖于Finalizer和Cleaner机制来关闭文件是严重的错误，因为打开的文件描述符是有限的资源。 如果由于系统迟迟没有运行Finalizer和Cleaner机制而导致许多文件被打开，程序可能会失败，因为它不能再打开文件了。</p><p>及时执行Finalizer和 Cleaner机制是垃圾收集算法的一个功能，这种算法在不同的实现中有很大的不同。程序的行为依赖于Finalizer和 Cleaner机制的及时执行，其行为也可能大不不同。 这样的程序完全可以在你测试的JVM上完美运行，然而在你最重要的客户的机器上可能运行就会失败。</p><p>延迟终结（finalization）不只是一个理论问题。为一个类提供一个Finalizer机制可以任意拖延它的实例的回收。一位同事调试了一个长时间运行的GUI应用程序，这个应用程序正在被一个OutOfMemoryError错误神秘地死掉。分析显示，在它死亡的时候，应用程序的Finalizer机制队列上有成千上万的图形对象正在等待被终结和回收。不幸的是，Finalizer机制线程的运行优先级低于其他应用程序线程，所以对象被回收的速度低于进入队列的速度。语言规范并不保证哪个线程执行Finalizer机制，因此除了避免使用Finalizer机制之外，没有轻便的方法来防止这类问题。在这方面， Cleaner机制比Finalizer机制要好一些，因为Java类的创建者可以控制自己cleaner机制的线程，但cleaner机制仍然在后台运行，在垃圾回收器的控制下运行，但不能保证及时清理。</p><p>Java规范不能保证Finalizer和Cleaner机制能及时运行；它甚至不能能保证它们是否会运行。当一个程序结束后，一些不可达对象上的Finalizer和Cleaner机制仍然没有运行。因此，不应该依赖于Finalizer和Cleaner机制来更新持久化状态。例如，依赖于Finalizer和Cleaner机制来释放对共享资源(如数据库)的持久锁，这是一个使整个分布式系统陷入停滞的好方法。</p><p>不要相信<code>System.gc</code>和<code>System.runFinalization</code>方法。 他们可能会增加Finalizer和Cleaner机制被执行的几率，但不能保证一定会执行。 曾经声称做出这种保证的两个方法：<code>System.runFinalizersOnExit</code>和它的孪生兄弟<code>Runtime.runFinalizersOnExit</code>，包含致命的缺陷，并已被弃用了几十年[ThreadStop]。</p><p>Finalizer机制的另一个问题是在执行Finalizer机制过程中，未捕获的异常会被忽略，并且该对象的Finalizer机制也会终止 [JLS, 12.6]。未捕获的异常会使其他对象陷入一种损坏的状态（corrupt state）。如果另一个线程试图使用这样一个损坏的对象，可能会导致任意不确定的行为。通常情况下，未捕获的异常将终止线程并打印堆栈跟踪（ stacktrace），但如果发生在Finalizer机制中，则不会发出警告。Cleaner机制没有这个问题，因为使用Cleaner机制的类库可以控制其线程。</p><p>使用finalizer和cleaner机制会导致严重的性能损失。 在我的机器上，创建一个简单的<code>AutoCloseable</code>对象，使用try-with-resources关闭它，并让垃圾回收器回收它的时间大约是12纳秒。 使用finalizer机制，而时间增加到550纳秒。 换句话说，使用finalizer机制创建和销毁对象的速度要慢50倍。 这主要是因为finalizer机制会阻碍有效的垃圾收集。 如果使用它们来清理类的所有实例(在我的机器上的每个实例大约是500纳秒)，那么cleaner机制的速度与finalizer机制的速度相当，但是如果仅将它们用作安全网（ safety net），则cleaner机制要快得多，如下所述。 在这种环境下，创建，清理和销毁一个对象在我的机器上需要大约66纳秒，这意味着如果你不使用安全网的话，需要支付5倍(而不是50倍)的保险。</p><p>finalizer机制有一个严重的安全问题：它们会打开你的类来进行finalizer机制攻击。finalizer机制攻击的想法很简单：如果一个异常是从构造方法或它的序列化中抛出的——<code>readObjec</code>t和<code>readResolve</code>方法(第12章)——恶意子类的finalizer机制可以运行在本应该“中途夭折（died on the vine）”的部分构造对象上。finalizer机制可以在静态字属性记录对对象的引用，防止其被垃圾收集。一旦记录了有缺陷的对象，就可以简单地调用该对象上的任意方法，而这些方法本来就不应该允许存在。从构造方法中抛出异常应该足以防止对象出现；而在finalizer机制存在下，则不是。这样的攻击会带来可怕的后果。Final类不受finalizer机制攻击的影响，因为没有人可以编写一个final类的恶意子类。为了保护非final类不受finalizer机制攻击，编写一个final的<code>finalize</code>方法，它什么都不做。</p><p>那么，你应该怎样做呢？为对象封装需要结束的资源(如文件或线程)，而不是为该类编写Finalizer和Cleaner机制？让你的类实现<code>AutoCloseable</code>接口即可，并要求客户在在不再需要时调用每个实例close方法，通常使用try-with-resources确保终止，即使面对有异常抛出情况（条目 9）。一个值得一提的细节是实例必须跟踪是否已经关闭：close方法必须记录在对象里不再有效的属性，其他方法必须检查该属性，如果在对象关闭后调用它们，则抛出IllegalStateException异常。</p><p>那么，Finalizer和Cleaner机制有什么好处呢？它们可能有两个合法用途。一个是作为一个安全网（safety net），以防资源的拥有者忽略了它的<code>close</code>方法。虽然不能保证Finalizer和Cleaner机制会迅速运行(或者根本就没有运行)，最好是把资源释放晚点出来，也要好过客户端没有这样做。如果你正在考虑编写这样的安全网Finalizer机制，请仔细考虑一下这样保护是否值得付出对应的代价。一些Java库类，如<code>FileInputStream</code>、<code>FileOutputStream</code>、<code>ThreadPoolExecutor</code>和<code>java.sql.Connection</code>，都有作为安全网的Finalizer机制。</p><p>第二种合理使用Cleaner机制的方法与本地对等类（native peers）有关。本地对等类是一个由普通对象委托的本地(非Java)对象。由于本地对等类不是普通的 Java对象，所以垃圾收集器并不知道它，当它的Java对等对象被回收时，本地对等类也不会回收。假设性能是可以接受的，并且本地对等类没有关键的资源，那么Finalizer和Cleaner机制可能是这项任务的合适的工具。但如果性能是不可接受的，或者本地对等类持有必须迅速回收的资源，那么类应该有一个<code>close</code>方法，正如前面所述。</p><p>Cleaner机制使用起来有点棘手。下面是演示该功能的一个简单的<code>Room</code>类。假设<code>Room</code>对象必须在被回收前清理干净。<code>Room</code>类实现<code>AutoCloseable</code>接口；它的自动清理安全网使用的是一个Cleaner机制，这仅仅是一个实现细节。与Finalizer机制不同，Cleaner机制不污染一个类的公共API：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// An autocloseable class using a cleaner as a safety net</span><br><span class="line">public class Room implements AutoCloseable &#123;</span><br><span class="line">    private static final Cleaner cleaner = Cleaner.create();</span><br><span class="line"></span><br><span class="line">    // Resource that requires cleaning. Must not refer to Room!</span><br><span class="line">    private static class State implements Runnable &#123;</span><br><span class="line">        int numJunkPiles; // Number of junk piles in this room</span><br><span class="line"></span><br><span class="line">        State(int numJunkPiles) &#123;</span><br><span class="line">            this.numJunkPiles = numJunkPiles;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Invoked by close method or cleaner</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(&quot;Cleaning room&quot;);</span><br><span class="line">            numJunkPiles = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // The state of this room, shared with our cleanable</span><br><span class="line">    private final State state;</span><br><span class="line"></span><br><span class="line">    // Our cleanable. Cleans the room when it’s eligible for gc</span><br><span class="line">    private final Cleaner.Cleanable cleanable;</span><br><span class="line"></span><br><span class="line">    public Room(int numJunkPiles) &#123;</span><br><span class="line">        state = new State(numJunkPiles);</span><br><span class="line">        cleanable = cleaner.register(this, state);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void close() &#123;</span><br><span class="line">        cleanable.clean();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态内部<code>State</code>类拥有Cleaner机制清理房间所需的资源。 在这里，它仅仅包含<code>numJunkPiles</code>属性，它代表混乱房间的数量。 更实际地说，它可能是一个final修饰的<code>long</code>类型的指向本地对等类的指针。 <code>State</code>类实现了<code>Runnable</code>接口，其<code>run</code>方法最多只能调用一次，只能被我们在<code>Room</code>构造方法中用Cleaner机制注册<code>State</code>实例时得到的<code>Cleanable</code>调用。 对<code>run</code>方法的调用通过以下两种方法触发：通常，通过调用<code>Room</code>的<code>close</code>方法内调用<code>Cleanable</code>的<code>clean</code>方法来触发。 如果在<code>Room</code>实例有资格进行垃圾回收的时候客户端没有调用<code>close</code>方法，那么Cleaner机制将（希望）调用<code>State</code>的<code>run</code>方法。</p><p>一个<code>State</code>实例不引用它的<code>Room</code>实例是非常重要的。如果它引用了，则创建了一个循环，阻止了<code>Room</code>实例成为垃圾收集的资格(以及自动清除)。因此，<code>State</code>必须是静态的嵌内部类，因为非静态内部类包含对其宿主类的实例的引用(条目 24)。同样，使用lambda表达式也是不明智的，因为它们很容易获取对宿主类对象的引用。</p><p>就像我们之前说的，<code>Room</code>的Cleaner机制仅仅被用作一个安全网。如果客户将所有<code>Room</code>的实例放在try-with-resource块中，则永远不需要自动清理。行为良好的客户端如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Adult &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try (Room myRoom = new Room(7)) &#123;</span><br><span class="line">            System.out.println(&quot;Goodbye&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如你所预料的，运行<code>Adult</code>程序会打印<code>Goodbye</code>字符串，随后打印<code>Cleaning room</code>字符串。但是如果时不合规矩的程序，它从来不清理它的房间会是什么样的?</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Teenager &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new Room(99);</span><br><span class="line">        System.out.println(&quot;Peace out&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可能期望它打印出<code>Peace out</code>，然后打印<code>Cleaning room</code>字符串，但在我的机器上，它从不打印<code>Cleaning room</code>字符串；仅仅是程序退出了。 这是我们之前谈到的不可预见性。 Cleaner机制的规范说：“<code>System.exit</code>方法期间的清理行为是特定于实现的。 不保证清理行为是否被调用。”虽然规范没有说明，但对于正常的程序退出也是如此。 在我的机器上，将<code>System.gc()</code>方法添加到<code>Teenager</code>类的<code>main</code>方法足以让程序退出之前打印<code>Cleaning room</code>，但不能保证在你的机器上会看到相同的行为。</p><p>总之，除了作为一个安全网或者终止非关键的本地资源，不要使用Cleaner机制，或者是在Java 9发布之前的finalizers机制。即使是这样，也要当心不确定性和性能影响。</p><h2 id="9-使用try-with-resources语句替代try-finally语句"><a href="#9-使用try-with-resources语句替代try-finally语句" class="headerlink" title="9. 使用try-with-resources语句替代try-finally语句"></a>9. 使用try-with-resources语句替代try-finally语句</h2><p>Java类库中包含许多必须通过调用<code>close</code>方法手动关闭的资源。 比如<code>InputStream</code>，<code>OutputStream</code>和<code>java.sql.Connection</code>。 客户经常忽视关闭资源，其性能结果可想而知。 尽管这些资源中有很多使用finalizer机制作为安全网，但finalizer机制却不能很好地工作（条目 8）。</p><p>从以往来看，try-finally语句是保证资源正确关闭的最佳方式，即使是在程序抛出异常或返回的情况下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// try-finally - No longer the best way to close resources!</span><br><span class="line">static String firstLineOfFile(String path) throws IOException &#123;</span><br><span class="line">    BufferedReader br = new BufferedReader(new FileReader(path));</span><br><span class="line">    try &#123;</span><br><span class="line">        return br.readLine();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这可能看起来并不坏，但是当添加第二个资源时，情况会变得更糟：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// try-finally is ugly when used with more than one resource!</span><br><span class="line">static void copy(String src, String dst) throws IOException &#123;</span><br><span class="line">    InputStream in = new FileInputStream(src);</span><br><span class="line">    try &#123;</span><br><span class="line">        OutputStream out = new FileOutputStream(dst);</span><br><span class="line">        try &#123;</span><br><span class="line">            byte[] buf = new byte[BUFFER_SIZE];</span><br><span class="line">            int n;</span><br><span class="line">            while ((n = in.read(buf)) &gt;= 0)</span><br><span class="line">                out.write(buf, 0, n);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            out.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这可能很难相信，但即使是优秀的程序员，大多数时候也会犯错误。首先，我在Java Puzzlers[Bloch05]的第88页上弄错了，多年来没有人注意到。事实上，2007年Java类库中使用<code>close</code>方法的三分之二都是错误的。</p><p>即使是用try-finally语句关闭资源的正确代码，如前面两个代码示例所示，也有一个微妙的缺陷。 try-with-resources块和finally块中的代码都可以抛出异常。 例如，在<code>firstLineOfFile</code>方法中，由于底层物理设备发生故障，对<code>readLine</code>方法的调用可能会引发异常，并且由于相同的原因，调用<code>close</code>方法可能会失败。 在这种情况下，第二个异常完全冲掉了第一个异常。 在异常堆栈跟踪中没有第一个异常的记录，这可能使实际系统中的调试非常复杂——通常这是你想要诊断问题的第一个异常。 虽然可以编写代码来抑制第二个异常，但是实际上没有人这样做，因为它太冗长了。</p><p>当Java 7引入了try-with-resources语句时，所有这些问题一下子都得到了解决[JLS,14.20.3]。要使用这个构造，资源必须实现 <code>AutoCloseable</code>接口，该接口由一个返回为<code>void</code>的<code>close</code>组成。Java类库和第三方类库中的许多类和接口现在都实现或继承了<code>AutoCloseable</code>接口。如果你编写的类表示必须关闭的资源，那么这个类也应该实现<code>AutoCloseable</code>接口。</p><p>以下是我们的第一个使用try-with-resources的示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// try-with-resources - the the best way to close resources!</span><br><span class="line">static String firstLineOfFile(String path) throws IOException &#123;</span><br><span class="line">    try (BufferedReader br = new BufferedReader(</span><br><span class="line">           new FileReader(path))) &#123;</span><br><span class="line">       return br.readLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是我们的第二个使用try-with-resources的示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// try-with-resources on multiple resources - short and sweet</span><br><span class="line">static void copy(String src, String dst) throws IOException &#123;</span><br><span class="line">    try (InputStream   in = new FileInputStream(src);</span><br><span class="line">         OutputStream out = new FileOutputStream(dst)) &#123;</span><br><span class="line">        byte[] buf = new byte[BUFFER_SIZE];</span><br><span class="line">        int n;</span><br><span class="line">        while ((n = in.read(buf)) &gt;= 0)</span><br><span class="line">            out.write(buf, 0, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不仅 try-with-resources版本比原始版本更精简，更好的可读性，而且它们提供了更好的诊断。 考虑<code>firstLineOfFile</code>方法。 如果调用<code>readLine</code>和（不可见）<code>close</code>方法都抛出异常，则后一个异常将被抑制（suppressed），而不是前者。 事实上，为了保留你真正想看到的异常，可能会抑制多个异常。 这些抑制的异常没有呗被抛弃， 而是打印在堆栈跟踪中，并标注为被抑制了。 你也可以使用<code>getSuppressed</code>方法以编程方式访问它们，该方法在Java 7中已添加到的<code>Throwable</code>中。</p><p>可以在 try-with-resources语句中添加catch子句，就像在常规的try-finally语句中一样。这允许你处理异常，而不会在另一层嵌套中污染代码。作为一个稍微有些做作的例子，这里有一个版本的<code>firstLineOfFile</code>方法，它不会抛出异常，但是如果它不能打开或读取文件，则返回默认值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// try-with-resources with a catch clause</span><br><span class="line">static String firstLineOfFile(String path, String defaultVal) &#123;</span><br><span class="line">    try (BufferedReader br = new BufferedReader(</span><br><span class="line">           new FileReader(path))) &#123;</span><br><span class="line">        return br.readLine();</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        return defaultVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结论明确：在处理必须关闭的资源时，使用try-with-resources语句替代try-finally语句。 生成的代码更简洁，更清晰，并且生成的异常更有用。 try-with-resources语句在编写必须关闭资源的代码时会更容易，也不会出错，而使用try-finally语句实际上是不可能的。</p><h2 id="10-重写equals方法时遵守通用约定"><a href="#10-重写equals方法时遵守通用约定" class="headerlink" title="10. 重写equals方法时遵守通用约定"></a>10. 重写equals方法时遵守通用约定</h2><p>虽然<code>Object</code>是一个具体的类，但它主要是为继承而设计的。它的所有非 final方法(equals、hashCode、toString、clone和finalize)都有清晰的通用约定（ general contracts），因为它们被设计为被子类重写。任何类都有义务重写这些方法，以遵从他们的通用约定；如果不这样做，将会阻止其他依赖于约定的类(例如HashMap和HashSet)与此类一起正常工作。</p><p>本章论述何时以及如何重写<code>Object</code>类的非final的方法。这一章省略了finalize方法，因为它在条目 8中进行了讨论。<code>Comparable.compareTo</code>方法虽然不是<code>Object</code>中的方法，因为具有很多的相似性，所以也在这里讨论。</p><p>重写equals方法看起来很简单，但是有很多方式会导致重写出错，其结果可能是可怕的。避免此问题的最简单方法不是覆盖equals方法，在这种情况下，类的每个实例只与自身相等。如果满足以下任一下条件，则说明是正确的做法：</p><ul><li><p>每个类的实例都是固有唯一的。 对于像Thread这样代表活动实体而不是值的类来说，这是正确的。 Object提供的equals实现对这些类完全是正确的行为。</p></li><li><p>类不需要提供一个“逻辑相等（logical equality）”的测试功能。例如<code>java.util.regex.Pattern</code>可以重写equals 方法检查两个是否代表完全相同的正则表达式Pattern实例，但是设计者并不认为客户需要或希望使用此功能。在这种情况下，从Object继承的equals实现是最合适的。</p></li><li><p>父类已经重写了equals方法，则父类行为完全适合于该子类。例如，大多数Set从AbstractSet继承了equals实现、List从AbstractList继承了equals实现，Map从AbstractMap的Map继承了equals实现。</p></li><li><p>类是私有的或包级私有的，可以确定它的equals方法永远不会被调用。如果你非常厌恶风险，可以重写equals方法，以确保不会被意外调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Override public boolean equals(Object o) &#123;</span><br><span class="line">throw new AssertionError(); // Method is never called</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>那什么时候需要重写 equals 方法呢？如果一个类包含一个逻辑相等（ logical equality）的概念，此概念有别于对象标识（object identity），而且父类还没有重写过equals 方法。这通常用在值类（ value classes）的情况。值类只是一个表示值的类，例如Integer或String类。程序员使用equals方法比较值对象的引用，期望发现它们在逻辑上是否相等，而不是引用相同的对象。重写 equals方法不仅可以满足程序员的期望，它还支持重写过equals 的实例作为Map 的键（key），或者 Set 里的元素，以满足预期和期望的行为。</p><p>一种不需要equals方法重写的值类是使用实例控制（instance control）（条目 1）的类，以确保每个值至多存在一个对象。 枚举类型（条目 34）属于这个类别。 对于这些类，逻辑相等与对象标识是一样的，所以Object的equals方法作用逻辑equals方法。</p><p>当你重写equals方法时，必须遵守它的通用约定。Object的规范如下：<br>equals方法实现了一个等价关系（equivalence relation）。它有以下这些属性:<br>•自反性：对于任何非空引用x，<code>x.equals(x)</code>必须返回true。<br>•对称性：对于任何非空引用x和y，如果且仅当<code>y.equals(x)</code>返回true时<code>x.equals(y)</code>必须返回true。<br>•传递性：对于任何非空引用x、y、z，如果<code>x.equals(y)</code>返回true，<code>y.equals(z)</code>返回true，则<code>x.equals(z)</code>必须返回true。<br>•一致性：对于任何非空引用x和y，如果在equals比较中使用的信息没有修改，则<code>x.equals(y)</code>的多次调用必须始终返回true或始终返回false。<br>•对于任何非空引用x，<code>x.equals(null)</code>必须返回false。</p><p>除非你喜欢数学，否则这看起来有点吓人，但不要忽略它！如果一旦违反了它，很可能会发现你的程序运行异常或崩溃，并且很难确定失败的根源。套用约翰·多恩(John Donne)的说法，没有哪个类是孤立存在的。一个类的实例常常被传递给另一个类的实例。许多类，包括所有的集合类，都依赖于传递给它们遵守equals约定的对象。</p><p>既然已经意识到违反equals约定的危险，让我们详细地讨论一下这个约定。好消息是，表面上看，这并不是很复杂。一旦你理解了，就不难遵守这一约定。</p><p>那么什么是等价关系？ 笼统地说，它是一个运算符，它将一组元素划分为彼此元素相等的子集。 这些子集被称为等价类（equivalence classes）。 为了使equals方法有用，每个等价类中的所有元素必须从用户的角度来说是可以互换（interchangeable）的。 现在让我们依次看下这个五个要求：</p><p>自反性（Reflexivity）——第一个要求只是说一个对象必须与自身相等。 很难想象无意中违反了这个规定。 如果你违反了它，然后把类的实例添加到一个集合中，那么<code>contains</code>方法可能会说集合中没有包含刚添加的实例。</p><p>对称性（Symmetry）——第二个要求是，任何两个对象必须在是否相等的问题上达成一致。与第一个要求不同的是，我们不难想象在无意中违反了这一要求。例如，考虑下面的类，它实现了不区分大小写的字符串。字符串被toString保存，但在equals比较中被忽略：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Objects;</span><br><span class="line"></span><br><span class="line">public final class CaseInsensitiveString &#123;</span><br><span class="line">    private final String s;</span><br><span class="line"></span><br><span class="line">    public CaseInsensitiveString(String s) &#123;</span><br><span class="line">        this.s = Objects.requireNonNull(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Broken - violates symmetry!</span><br><span class="line">    @Override</span><br><span class="line">    public boolean equals(Object o) &#123;</span><br><span class="line">        if (o instanceof CaseInsensitiveString)</span><br><span class="line">            return s.equalsIgnoreCase(</span><br><span class="line">                    ((CaseInsensitiveString) o).s);</span><br><span class="line">        if (o instanceof String)  // One-way interoperability!</span><br><span class="line">            return s.equalsIgnoreCase((String) o);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    ...// Remainder omitted</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面类中的 equals 试图与正常的字符串进行操作，假设我们有一个不区分大小写的字符串和一个正常的字符串：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CaseInsensitiveString cis = new CaseInsensitiveString(&quot;Polish&quot;);</span><br><span class="line">String s = &quot;polish”;</span><br><span class="line"></span><br><span class="line">System.out.println(cis.equals(s)); // true</span><br><span class="line">System.out.println(s.equals(cis)); // false</span><br></pre></td></tr></table></figure><p>正如所料，<code>cis.equals(s)</code>返回true。 问题是，尽管<code>CaseInsensitiveString</code>类中的equals方法知道正常字符串，但String类中的equals方法却忽略了不区分大小写的字符串。 因此，<code>s.equals(cis</code>)返回false，明显违反对称性。 假设把一个不区分大小写的字符串放入一个集合中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;CaseInsensitiveString&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">list.add(cis);</span><br></pre></td></tr></table></figure><p><code>list.contains(s)</code>返回了什么？谁知道呢？在当前的OpenJDK实现中，它会返回false，但这只是一个实现构件。在另一个实现中，它可以很容易地返回true或抛出运行时异常。一旦违反了equals约定，就不知道其他对象在面对你的对象时会如何表现了。</p><p>要消除这个问题，只需删除equals方法中与String类相互操作的恶意尝试。这样做之后，可以将该方法重构为单个返回语句:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean equals(Object o) &#123;</span><br><span class="line">    return o instanceof CaseInsensitiveString &amp;&amp;</span><br><span class="line">            ((CaseInsensitiveString) o).s.equalsIgnoreCase(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传递性（Transitivity）——equals 约定的第三个要求是，如果第一个对象等于第二个对象，第二个对象等于第三个对象，那么第一个对象必须等于第三个对象。同样，也不难想象，无意中违反了这一要求。考虑子类的情况， 将新值组件（ value component）添加到其父类中。换句话说，子类添加了一个信息，它影响了equals方法比较。让我们从一个简单不可变的二维整数类型Point类开始：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Point &#123;</span><br><span class="line">    private final int x;</span><br><span class="line">    private final int y;</span><br><span class="line"></span><br><span class="line">    public Point(int x, int y) &#123;</span><br><span class="line">        this.x = x;</span><br><span class="line">        this.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean equals(Object o) &#123;</span><br><span class="line">        if (!(o instanceof Point))</span><br><span class="line">            return false;</span><br><span class="line">        Point p = (Point) o;</span><br><span class="line">        return p.x == x &amp;&amp; p.y == y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...  // Remainder omitted</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设想继承这个类，将表示颜色的Color类添加到Point类中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class ColorPoint extends Point &#123;</span><br><span class="line">    private final Color color;</span><br><span class="line"></span><br><span class="line">    public ColorPoint(int x, int y, Color color) &#123;</span><br><span class="line">        super(x, y);</span><br><span class="line">        this.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...  // Remainder omitted</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>equals方法应该是什么样子?如果完全忽略，则实现是从Point类上继承的，颜色信息在equals方法比较中被忽略。虽然这并不违反equals约定，但这显然是不可接受的。假设你写了一个equals方法，它只在它的参数是另一个具有相同位置和颜色的ColorPoint实例时返回true：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Broken - violates symmetry!</span><br><span class="line">@Override public boolean equals(Object o) &#123;</span><br><span class="line">    if (!(o instanceof ColorPoint))</span><br><span class="line">        return false;</span><br><span class="line">    return super.equals(o) &amp;&amp; ((ColorPoint) o).color == color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当你比较Point对象和ColorPoint对象时，可以会得到不同的结果，反之亦然。前者的比较忽略了颜色属性，而后者的比较会一直返回 false，因为参数的类型是错误的。为了让问题更加具体，我们创建一个Point对象和ColorPoint对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Point p = new Point(1, 2);</span><br><span class="line">ColorPoint cp = new ColorPoint(1, 2, Color.RED);</span><br></pre></td></tr></table></figure><p>p.equals(cp)返回 true，但是 cp.equals(p)返回 false。你可能想使用ColorPoint.equals 通过混合比较的方式来解决这个问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean equals(Object o) &#123;</span><br><span class="line">    if (!(o instanceof Point))</span><br><span class="line">        return false;</span><br><span class="line"></span><br><span class="line">    // If o is a normal Point, do a color-blind comparison</span><br><span class="line">    if (!(o instanceof ColorPoint))</span><br><span class="line">        return o.equals(this);</span><br><span class="line"></span><br><span class="line">    // o is a ColorPoint; do a full comparison</span><br><span class="line">    return super.equals(o) &amp;&amp; ((ColorPoint) o).color == color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法确实提供了对称性，但是丧失了传递性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ColorPoint p1 = new ColorPoint(1, 2, Color.RED);</span><br><span class="line">Point p2 = new Point(1, 2);</span><br><span class="line">ColorPoint p3 = new ColorPoint(1, 2, Color.BLUE);</span><br></pre></td></tr></table></figure><p>现在，<code>p1.equals(p2)</code>和<code>p2.equals(p3)</code> 返回了 true，但是<code>p1.equals(p3)</code>却返回了 false，很明显违背了传递性的要求。前两个比较都是不考虑颜色信息的，而第三个比较时却包含颜色信息。</p><p>此外，这种方法可能导致无限递归：假设有两个Point的子类，比如ColorPoint和SmellPoint，每个都有这种equals方法。 然后调用<code>myColorPoint.equals(mySmellPoint)</code>将抛出一个StackOverflowError异常。</p><p>那么解决方案是什么？ 事实证明，这是面向对象语言中关于等价关系的一个基本问题。 除非您愿意放弃面向对象抽象的好处，否则无法继承可实例化的类，并在保留 equals 约定的同时添加一个值组件。</p><p>你可能听说过，可以继承一个可实例化的类并添加一个值组件，同时通过在equals方法中使用一个getClass测试代替instanceof测试来保留equals约定：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean equals(Object o) &#123;</span><br><span class="line">    if (o == null || o.getClass() != getClass())</span><br><span class="line">        return false;</span><br><span class="line">    Point p = (Point) o;</span><br><span class="line">    return p.x == x &amp;&amp; p.y == y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只有当对象具有相同的实现类时，才会产生相同的效果。这看起来可能不是那么糟糕，但是结果是不可接受的:一个Point类子类的实例仍然是一个Point的实例，它仍然需要作为一个Point来运行，但是如果你采用这个方法，就会失败！假设我们要写一个方法来判断一个Point 对象是否在unitCircle集合中。我们可以这样做：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private static final Set&lt;Point&gt; unitCircle = Set.of(</span><br><span class="line">        new Point( 1,  0), new Point( 0,  1),</span><br><span class="line">        new Point(-1,  0), new Point( 0, -1));</span><br><span class="line"></span><br><span class="line">public static boolean onUnitCircle(Point p) &#123;</span><br><span class="line">    return unitCircle.contains(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然这可能不是实现功能的最快方法，但它可以正常工作。假设以一种不添加值组件的简单方式继承 Point 类，比如让它的构造方法跟踪记录创建了多少实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class CounterPoint extends Point &#123;</span><br><span class="line">    private static final AtomicInteger counter =</span><br><span class="line">            new AtomicInteger();</span><br><span class="line"></span><br><span class="line">    public CounterPoint(int x, int y) &#123;</span><br><span class="line">        super(x, y);</span><br><span class="line">        counter.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int numberCreated() &#123;</span><br><span class="line">        return counter.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>里氏替代原则（ Liskov substitution principle）指出，任何类型的重要属性都应该适用于所有的子类型，因此任何为这种类型编写的方法都应该在其子类上同样适用[Liskov87]。 这是我们之前声明的一个正式陈述，即Point的子类（如CounterPoint）仍然是一个Point，必须作为一个Point类来看待。 但是，假设我们将一个CounterPoint对象传递给onUnitCircle方法。 如果Point类使用基于getClass的equals方法，则无论CounterPoint实例的x和y坐标如何，onUnitCircle方法都将返回false。 这是因为大多数集合（包括onUnitCircle方法使用的HashSet）都使用equals方法来测试是否包含元素，并且CounterPoint实例并不等于任何Point实例。 但是，如果在Point上使用了适当的基于<code>instanceof</code>的equals方法，则在使用CounterPoint实例呈现时，同样的onUnitCircle方法可以正常工作。</p><p>虽然没有令人满意的方法来继承一个可实例化的类并添加一个值组件，但是有一个很好的变通方法：按照条目18的建议，“优先使用组合而不是继承”。取代继承Point类的ColorPoint类，可以在ColorPoint类中定义一个私有Point属性，和一个公共的试图（view）（条目6）方法，用来返回具有相同位置的ColorPoint对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// Adds a value component without violating the equals contract</span><br><span class="line">public class ColorPoint &#123;</span><br><span class="line">    private final Point point;</span><br><span class="line">    private final Color color;</span><br><span class="line"></span><br><span class="line">    public ColorPoint(int x, int y, Color color) &#123;</span><br><span class="line">        point = new Point(x, y);</span><br><span class="line">        this.color = Objects.requireNonNull(color);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * Returns the point-view of this color point.</span><br><span class="line">     */</span><br><span class="line">    public Point asPoint() &#123;</span><br><span class="line">        return point;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override public boolean equals(Object o) &#123;</span><br><span class="line">        if (!(o instanceof ColorPoint))</span><br><span class="line">            return false;</span><br><span class="line">        ColorPoint cp = (ColorPoint) o;</span><br><span class="line">        return cp.point.equals(point) &amp;&amp; cp.color.equals(color);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...    // Remainder omitted</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java平台类库中有一些类可以继承可实例化的类并添加一个值组件。 例如，<code>java.sql.Timestamp</code>继承了<code>java.util.Date</code>并添加了一个nanoseconds字段。 Timestamp的等价equals确实违反了对称性，并且如果Timestamp和Date对象在同一个集合中使用，或者以其他方式混合使用，则可能导致不稳定的行为。 Timestamp类有一个免责声明，告诫程序员不要混用Timestamp和Date。 虽然只要将它们分开使用就不会遇到麻烦，但没有什么可以阻止你将它们混合在一起，并且由此产生的错误可能很难调试。 Timestamp类的这种行为是一个错误，不应该被仿效。</p><p>你可以将值组件添加到抽象类的子类中，而不会违反equals约定。这对于通过遵循第23个条目中“优先考虑类层级（class hierarchies）来代替标记类（tagged classes）”中的建议而获得的类层级，是非常重要的。例如，可以有一个没有值组件的抽象类Shape，子类Circle有一个radius属性，另一个子类Rectangle包含length和width属性 。 只要不直接创建父类实例，就不会出现前面所示的问题。</p><p>一致性——equals 约定的第四个要求是，如果两个对象是相等的，除非一个（或两个）对象被修改了， 那么它们必须始终保持相等。 换句话说，可变对象可以在不同时期可以与不同的对象相等，而不可变对象则不会。 当你写一个类时，要认真思考它是否应该设计为不可变的（条目 17）。 如果你认为应该这样做，那么确保你的equals方法强制执行这样的限制：相等的对象永远相等，不相等的对象永远都不会相等。</p><p>不管一个类是不是不可变的，都不要写一个依赖于不可靠资源的equals方法。 如果违反这一禁令，满足一致性要求是非常困难的。 例如，java.net.URL类中的equals方法依赖于与URL关联的主机的IP地址的比较。 将主机名转换为IP地址可能需要访问网络，并且不能保证随着时间的推移会产生相同的结果。 这可能会导致URL类的equals方法违反equals 约定，并在实践中造成问题。 URL类的equals方法的行为是一个很大的错误，不应该被效仿。 不幸的是，由于兼容性的要求，它不能改变。 为了避免这种问题，equals方法应该只对内存驻留对象执行确定性计算。</p><p>非空性（Non-nullity）——最后equals 约定的要求没有官方的名称，所以我冒昧地称之为“非空性”。意思是说说所有的对象都必须不等于 null。虽然很难想象在调用 <code>o.equals(null)</code>的响应中意外地返回true，但不难想象不小心抛出<code>NullPointerException</code>异常的情况。通用的约定禁止抛出这样的异常。许多类中的 equals方法都会明确阻止对象为null的情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override public boolean equals(Object o) &#123;</span><br><span class="line">    if (o == null)</span><br><span class="line">        return false;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个判断是不必要的。 为了测试它的参数是否相等，equals方法必须首先将其参数转换为合适类型，以便调用访问器或允许访问的属性。 在执行类型转换之前，该方法必须使用instanceof运算符来检查其参数是否是正确的类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Override public boolean equals(Object o) &#123;</span><br><span class="line">    if (!(o instanceof MyType))</span><br><span class="line">        return false;</span><br><span class="line">    MyType mt = (MyType) o;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果此类型检查漏掉，并且equals方法传递了错误类型的参数，那么equals方法将抛出<code>ClassCastException</code>异常，这违反了equals约定。 但是，如果第一个操作数为 null，则指定instanceof运算符返回false，而不管第二个操作数中出现何种类型[JLS，15.20.2]。 因此，如果传入null，类型检查将返回false，因此不需要 明确的 null检查。</p><p>综合起来，以下是编写高质量equals方法的配方（recipe）：</p><ol><li>使用= =运算符检查参数是否为该对象的引用。如果是，返回true。这只是一种性能优化，但是如果这种比较可能很昂贵的话，那就值得去做。</li><li>使用<code>instanceof</code>运算符来检查参数是否具有正确的类型。 如果不是，则返回false。 通常，正确的类型是equals方法所在的那个类。 有时候，改类实现了一些接口。 如果类实现了一个接口，该接口可以改进 equals约定以允许实现接口的类进行比较，那么使用接口。 集合接口（如Set，List，Map和Map.Entry）具有此特性。</li><li>参数转换为正确的类型。因为转换操作在instanceof中已经处理过，所以它肯定会成功。</li><li>对于类中的每个“重要”的属性，请检查该参数属性是否与该对象对应的属性相匹配。如果所有这些测试成功，返回true，否则返回false。如果步骤2中的类型是一个接口，那么必须通过接口方法访问参数的属性;如果类型是类，则可以直接访问属性，这取决于属性的访问权限。</li></ol><p>对于类型为非float或double的基本类型，使用= =运算符进行比较；对于对象引用属性，递归地调用equals方法；对于float 基本类型的属性，使用静态<code>Float.compare(float, float)</code>方法；对于double 基本类型的属性，使用<code>Double.compare(double, double)</code>方法。由于存在<code>Float.NaN</code>，<code>-0.0f</code>和类似的double类型的值，所以需要对float和double属性进行特殊的处理；有关详细信息，请参阅JLS 15.21.1或Float.equals方法的详细文档。 虽然你可以使用静态方法Float.equals和Double.equals方法对float和double基本类型的属性进行比较，这会导致每次比较时发生自动装箱，引发非常差的性能。 对于数组属性，将这些准则应用于每个元素。 如果数组属性中的每个元素都很重要，请使用其中一个重载的Arrays.equals方法。</p><p>某些对象引用的属性可能合法地包含null。 为避免出现NullPointerException异常，请使用静态方法 Objects.equals(Object, Object)检查这些属性是否相等。</p><p>对于一些类，例如上的<code>CaseInsensitiveString</code>类，属性比较相对于简单的相等性测试要复杂得多。在这种情况下，你想要保存属性的一个规范形式（ canonical form），这样 equals 方法就可以基于这个规范形式去做开销很小的精确比较，来取代开销很大的非标准比较。这种方式其实最适合不可变类（条目 17）。一旦对象发生改变，一定要确保把对应的规范形式更新到最新。</p><p>equals方法的性能可能受到属性比较顺序的影响。 为了获得最佳性能，你应该首先比较最可能不同的属性，开销比较小的属性，或者最好是两者都满足（derived fields）。 你不要比较不属于对象逻辑状态的属性，例如用于同步操作的lock 属性。 不需要比较可以从“重要属性”计算出来的派生属性，但是这样做可以提高equals方法的性能。 如果派生属性相当于对整个对象的摘要描述，比较这个属性将节省在比较失败时再去比较实际数据的开销。 例如，假设有一个Polygon类，并缓存该区域。 如果两个多边形的面积不相等，则不必费心比较它们的边和顶点。</p><p>当你完成编写完equals方法时，问你自己三个问题：它是对称的吗?它是传递吗?它是一致的吗?除此而外，编写单元测试加以排查，除非使用AutoValue框架(第49页)来生成equals方法，在这种情况下可以安全地省略测试。如果持有的属性失败，找出原因，并相应地修改equals方法。当然，equals方法也必须满足其他两个属性(自反性和非空性)，但这两个属性通常都会满足。</p><p>在下面这个简单的<code>PhoneNumber</code>类中展示了根据之前的配方构建的equals方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public final class PhoneNumber &#123;</span><br><span class="line"></span><br><span class="line">    private final short areaCode, prefix, lineNum;</span><br><span class="line"></span><br><span class="line">    public PhoneNumber(int areaCode, int prefix, int lineNum) &#123;</span><br><span class="line">        this.areaCode = rangeCheck(areaCode, 999, &quot;area code&quot;);</span><br><span class="line">        this.prefix = rangeCheck(prefix, 999, &quot;prefix&quot;);</span><br><span class="line">        this.lineNum = rangeCheck(lineNum, 9999, &quot;line num&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static short rangeCheck(int val, int max, String arg) &#123;</span><br><span class="line">        if (val &lt; 0 || val &gt; max)</span><br><span class="line">            throw new IllegalArgumentException(arg + &quot;: &quot; + val);</span><br><span class="line">        </span><br><span class="line">        return (short) val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean equals(Object o) &#123;</span><br><span class="line">        if (o == this)</span><br><span class="line">            return true;</span><br><span class="line">        if (!(o instanceof PhoneNumber))</span><br><span class="line">            return false;</span><br><span class="line"></span><br><span class="line">        PhoneNumber pn = (PhoneNumber) o;</span><br><span class="line"></span><br><span class="line">        return pn.lineNum == lineNum &amp;&amp; pn.prefix == prefix</span><br><span class="line">                &amp;&amp; pn.areaCode == areaCode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ... // Remainder omitted</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是一些最后提醒：</p><ol><li><p><strong>当重写equals方法时，同时也要重写hashCode方法（条目 11）。</strong></p></li><li><p><strong>不要让equals方法试图太聪明</strong>。如果只是简单地测试用于相等的属性，那么要遵守equals约定并不困难。如果你在寻找相等方面过于激进，那么很容易陷入麻烦。一般来说，考虑到任何形式的别名通常是一个坏主意。例如，File类不应该试图将引用的符号链接等同于同一文件对象。幸好 File 类并没这么做。</p></li><li><p><strong>在equal 时方法声明中，不要将参数Object替换成其他类型</strong>。对于程序员来说，编写一个看起来像这样的equals方法并不少见，然后花上几个小时苦苦思索为什么它不能正常工作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// Broken - parameter type must be Object!public boolean equals(MyClass o) &#123;   </span><br><span class="line"> …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题在于这个方法并没有重写Object.equals方法，它的参数是Object类型的，这样写只是重载了 equals 方法（Item 52）。 即使除了正常的方法之外，提供这种“强类型”的equals方法也是不可接受的，因为它可能会导致子类中的Override注解产生误报，提供不安全的错觉。<br>在这里，使用Override注解会阻止你犯这个错误(条目 40)。这个equals方法不会编译，错误消息会告诉你到底错在哪里：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Still broken, but won’t compile</span><br><span class="line">@Override public boolean equals(MyClass o) &#123;</span><br><span class="line">…</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写和测试equals(和hashCode)方法很繁琐，生的代码也很普通。替代手动编写和测试这些方法的优雅的手段是，使用谷歌AutoValue开源框架，该框架自动为你生成这些方法，只需在类上添加一个注解即可。在大多数情况下，AutoValue框架生成的方法与你自己编写的方法本质上是相同的。</p></li></ol><p>很多 IDE（例如 Eclipse，NetBeans，IntelliJ IDEA 等）也有生成equals和hashCode方法的功能，但是生成的源代码比使用AutoValue框架的代码更冗长、可读性更差，不会自动跟踪类中的更改，因此需要进行测试。这就是说，使用IDE工具生成equals(和hashCode)方法通常比手动编写它们更可取，因为IDE工具不会犯粗心大意的错误，而人类则会。</p><p>总之，除非必须：在很多情况下，不要重写equals方法，从Object继承的实现完全是你想要的。 如果你确实重写了equals 方法，那么一定要比较这个类的所有重要属性，并且以保护前面equals约定里五个规定的方式去比较。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;6-避免创建不必要的对象&quot;&gt;&lt;a href=&quot;#6-避免创建不必要的对象&quot; class=&quot;headerlink&quot; title=&quot;6. 避免创建不必要的对象&quot;&gt;&lt;/a&gt;6. 避免创建不必要的对象&lt;/h2&gt;&lt;p&gt;在每次需要时重用一个对象而不是创建一个新的相同功能对象通
      
    
    </summary>
    
      <category term="java" scheme="http://luxiangdong.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>Effective Java 中文版(item:01-05)</title>
    <link href="http://luxiangdong.com/2018/05/09/effective-java-cn-01-05/"/>
    <id>http://luxiangdong.com/2018/05/09/effective-java-cn-01-05/</id>
    <published>2018-05-09T01:24:33.000Z</published>
    <updated>2018-05-09T01:30:44.060Z</updated>
    
    <content type="html"><![CDATA[<h2 id="条目1-考虑使用静态工厂方法替代构造方法"><a href="#条目1-考虑使用静态工厂方法替代构造方法" class="headerlink" title="条目1. 考虑使用静态工厂方法替代构造方法"></a>条目1. 考虑使用静态工厂方法替代构造方法</h2><p>一个类允许客户端获取其实例的传统方式是提供一个公共构造方法。 其实还有另一种技术应该成为每个程序员工具箱的一部分。 一个类可以提供一个公共静态工厂方法，它只是一个返回类实例的静态方法。 下面是一个<code>Boolean</code>简单的例子（<code>boolean</code>基本类型的包装类）。 此方法将<code>boolean</code>基本类型转换为<code>Boolean</code>对象引用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static Boolean valueOf(boolean b) &#123;</span><br><span class="line">    return b ? Boolean.TRUE : Boolean.FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，静态工厂方法与设计模式中的工厂方法模式不同[Gamma95]。本条目中描述的静态工厂方法在设计模式中没有直接的等价。</p><p>类可以为其客户端提供静态工厂方法，而不是公共构造方法。提供静态工厂方法而不是公共构造方法有优点也有缺点。</p><p><strong>静态工厂方法的一个优点是，不像构造方法，它们是有名字的。</strong> 如果构造方法的参数本身并不描述被返回的对象，则具有精心选择名称的静态工厂更易于使用，并且生成的客户端代码更易于阅读。 例如，返回一个可能为素数的<code>BigInteger</code>的构造方法<code>BigInteger(int，int，Random)</code>可以更好地表示为名为<code>BigInteger.probablePrime</code>的静态工厂方法。 （这个方法是在Java 1.4中添加的。）</p><p>一个类只能有一个给定签名的构造方法。 程序员知道通过提供两个构造方法来解决这个限制，这两个构造方法的参数列表只有它们的参数类型的顺序不同。 这是一个非常糟糕的主意。 这样的API用户将永远不会记得哪个构造方法是哪个，最终会错误地调用。 阅读使用这些构造方法的代码的人只有在参考类文档的情况下才知道代码的作用。</p><p>因为他们有名字，所以静态工厂方法不会受到上面讨论中的限制。在类中似乎需要具有相同签名的多个构造方法的情况下，用静态工厂方法替换构造方法，并仔细选择名称来突出它们的差异。</p><p><strong>静态工厂方法的第二个优点是，与构造方法不同，它们不需要每次调用时都创建一个新对象。</strong>这允许不可变的类(条目17)使用预先构建的实例，或者在构造时缓存实例，并反复分配它们以避免创建不必要的重复对象。<code>boolean.valueof(boolean)</code>方法说明了这种方法：它从不创建对象。这种技术类似于Flyweight模式[Gamma95]。如果经常请求等价对象，那么它可以极大地提高性能，特别是如果在创建它们非常昂贵的情况下。</p><p>静态工厂方法从重复调用返回相同对象的能力允许类保持在任何时候存在的实例的严格控制。这样做的类被称为实例控制（ instance-controlled）。编写实例控制类的原因有很多。实例控制允许一个类来保证它是一个单例(3)项或不可实例化的(条目4)。同时,它允许一个不可变的值类(条目17)保证不存在两个相同的实例：当且仅当<code>a== b</code>时<code>a.equals(b)</code>。这是享元模式的基础[Gamma95]。<code>Enum</code>类型(条目34)提供了这个保证。</p><p><strong>静态工厂方法的第三个优点是，与构造方法不同，它们可以返回其返回类型的任何子类型的对象。</strong> 这为你在选择返回对象的类时提供了很大的灵活性。</p><p>这种灵活性的一个应用是API可以返回对象而不需要公开它的类。 以这种方式隐藏实现类会使 API非常紧凑I。 这种技术适用于基于接口的框架（条目20），其中接口为静态工厂方法提供自然返回类型。</p><p>在Java 8之前，接口不能有静态方法。根据约定，一个名为<code>Type</code>的接口的静态工厂方法被放入一个非实例化的伙伴类(companion class)(条目4)<code>Types</code>类中。例如，Java集合框架有45个接口的实用工具实现，提供不可修改的集合、同步集合等等。几乎所有这些实现都是通过静态工厂方法在一个非实例类(<code>java .util. collections</code>)中导出的。返回对象的类都是非公开的。</p><p><code>Collections</code>框架API的规模要比它之前输出的45个单独的公共类要小得多，每个类有个便利类的实现。不仅是API的大部分减少了，还包括概念上的权重：程序员必须掌握的概念的数量和难度，才能使用API。程序员知道返回的对象恰好有其接口指定的API，因此不需要为实现类读阅读额外的类文档。此外，使用这种静态工厂方法需要客户端通过接口而不是实现类来引用返回的对象，这通常是良好的实践(条目64)。</p><p>从Java 8开始，接口不能包含静态方法的限制被取消了，所以通常没有理由为接口提供一个不可实例化的伴随类。 很多公开的静态成员应该放在这个接口本身。 但是，请注意，将这些静态方法的大部分实现代码放在单独的包私有类中仍然是必要的。 这是因为Java 8要求所有接口的静态成员都是公共的。 Java 9允许私有静态方法，但静态字段和静态成员类仍然需要公开。</p><p><strong>静态工厂的第四个优点是返回对象的类可以根据输入参数的不同而不同。</strong> 声明的返回类型的任何子类都是允许的。 返回对象的类也可以随每次发布而不同。</p><p><code>EnumSet</code>类（条目 36）没有公共构造方法，只有静态工厂。 在OpenJDK实现中，它们根据底层枚举类型的大小返回两个子类中的一个的实例：如果大多数枚举类型具有64个或更少的元素，静态工厂将返回一个<code>RegularEnumSet</code>实例， 返回一个<code>long</code>类型；如果枚举类型具有六十五个或更多元素，则工厂将返回一个<code>JumboEnumSet</code>实例，返回一个<code>long</code>类型的数组。</p><p>这两个实现类的存在对于客户是不可见的。 如果<code>RegularEnumSet</code>不再为小枚举类型提供性能优势，则可以在未来版本中将其淘汰，而不会产生任何不良影响。 同样，未来的版本可能会添加<code>EnumSet</code>的第三个或第四个实现，如果它证明有利于性能。 客户既不知道也不关心他们从工厂返回的对象的类别; 他们只关心它是<code>EnumSet</code>的一些子类。</p><p><strong>静态工厂的第5个优点是，在编写包含该方法的类时，返回的对象的类不需要存在。</strong>这种灵活的静态工厂方法构成了服务提供者框架的基础，比如Java数据库连接API(JDBC)。服务提供者框架是提供者实现服务的系统，并且系统使得实现对客户端可用，从而将客户端从实现中分离出来。</p><p>服务提供者框架中有三个基本组：服务接口，它表示实现；提供者注册API，提供者用来注册实现；以及服务访问API，客户端使用该API获取服务的实例。服务访问API允许客户指定选择实现的标准。在缺少这样的标准的情况下，API返回一个默认实现的实例，或者允许客户通过所有可用的实现进行遍历。服务访问API是灵活的静态工厂，它构成了服务提供者框架的基础。</p><p>服务提供者框架的一个可选的第四个组件是一个服务提供者接口，它描述了一个生成服务接口实例的工厂对象。在没有服务提供者接口的情况下，必须对实现进行反射实例化(条目65)。在JDBC的情况下，<code>Connection</code>扮演服务接口的一部分，<code>DriverManager.registerDriver</code>提供程序注册API、<code>DriverManager.getConnection</code>是服务访问API，<code>Driver</code>是服务提供者接口。</p><p>服务提供者框架模式有许多变种。 例如，服务访问API可以向客户端返回比提供者提供的更丰富的服务接口。 这是桥接模式[Gamma95]。 依赖注入框架（条目5）可以被看作是强大的服务提供者。 从Java 6开始，平台包含一个通用的服务提供者框架<code>java.util.ServiceLoader</code>，所以你不需要，一般也不应该自己编写（条目59）。 JDBC不使用<code>ServiceLoader</code>，因为前者早于后者。</p><p><strong>只提供静态工厂方法的主要限制是，没有公共或受保护构造方法的类不能被子类化。</strong>例如，在<code>Collections</code>框架中不可能将任何方便实现类子类化。可以说，这可能是因祸得福，因为它鼓励程序员使用组合而不是继承(条目18)，并且是不可变类型(条目17)。</p><p><strong>静态工厂方法的第二个缺点是，程序员很难找到它们。</strong>它们不像构造方法那样在API文档中突出，因此很难找出如何实例化一个提供静态工厂方法而不是构造方法的类。Javadoc工具可能有一天会引起对静态工厂方法的注意。与此同时，可以通过将注意力吸引到类或接口文档中的静态工厂以及遵守通用的命名约定来减少这个问题。下面是一些静态工厂方法的常用名称。以下清单并非完整：</p><ul><li>from——A类型转换方法，它接受单个参数并返回此类型的相应实例，例如：<code>Date d = Date.from(instant)</code>;</li><li>of——一个聚合方法，接受多个参数并返回该类型的实例，并把他们合并在一起，例如：<code>Set&lt;Rank&gt; faceCards = EnumSet.of(JACK, QUEEN, KING)</code>;</li><li>valueOf——from和to更为详细的替代 方式，例如：<code>BigInteger prime = BigInteger.valueOf(Integer.MAX_VALUE)</code>;</li><li>instance或getinstance——返回一个由其参数(如果有的话)描述的实例，但不能说它具有相同的值，例如：<code>StackWalker luke = StackWalker.getInstance(options)</code>;</li><li>create 或 newInstance——与instance 或 getInstance类似，除了该方法保证每个调用返回一个新的实例，例如：<code>Object newArray = Array.newInstance(classObject, arrayLen)</code>;</li><li>getType——与getInstance类似，但是如果在工厂方法中不同的类中使用。Type是工厂方法返回的对象类型，例如：<code>FileStore fs = Files.getFileStore(path)</code>;</li><li>newType——与newInstance类似，但是如果在工厂方法中不同的类中使用。Type是工厂方法返回的对象类型，例如：<code>BufferedReader br = Files.newBufferedReader(path)</code>;</li><li>type—— getType 和 newType简洁的替代方式，例如：<code>List&lt;Complaint&gt; litany = Collections.list(legacyLitany)</code>;</li></ul><p>总之，静态工厂方法和公共构造方法都有它们的用途，并且了解它们的相对优点是值得的。通常，静态工厂更可取，因此避免在没有考虑静态工厂的情况下提供公共构造方法。</p><h2 id="条目2：当构造方法参数过多时使用builder模式"><a href="#条目2：当构造方法参数过多时使用builder模式" class="headerlink" title="条目2：当构造方法参数过多时使用builder模式"></a>条目2：当构造方法参数过多时使用builder模式</h2><p>静态工厂和构造方法都有一个限制：它们不能很好地扩展到很多可选参数的情景。请考虑一个代表包装食品上的营养成分标签的例子。这些标签有几个必需的属性——每次建议的摄入量，每罐的份量和每份卡路里 ，以及超过20个可选的属性——总脂肪、饱和脂肪、反式脂肪、胆固醇、钠等等。大多数产品都有非零值，只有少数几个可选属性。</p><p>应该为这样的类编写什么样的构造方法或静态工厂？传统上，程序员使用了可伸缩（telescoping constructor）构造方法模式，在这种模式中，只提供了一个只所需参数的构造函数，另一个只有一个可选参数，第三个有两个可选参数，等等，最终在构造函数中包含所有可选参数。这就是它在实践中的样子。为了简便起见，只显示了四个可选属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// Telescoping constructor pattern - does not scale well!</span><br><span class="line"></span><br><span class="line">public class NutritionFacts &#123;</span><br><span class="line">    private final int servingSize;  // (mL)            required</span><br><span class="line">    private final int servings;     // (per container) required</span><br><span class="line">    private final int calories;     // (per serving)   optional</span><br><span class="line">    private final int fat;          // (g/serving)     optional</span><br><span class="line">    private final int sodium;       // (mg/serving)    optional</span><br><span class="line">    private final int carbohydrate; // (g/serving)     optional</span><br><span class="line"></span><br><span class="line">    public NutritionFacts(int servingSize, int servings) &#123;</span><br><span class="line">        this(servingSize, servings, 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public NutritionFacts(int servingSize, int servings,</span><br><span class="line">            int calories) &#123;</span><br><span class="line">        this(servingSize, servings, calories, 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public NutritionFacts(int servingSize, int servings,</span><br><span class="line">            int calories, int fat) &#123;</span><br><span class="line">        this(servingSize, servings, calories, fat, 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public NutritionFacts(int servingSize, int servings,</span><br><span class="line">            int calories, int fat, int sodium) &#123;</span><br><span class="line">        this(servingSize, servings, calories, fat, sodium, 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public NutritionFacts(int servingSize, int servings,</span><br><span class="line">           int calories, int fat, int sodium, int carbohydrate) &#123;</span><br><span class="line">        this.servingSize  = servingSize;</span><br><span class="line">        this.servings     = servings;</span><br><span class="line">        this.calories     = calories;</span><br><span class="line">        this.fat          = fat;</span><br><span class="line">        this.sodium       = sodium;</span><br><span class="line">        this.carbohydrate = carbohydrate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当想要创建一个实例时，可以使用包含所有要设置的参数的最短参数列表的构造方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NutritionFacts cocaCola = new NutritionFacts(240, 8, 100, 0, 35, 27);</span><br></pre></td></tr></table></figure><p>通常情况下，这个构造方法的调用需要许多你不想设置的参数，但是你不得不为它们传递一个值。 在这种情况下，我们为<code>fat</code>属性传递了0值。 『只有』六个参数可能看起来并不那么糟糕，但随着参数数量的增加，它会很快失控。</p><p>简而言之，可伸缩构造方法模式是有效的，但是当有很多参数时，很难编写客户端代码，而且很难读懂它。读者不知道这些值是什么意思，并且必须仔细地计算参数才能找到答案。一长串相同类型的参数可能会导致一些细微的bug。如果客户端意外地反转了两个这样的参数，编译器并不会抱怨，但是程序在运行时会出现错误行为(条目51)。</p><p>当在构造方法中遇到许多可选参数时，另一种选择是JavaBeans模式，在这种模式中，调用一个无参数的构造函数来创建对象，然后调用setter方法来设置每个必需的参数和可选参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// JavaBeans Pattern - allows inconsistency, mandates mutability</span><br><span class="line"></span><br><span class="line">public class NutritionFacts &#123;</span><br><span class="line">    // Parameters initialized to default values (if any)</span><br><span class="line">    private int servingSize  = -1; // Required; no default value</span><br><span class="line">    private int servings     = -1; // Required; no default value</span><br><span class="line">    private int calories     = 0;</span><br><span class="line">    private int fat          = 0;</span><br><span class="line">    private int sodium       = 0;</span><br><span class="line">    private int carbohydrate = 0;</span><br><span class="line"></span><br><span class="line">    public NutritionFacts() &#123; &#125;</span><br><span class="line"></span><br><span class="line">    // Setters</span><br><span class="line">    public void setServingSize(int val)  &#123; servingSize = val; &#125;</span><br><span class="line">    public void setServings(int val)    &#123; servings = val; &#125;</span><br><span class="line">    public void setCalories(int val)    &#123; calories = val; &#125;</span><br><span class="line">    public void setFat(int val)         &#123; fat = val; &#125;</span><br><span class="line">    public void setSodium(int val)      &#123; sodium = val; &#125;</span><br><span class="line">    public void setCarbohydrate(int val) &#123; carbohydrate = val; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种模式没有伸缩构造方法模式的缺点。有点冗长，但创建实例很容易，并且易于阅读所生成的代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NutritionFacts cocaCola = new NutritionFacts();</span><br><span class="line">cocaCola.setServingSize(240);</span><br><span class="line">cocaCola.setServings(8);</span><br><span class="line">cocaCola.setCalories(100);</span><br><span class="line">cocaCola.setSodium(35);</span><br><span class="line">cocaCola.setCarbohydrate(27);</span><br></pre></td></tr></table></figure><p>不幸的是，JavaBeans模式本身有严重的缺陷。由于构造方法在多次调用中被分割，所以在构造过程中JavaBean可能处于不一致的状态。该类没有通过检查构造参数参数的有效性来执行一致性的选项。在不一致的状态下尝试使用对象可能会导致与包含bug的代码大相径庭的错误，因此很难调试。一个相关的缺点是，JavaBeans模式排除了让类不可变的可能性(条目17)，并且需要在程序员的部分增加工作以确保线程安全。</p><p>当它的构造完成时，手动“冻结”对象，并且不允许它在解冻之前使用，可以减少这些缺点，但是这种变体在实践中很难使用并且很少使用。 而且，在运行时会导致错误，因为编译器无法确保程序员在使用对象之前调用<code>freeze</code>方法。</p><p>幸运的是，还有第三种选择，它结合了可伸缩构造方法模式的安全性和javabean模式的可读性。 它是Builder模式[Gamma95]的一种形式。客户端不直接调用所需的对象，而是调用构造方法(或静态工厂)，并使用所有必需的参数，并获得一个builder对象。然后，客户端调用builder对象的<code>setter</code>相似方法来设置每个可选参数。最后，客户端调用一个无参的<code>build</code>方法来生成对象，该对象通常是不可变的。Builder通常是它所构建的类的一个静态成员类(条目24)。以下是它在实践中的示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">// Builder Pattern</span><br><span class="line"></span><br><span class="line">public class NutritionFacts &#123;</span><br><span class="line">    private final int servingSize;</span><br><span class="line">    private final int servings;</span><br><span class="line">    private final int calories;</span><br><span class="line">    private final int fat;</span><br><span class="line">    private final int sodium;</span><br><span class="line">    private final int carbohydrate;</span><br><span class="line"></span><br><span class="line">    public static class Builder &#123;</span><br><span class="line">        // Required parameters</span><br><span class="line">        private final int servingSize;</span><br><span class="line">        private final int servings;</span><br><span class="line"></span><br><span class="line">        // Optional parameters - initialized to default values</span><br><span class="line">        private int calories      = 0;</span><br><span class="line">        private int fat           = 0;</span><br><span class="line">        private int sodium        = 0;</span><br><span class="line">        private int carbohydrate  = 0;</span><br><span class="line"></span><br><span class="line">        public Builder(int servingSize, int servings) &#123;</span><br><span class="line">            this.servingSize = servingSize;</span><br><span class="line">            this.servings    = servings;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Builder calories(int val) &#123; </span><br><span class="line">            calories = val;      </span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Builder fat(int val) &#123; </span><br><span class="line">           fat = val;           </span><br><span class="line">           return this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Builder sodium(int val) &#123; </span><br><span class="line">           sodium = val;        </span><br><span class="line">           return this; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Builder carbohydrate(int val) &#123; </span><br><span class="line">           carbohydrate = val;  </span><br><span class="line">           return this; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public NutritionFacts build() &#123;</span><br><span class="line">            return new NutritionFacts(this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private NutritionFacts(Builder builder) &#123;</span><br><span class="line">        servingSize  = builder.servingSize;</span><br><span class="line">        servings     = builder.servings;</span><br><span class="line">        calories     = builder.calories;</span><br><span class="line">        fat          = builder.fat;</span><br><span class="line">        sodium       = builder.sodium;</span><br><span class="line">        carbohydrate = builder.carbohydrate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>NutritionFacts</code>类是不可变的，所有的参数默认值都在一个地方。builder的setter方法返回builder本身，这样调用就可以被链接起来，从而生成一个流畅的API。下面是客户端代码的示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NutritionFacts cocaCola = new NutritionFacts.Builder(240, 8)</span><br><span class="line">    .calories(100).sodium(35).carbohydrate(27).build();</span><br></pre></td></tr></table></figure><p>这个客户端代码很容易编写，更重要的是易于阅读。 Builder模式模拟Python和Scala中的命名可选参数。</p><p>为了简洁起见，省略了有效性检查。 要尽快检测无效参数，检查builder的构造方法和方法中的参数有效性。 在<code>build</code>方法调用的构造方法中检查包含多个参数的不变性。为了确保这些不变性不受攻击，在从builder复制参数后对对象属性进行检查（条目 50）。 如果检查失败，则抛出<code>IllegalArgumentException</code>异常（条目 72），其详细消息指示哪些参数无效（条目 75）。</p><p>Builder模式非常适合类层次结构。 使用平行层次的builder，每个嵌套在相应的类中。 抽象类有抽象的builder; 具体的类有具体的builder。 例如，考虑代表各种比萨饼的根层次结构的抽象类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// Builder pattern for class hierarchies</span><br><span class="line"></span><br><span class="line">import java.util.EnumSet;</span><br><span class="line">import java.util.Objects;</span><br><span class="line">import java.util.Set;</span><br><span class="line"></span><br><span class="line">public abstract class Pizza &#123;</span><br><span class="line">    public enum Topping &#123;HAM, MUSHROOM, ONION, PEPPER, SAUSAGE&#125;</span><br><span class="line">    final Set&lt;Topping&gt; toppings;</span><br><span class="line">    </span><br><span class="line">    abstract static class Builder&lt;T extends Builder&lt;T&gt;&gt; &#123;</span><br><span class="line">        EnumSet&lt;Topping&gt; toppings = EnumSet.noneOf(Topping.class);</span><br><span class="line"></span><br><span class="line">        public T addTopping(Topping topping) &#123;</span><br><span class="line">            toppings.add(Objects.requireNonNull(topping));</span><br><span class="line">            return self();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        abstract Pizza build();</span><br><span class="line">        </span><br><span class="line">        // Subclasses must override this method to return &quot;this&quot;</span><br><span class="line">        protected abstract T self();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Pizza(Builder&lt;?&gt; builder) &#123;</span><br><span class="line">        toppings = builder.toppings.clone(); // See Item 50</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，<code>Pizza.Builder</code>是一个带有递归类型参数（ recursive type parameter）（条目 30）的泛型类型。 这与抽象的<code>self</code>方法一起，允许方法链在子类中正常工作，而不需要强制转换。 Java缺乏自我类型的这种变通解决方法被称为模拟自我类型（simulated self-type）的习惯用法。</p><p>这里有两个具体的<code>Pizza</code>的子类，其中一个代表标准的纽约风格的披萨，另一个是半圆形烤乳酪馅饼。前者有一个所需的尺寸参数，而后者则允许指定酱汁是否应该在里面或在外面：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Objects;</span><br><span class="line"></span><br><span class="line">public class NyPizza extends Pizza &#123;</span><br><span class="line">    public enum Size &#123; SMALL, MEDIUM, LARGE &#125;</span><br><span class="line">    private final Size size;</span><br><span class="line"></span><br><span class="line">    public static class Builder extends Pizza.Builder&lt;Builder&gt; &#123;</span><br><span class="line">        private final Size size;</span><br><span class="line"></span><br><span class="line">        public Builder(Size size) &#123;</span><br><span class="line">            this.size = Objects.requireNonNull(size);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override public NyPizza build() &#123;</span><br><span class="line">            return new NyPizza(this);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override protected Builder self() &#123;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private NyPizza(Builder builder) &#123;</span><br><span class="line">        super(builder);</span><br><span class="line">        size = builder.size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Calzone extends Pizza &#123;</span><br><span class="line">    private final boolean sauceInside;</span><br><span class="line">    </span><br><span class="line">    public static class Builder extends Pizza.Builder&lt;Builder&gt; &#123;</span><br><span class="line">        private boolean sauceInside = false; // Default</span><br><span class="line"></span><br><span class="line">        public Builder sauceInside() &#123;</span><br><span class="line">            sauceInside = true;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        @Override public Calzone build() &#123;</span><br><span class="line">            return new Calzone(this);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        @Override protected Builder self() &#123;</span><br><span class="line">            return this; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private Calzone(Builder builder) &#123;</span><br><span class="line">        super(builder);</span><br><span class="line">        sauceInside = builder.sauceInside;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，每个子类builder中的<code>build</code>方法被声明为返回正确的子类：<code>NyPizza.Builder</code>的<code>build</code>方法返回<code>NyPizza</code>，而<code>Calzone.Builder</code>中的<code>build</code>方法返回<code>Calzone</code>。 这种技术，其一个子类的方法被声明为返回在超类中声明的返回类型的子类型，称为协变返回类型( covariant return typing)。 它允许客户端使用这些builder，而不需要强制转换。</p><p>这些“分层builder”的客户端代码基本上与简单的<code>NutritionFacts</code> builder的代码相同。为了简洁起见,下面显示的示例客户端代码假设枚举常量的静态导入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NyPizza pizza = new NyPizza.Builder(SMALL)</span><br><span class="line">        .addTopping(SAUSAGE).addTopping(ONION).build();</span><br><span class="line">Calzone calzone = new Calzone.Builder()</span><br><span class="line">        .addTopping(HAM).sauceInside().build();</span><br></pre></td></tr></table></figure><p>builder对构造方法的一个微小的优势是，builder可以有多个可变参数，因为每个参数都是在它自己的方法中指定的。或者，builder可以将传递给多个调用的参数聚合到单个属性中，如前面的<code>addTopping</code>方法所演示的那样。</p><p>Builder模式非常灵活。 单个builder可以重复使用来构建多个对象。 builder的参数可以在构建方法的调用之间进行调整，以改变创建的对象。 builder可以在创建对象时自动填充一些属性，例如每次创建对象时增加的序列号。</p><p>Builder模式也有缺点。为了创建对象，首先必须创建它的builder。虽然创建这个builder的成本在实践中不太可能被注意到，但在性能关键的情况下可能会出现问题。而且，builder模式比伸缩构造方法模式更冗长，因此只有在有足够的参数时才值得使用它，比如四个或更多。但是请记住，如果希望在将来添加更多的参数。但是，如果从构造方法或静态工厂开始，并切换到builder，当类演化到参数数量失控的时候，过时的构造方法或静态工厂就会面临尴尬的处境。因此，所以，最好从一开始就创建一个builder。</p><p>总而言之，当设计类的构造方法或静态工厂的参数超过几个时，Builder模式是一个不错的选择，特别是如果许多参数是可选的或相同类型的。客户端代码比使用伸缩构造方法（telescoping constructors）更容易读写，并且builder比JavaBeans更安全。</p><h2 id="3-使用私有构造方法或枚类实现Singleton属性"><a href="#3-使用私有构造方法或枚类实现Singleton属性" class="headerlink" title="3. 使用私有构造方法或枚类实现Singleton属性"></a>3. 使用私有构造方法或枚类实现Singleton属性</h2><p>单例是一个仅实例化一次的类[Gamma95]。单例对象通常表示无状态对象，如函数(条目 24)或一个本质上唯一的系统组件。让一个类成为单例会使测试它的客户变得困难，因为除非实现一个作为它类型的接口，否则不可能用一个模拟实现替代单例。</p><p>有两种常见的方法来实现单例。两者都基于保持构造方法私有和导出公共静态成员以提供对唯一实例的访问。在第一种方法中，成员是<code>final</code>修饰的属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Singleton with public final field</span><br><span class="line">public class Elvis &#123;</span><br><span class="line">    public static final Elvis INSTANCE = new Elvis();</span><br><span class="line">    private Elvis() &#123; ... &#125;</span><br><span class="line">    public void leaveTheBuilding() &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>私有构造方法只调用一次，来初始化公共静态 final <code>Elvis.INSTANCE</code>属性。缺少一个公共的或受保护的构造方法，保证了全局的唯一性：一旦Elvis类被初始化，一个Elvis的实例就会存在——不多也不少。客户端所做的任何事情都不能改变这一点，但需要注意的是：特权客户端可以使用<code>AccessibleObject.setAccessible</code>方法，以反射方式调用私有构造方法(条目 65)。如果需要防御此攻击，请修改构造函数，使其在请求创建第二个实例时抛出异常。</p><p>在第二个实现单例的方法中，公共成员是一个静态的工厂方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// Singleton with static factory</span><br><span class="line">public class Elvis &#123;</span><br><span class="line">    private static final Elvis INSTANCE = new Elvis();</span><br><span class="line">    private Elvis() &#123; ... &#125;</span><br><span class="line">    public static Elvis getInstance() &#123; return INSTANCE; &#125;</span><br><span class="line"></span><br><span class="line">    public void leaveTheBuilding() &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有对<code>Elvis.getInstance</code>的调用都返回相同的对象引用，并且不会创建其他的Elvis实例（与前面提到的警告相同）。</p><p>公共属性方法的主要优点是API明确表示该类是一个单例：公共静态属性是final的，所以它总是包含相同的对象引用。 第二个好处是它更简单。</p><p>静态工厂方法的一个优点是，它可以灵活地改变你的想法，无论该类是否为单例而不必更改其API。 工厂方法返回唯一的实例，但是可以修改，比如，返回调用它的每个线程的单独实例。 第二个好处是，如果你的应用程序需要它，可以编写一个泛型单例工厂（generic singleton factory ）（条目30）。 使用静态工厂的最后一个优点是方法引用可以用<code>supplier</code>，例如<code>Elvis :: instance</code>等同于<code>Supplier&lt;Elvis&gt;</code>。 除非与这些优点相关的，否则公共属性方法是可取的。</p><p>创建一个使用这两种方法的单例类(第12章)，仅仅将<code>implements Serializable</code>添加到声明中是不够的。为了维护单例的保证，声明所有的实例属性为<code>transient</code>，并提供一个<code>readResolve</code>方法(条目89)。否则，每当序列化实例被反序列化时，就会创建一个新的实例，在我们的例子中，导致出现新的Elvis实例。为了防止这种情况发生，将这个<code>readResolve</code>方法添加到Elvis类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// readResolve method to preserve singleton property</span><br><span class="line">private Object readResolve() &#123;</span><br><span class="line">     // Return the one true Elvis and let the garbage collector</span><br><span class="line">     // take care of the Elvis impersonator.</span><br><span class="line">    return INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现一个单例的第三种方法是声明单一元素的枚举类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Enum singleton - the preferred approach</span><br><span class="line">public enum Elvis &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    public void leaveTheBuilding() &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式类似于公共属性方法，但更简洁，提供了免费的序列化机制，并提供了针对多个实例化的坚固保证，即使是在复杂的序列化或反射攻击的情况下。这种方法可能感觉有点不自然，但是<strong>单一元素枚举类通常是实现单例的最佳方式</strong>。注意，如果单例必须继承<code>Enum</code>以外的父类(尽管可以声明一个<code>Enum</code>来实现接口)，那么就不能使用这种方法。</p><h2 id="4-使用私有构造方法执行非实例化"><a href="#4-使用私有构造方法执行非实例化" class="headerlink" title="4. 使用私有构造方法执行非实例化"></a>4. 使用私有构造方法执行非实例化</h2><p>偶尔你会想写一个类，它只是一组静态方法和静态属性。 这样的类获得了不好的名声，因为有些人滥用这些类而避免以面向对象方式思考，但是它们确实有着特殊的用途。 它们可以用来按照<code>java.lang.Math</code>或<code>java.util.Arrays</code>的方式，在基本类型的数值或数组上组织相关的方法。 它们也可以用于将静态方法（包括工厂（条目 1））分组，用于实现某个接口的对象，其方式为<code>java.util.Collections</code>。 （从Java 8开始，你也可以将这些方法放在接口中，假如它是你自己修改的。）最后，这样的类可以用于在final类上对方法进行分组，因为不能将它们放在子类中。</p><p>这样的实用类（ utility classes）不是设计用来被实例化的：一个实例是没有意义的。然而，在没有显式构造方法的情况下，编译器提供了一个公共的、无参的默认构造方法。对于用户来说，该构造方法与其他构造方法没有什么区别。在已发布的 API中经常看到无意识的被实例的类。</p><p><strong>试图通过创建抽象类来强制执行非实例化是行不通的。</strong>该类可以被子类化，子类可以被实例化。此外，它误导用户认为该类是为继承而设计的(条目 19)。不过，有一个简单的方法来确保非实例化。只有当类不包含显式构造方法时，才会生成一个默认构造方法，<strong>因此可以通过包含一个私有构造方法来实现类的非实例化：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// Noninstantiable utility class</span><br><span class="line">public class UtilityClass &#123;</span><br><span class="line">    // Suppress default constructor for noninstantiability</span><br><span class="line">    private UtilityClass() &#123;</span><br><span class="line">        throw new AssertionError();</span><br><span class="line">    &#125;</span><br><span class="line">    ... // Remainder omitted</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为显式构造方法是私有的，所以在类之外是不可访问的。<code>AssertionError</code>异常不是严格要求的，但是它提供了一种保证，以防在类中意外地调用构造方法。它保证类在任何情况下都不会被实例化。这个习惯用法有点违反直觉，好像构造方法就是设计成不能调用的一样。因此，如前面所示，添加注释是种明智的做法。</p><p>这种习惯有一个副作用，阻止了类的子类化。所有的构造方法都必须显式或隐式地调用父类构造方法，而子类则没有可访问的父类构造方法来调用。</p><h2 id="5-使用依赖注入取代硬连接资源（hardwiring-resources）"><a href="#5-使用依赖注入取代硬连接资源（hardwiring-resources）" class="headerlink" title="5. 使用依赖注入取代硬连接资源（hardwiring resources）"></a>5. 使用依赖注入取代硬连接资源（hardwiring resources）</h2><p>许多类依赖于一个或多个底层资源。例如，拼写检查器依赖于字典。将此类类实现为静态实用工具类并不少见(条目 4):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// Inappropriate use of static utility - inflexible &amp; untestable!</span><br><span class="line">public class SpellChecker &#123;</span><br><span class="line">    private static final Lexicon dictionary = ...;</span><br><span class="line"></span><br><span class="line">    private SpellChecker() &#123;&#125; // Noninstantiable</span><br><span class="line"></span><br><span class="line">    public static boolean isValid(String word) &#123; ... &#125;</span><br><span class="line">    public static List&lt;String&gt; suggestions(String typo) &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样地，将它们实现为单例也并不少见(条目 3)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// Inappropriate use of singleton - inflexible &amp; untestable!</span><br><span class="line">public class SpellChecker &#123;</span><br><span class="line">    private final Lexicon dictionary = ...;</span><br><span class="line"></span><br><span class="line">    private SpellChecker(...) &#123;&#125;</span><br><span class="line">    public static INSTANCE = new SpellChecker(...);</span><br><span class="line"></span><br><span class="line">    public boolean isValid(String word) &#123; ... &#125;</span><br><span class="line">    public List&lt;String&gt; suggestions(String typo) &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两种方法都不令人满意，因为他们假设只有一本字典值得使用。在实际中，每种语言都有自己的字典，特殊的字典被用于特殊的词汇表。另外，使用专门的字典来进行测试也是可取的。想当然地认为一本字典就足够了，这是一厢情愿的想法。</p><p>可以通过使<code>dictionary</code>属性设置为非<code>final</code>，并添加一个方法来更改现有拼写检查器中的字典，从而让拼写检查器支持多个字典，但是在并发环境中，这是笨拙的、容易出错的和不可行的。<strong>静态实用类和单例对于那些行为被底层资源参数化的类来说是不合适的</strong>。</p><p>所需要的是能够支持类的多个实例(在我们的示例中，即<code>SpellChecker</code>)，每个实例都使用客户端所期望的资源(在我们的例子中是<code>dictionary</code>)。满足这一需求的简单模式是在创建新实例时将资源传递到构造方法中。这是依赖项注入（dependency injection）的一种形式：字典是拼写检查器的一个依赖项，当它创建时被注入到拼写检查器中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// Dependency injection provides flexibility and testability</span><br><span class="line">public class SpellChecker &#123;</span><br><span class="line">    private final Lexicon dictionary;</span><br><span class="line"></span><br><span class="line">    public SpellChecker(Lexicon dictionary) &#123;</span><br><span class="line">        this.dictionary = Objects.requireNonNull(dictionary);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isValid(String word) &#123; ... &#125;</span><br><span class="line">    public List&lt;String&gt; suggestions(String typo) &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>依赖注入模式非常简单，许多程序员使用它多年而不知道它有一个名字。 虽然我们的拼写检查器的例子只有一个资源（字典），但是依赖项注入可以使用任意数量的资源和任意依赖图。 它保持了不变性（条目 17），因此多个客户端可以共享依赖对象（假设客户需要相同的底层资源）。 依赖注入同样适用于构造方法，静态工厂（条目 1）和 builder模式（条目 2）。</p><p>该模式的一个有用的变体是将资源工厂传递给构造方法。 工厂是可以重复调用以创建类型实例的对象。 这种工厂体现了工厂方法模式（Factory Method pattern ）[Gamma95]。 Java 8中引入的<code>Supplier &lt;T&gt;</code>接口非常适合代表工厂。 在输入上采用<code>Supplier&lt;T&gt;</code>的方法通常应该使用有界的通配符类型( bounded wildcard type)（条目 31）约束工厂的类型参数，以允许客户端传入工厂，创建指定类型的任何子类型。 例如，下面是一个使用客户端提供的工厂生成tile的方法：<br><code>Mosaic create(Supplier&lt;? extends Tile&gt; tileFactory) { ... }</code></p><p>尽管依赖注入极大地提高了灵活性和可测试性，但它可能使大型项目变得混乱，这些项目通常包含数千个依赖项。使用依赖注入框架(如Dagger[Dagger]、Guice[Guice]或Spring[Spring])可以消除这些混乱。这些框架的使用超出了本书的范围，但是请注意，为手动依赖注入而设计的API非常适合这些框架的使用。</p><p>总之，不要使用单例或静态的实用类来实现一个类，该类依赖于一个或多个底层资源，这些资源的行为会影响类的行为，并且不让类直接创建这些资源。相反，将资源或工厂传递给构造方法(或静态工厂或builder模式)。这种称为依赖注入的实践将极大地增强类的灵活性、可重用性和可测试性。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;条目1-考虑使用静态工厂方法替代构造方法&quot;&gt;&lt;a href=&quot;#条目1-考虑使用静态工厂方法替代构造方法&quot; class=&quot;headerlink&quot; title=&quot;条目1. 考虑使用静态工厂方法替代构造方法&quot;&gt;&lt;/a&gt;条目1. 考虑使用静态工厂方法替代构造方法&lt;/h2
      
    
    </summary>
    
      <category term="java" scheme="http://luxiangdong.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>Effective Java 中文版(item:1-37)</title>
    <link href="http://luxiangdong.com/2018/05/09/effective-java-cn-01/"/>
    <id>http://luxiangdong.com/2018/05/09/effective-java-cn-01/</id>
    <published>2018-05-09T01:19:16.000Z</published>
    <updated>2018-05-09T01:22:27.192Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Effective-Java-3rd"><a href="#Effective-Java-3rd" class="headerlink" title="Effective Java 3rd"></a>Effective Java 3rd</h1><p>[TOC]</p><h2 id="条目1-考虑使用静态工厂方法替代构造方法"><a href="#条目1-考虑使用静态工厂方法替代构造方法" class="headerlink" title="条目1. 考虑使用静态工厂方法替代构造方法"></a>条目1. 考虑使用静态工厂方法替代构造方法</h2><p>一个类允许客户端获取其实例的传统方式是提供一个公共构造方法。 其实还有另一种技术应该成为每个程序员工具箱的一部分。 一个类可以提供一个公共静态工厂方法，它只是一个返回类实例的静态方法。 下面是一个<code>Boolean</code>简单的例子（<code>boolean</code>基本类型的包装类）。 此方法将<code>boolean</code>基本类型转换为<code>Boolean</code>对象引用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static Boolean valueOf(boolean b) &#123;</span><br><span class="line">    return b ? Boolean.TRUE : Boolean.FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，静态工厂方法与设计模式中的工厂方法模式不同[Gamma95]。本条目中描述的静态工厂方法在设计模式中没有直接的等价。</p><p>类可以为其客户端提供静态工厂方法，而不是公共构造方法。提供静态工厂方法而不是公共构造方法有优点也有缺点。</p><p><strong>静态工厂方法的一个优点是，不像构造方法，它们是有名字的。</strong> 如果构造方法的参数本身并不描述被返回的对象，则具有精心选择名称的静态工厂更易于使用，并且生成的客户端代码更易于阅读。 例如，返回一个可能为素数的<code>BigInteger</code>的构造方法<code>BigInteger(int，int，Random)</code>可以更好地表示为名为<code>BigInteger.probablePrime</code>的静态工厂方法。 （这个方法是在Java 1.4中添加的。）</p><p>一个类只能有一个给定签名的构造方法。 程序员知道通过提供两个构造方法来解决这个限制，这两个构造方法的参数列表只有它们的参数类型的顺序不同。 这是一个非常糟糕的主意。 这样的API用户将永远不会记得哪个构造方法是哪个，最终会错误地调用。 阅读使用这些构造方法的代码的人只有在参考类文档的情况下才知道代码的作用。</p><p>因为他们有名字，所以静态工厂方法不会受到上面讨论中的限制。在类中似乎需要具有相同签名的多个构造方法的情况下，用静态工厂方法替换构造方法，并仔细选择名称来突出它们的差异。</p><p><strong>静态工厂方法的第二个优点是，与构造方法不同，它们不需要每次调用时都创建一个新对象。</strong>这允许不可变的类(条目17)使用预先构建的实例，或者在构造时缓存实例，并反复分配它们以避免创建不必要的重复对象。<code>boolean.valueof(boolean)</code>方法说明了这种方法：它从不创建对象。这种技术类似于Flyweight模式[Gamma95]。如果经常请求等价对象，那么它可以极大地提高性能，特别是如果在创建它们非常昂贵的情况下。</p><p>静态工厂方法从重复调用返回相同对象的能力允许类保持在任何时候存在的实例的严格控制。这样做的类被称为实例控制（ instance-controlled）。编写实例控制类的原因有很多。实例控制允许一个类来保证它是一个单例(3)项或不可实例化的(条目4)。同时,它允许一个不可变的值类(条目17)保证不存在两个相同的实例：当且仅当<code>a== b</code>时<code>a.equals(b)</code>。这是享元模式的基础[Gamma95]。<code>Enum</code>类型(条目34)提供了这个保证。</p><p><strong>静态工厂方法的第三个优点是，与构造方法不同，它们可以返回其返回类型的任何子类型的对象。</strong> 这为你在选择返回对象的类时提供了很大的灵活性。</p><p>这种灵活性的一个应用是API可以返回对象而不需要公开它的类。 以这种方式隐藏实现类会使 API非常紧凑I。 这种技术适用于基于接口的框架（条目20），其中接口为静态工厂方法提供自然返回类型。</p><p>在Java 8之前，接口不能有静态方法。根据约定，一个名为<code>Type</code>的接口的静态工厂方法被放入一个非实例化的伙伴类(companion class)(条目4)<code>Types</code>类中。例如，Java集合框架有45个接口的实用工具实现，提供不可修改的集合、同步集合等等。几乎所有这些实现都是通过静态工厂方法在一个非实例类(<code>java .util. collections</code>)中导出的。返回对象的类都是非公开的。</p><p><code>Collections</code>框架API的规模要比它之前输出的45个单独的公共类要小得多，每个类有个便利类的实现。不仅是API的大部分减少了，还包括概念上的权重：程序员必须掌握的概念的数量和难度，才能使用API。程序员知道返回的对象恰好有其接口指定的API，因此不需要为实现类读阅读额外的类文档。此外，使用这种静态工厂方法需要客户端通过接口而不是实现类来引用返回的对象，这通常是良好的实践(条目64)。</p><p>从Java 8开始，接口不能包含静态方法的限制被取消了，所以通常没有理由为接口提供一个不可实例化的伴随类。 很多公开的静态成员应该放在这个接口本身。 但是，请注意，将这些静态方法的大部分实现代码放在单独的包私有类中仍然是必要的。 这是因为Java 8要求所有接口的静态成员都是公共的。 Java 9允许私有静态方法，但静态字段和静态成员类仍然需要公开。</p><p><strong>静态工厂的第四个优点是返回对象的类可以根据输入参数的不同而不同。</strong> 声明的返回类型的任何子类都是允许的。 返回对象的类也可以随每次发布而不同。</p><p><code>EnumSet</code>类（条目 36）没有公共构造方法，只有静态工厂。 在OpenJDK实现中，它们根据底层枚举类型的大小返回两个子类中的一个的实例：如果大多数枚举类型具有64个或更少的元素，静态工厂将返回一个<code>RegularEnumSet</code>实例， 返回一个<code>long</code>类型；如果枚举类型具有六十五个或更多元素，则工厂将返回一个<code>JumboEnumSet</code>实例，返回一个<code>long</code>类型的数组。</p><p>这两个实现类的存在对于客户是不可见的。 如果<code>RegularEnumSet</code>不再为小枚举类型提供性能优势，则可以在未来版本中将其淘汰，而不会产生任何不良影响。 同样，未来的版本可能会添加<code>EnumSet</code>的第三个或第四个实现，如果它证明有利于性能。 客户既不知道也不关心他们从工厂返回的对象的类别; 他们只关心它是<code>EnumSet</code>的一些子类。</p><p><strong>静态工厂的第5个优点是，在编写包含该方法的类时，返回的对象的类不需要存在。</strong>这种灵活的静态工厂方法构成了服务提供者框架的基础，比如Java数据库连接API(JDBC)。服务提供者框架是提供者实现服务的系统，并且系统使得实现对客户端可用，从而将客户端从实现中分离出来。</p><p>服务提供者框架中有三个基本组：服务接口，它表示实现；提供者注册API，提供者用来注册实现；以及服务访问API，客户端使用该API获取服务的实例。服务访问API允许客户指定选择实现的标准。在缺少这样的标准的情况下，API返回一个默认实现的实例，或者允许客户通过所有可用的实现进行遍历。服务访问API是灵活的静态工厂，它构成了服务提供者框架的基础。</p><p>服务提供者框架的一个可选的第四个组件是一个服务提供者接口，它描述了一个生成服务接口实例的工厂对象。在没有服务提供者接口的情况下，必须对实现进行反射实例化(条目65)。在JDBC的情况下，<code>Connection</code>扮演服务接口的一部分，<code>DriverManager.registerDriver</code>提供程序注册API、<code>DriverManager.getConnection</code>是服务访问API，<code>Driver</code>是服务提供者接口。</p><p>服务提供者框架模式有许多变种。 例如，服务访问API可以向客户端返回比提供者提供的更丰富的服务接口。 这是桥接模式[Gamma95]。 依赖注入框架（条目5）可以被看作是强大的服务提供者。 从Java 6开始，平台包含一个通用的服务提供者框架<code>java.util.ServiceLoader</code>，所以你不需要，一般也不应该自己编写（条目59）。 JDBC不使用<code>ServiceLoader</code>，因为前者早于后者。</p><p><strong>只提供静态工厂方法的主要限制是，没有公共或受保护构造方法的类不能被子类化。</strong>例如，在<code>Collections</code>框架中不可能将任何方便实现类子类化。可以说，这可能是因祸得福，因为它鼓励程序员使用组合而不是继承(条目18)，并且是不可变类型(条目17)。</p><p><strong>静态工厂方法的第二个缺点是，程序员很难找到它们。</strong>它们不像构造方法那样在API文档中突出，因此很难找出如何实例化一个提供静态工厂方法而不是构造方法的类。Javadoc工具可能有一天会引起对静态工厂方法的注意。与此同时，可以通过将注意力吸引到类或接口文档中的静态工厂以及遵守通用的命名约定来减少这个问题。下面是一些静态工厂方法的常用名称。以下清单并非完整：</p><ul><li>from——A类型转换方法，它接受单个参数并返回此类型的相应实例，例如：<code>Date d = Date.from(instant)</code>;</li><li>of——一个聚合方法，接受多个参数并返回该类型的实例，并把他们合并在一起，例如：<code>Set&lt;Rank&gt; faceCards = EnumSet.of(JACK, QUEEN, KING)</code>;</li><li>valueOf——from和to更为详细的替代 方式，例如：<code>BigInteger prime = BigInteger.valueOf(Integer.MAX_VALUE)</code>;</li><li>instance或getinstance——返回一个由其参数(如果有的话)描述的实例，但不能说它具有相同的值，例如：<code>StackWalker luke = StackWalker.getInstance(options)</code>;</li><li>create 或 newInstance——与instance 或 getInstance类似，除了该方法保证每个调用返回一个新的实例，例如：<code>Object newArray = Array.newInstance(classObject, arrayLen)</code>;</li><li>getType——与getInstance类似，但是如果在工厂方法中不同的类中使用。Type是工厂方法返回的对象类型，例如：<code>FileStore fs = Files.getFileStore(path)</code>;</li><li>newType——与newInstance类似，但是如果在工厂方法中不同的类中使用。Type是工厂方法返回的对象类型，例如：<code>BufferedReader br = Files.newBufferedReader(path)</code>;</li><li>type—— getType 和 newType简洁的替代方式，例如：<code>List&lt;Complaint&gt; litany = Collections.list(legacyLitany)</code>;</li></ul><p>总之，静态工厂方法和公共构造方法都有它们的用途，并且了解它们的相对优点是值得的。通常，静态工厂更可取，因此避免在没有考虑静态工厂的情况下提供公共构造方法。</p><h2 id="条目2：当构造方法参数过多时使用builder模式"><a href="#条目2：当构造方法参数过多时使用builder模式" class="headerlink" title="条目2：当构造方法参数过多时使用builder模式"></a>条目2：当构造方法参数过多时使用builder模式</h2><p>静态工厂和构造方法都有一个限制：它们不能很好地扩展到很多可选参数的情景。请考虑一个代表包装食品上的营养成分标签的例子。这些标签有几个必需的属性——每次建议的摄入量，每罐的份量和每份卡路里 ，以及超过20个可选的属性——总脂肪、饱和脂肪、反式脂肪、胆固醇、钠等等。大多数产品都有非零值，只有少数几个可选属性。</p><p>应该为这样的类编写什么样的构造方法或静态工厂？传统上，程序员使用了可伸缩（telescoping constructor）构造方法模式，在这种模式中，只提供了一个只所需参数的构造函数，另一个只有一个可选参数，第三个有两个可选参数，等等，最终在构造函数中包含所有可选参数。这就是它在实践中的样子。为了简便起见，只显示了四个可选属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// Telescoping constructor pattern - does not scale well!</span><br><span class="line"></span><br><span class="line">public class NutritionFacts &#123;</span><br><span class="line">    private final int servingSize;  // (mL)            required</span><br><span class="line">    private final int servings;     // (per container) required</span><br><span class="line">    private final int calories;     // (per serving)   optional</span><br><span class="line">    private final int fat;          // (g/serving)     optional</span><br><span class="line">    private final int sodium;       // (mg/serving)    optional</span><br><span class="line">    private final int carbohydrate; // (g/serving)     optional</span><br><span class="line"></span><br><span class="line">    public NutritionFacts(int servingSize, int servings) &#123;</span><br><span class="line">        this(servingSize, servings, 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public NutritionFacts(int servingSize, int servings,</span><br><span class="line">            int calories) &#123;</span><br><span class="line">        this(servingSize, servings, calories, 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public NutritionFacts(int servingSize, int servings,</span><br><span class="line">            int calories, int fat) &#123;</span><br><span class="line">        this(servingSize, servings, calories, fat, 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public NutritionFacts(int servingSize, int servings,</span><br><span class="line">            int calories, int fat, int sodium) &#123;</span><br><span class="line">        this(servingSize, servings, calories, fat, sodium, 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public NutritionFacts(int servingSize, int servings,</span><br><span class="line">           int calories, int fat, int sodium, int carbohydrate) &#123;</span><br><span class="line">        this.servingSize  = servingSize;</span><br><span class="line">        this.servings     = servings;</span><br><span class="line">        this.calories     = calories;</span><br><span class="line">        this.fat          = fat;</span><br><span class="line">        this.sodium       = sodium;</span><br><span class="line">        this.carbohydrate = carbohydrate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当想要创建一个实例时，可以使用包含所有要设置的参数的最短参数列表的构造方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NutritionFacts cocaCola = new NutritionFacts(240, 8, 100, 0, 35, 27);</span><br></pre></td></tr></table></figure><p>通常情况下，这个构造方法的调用需要许多你不想设置的参数，但是你不得不为它们传递一个值。 在这种情况下，我们为<code>fat</code>属性传递了0值。 『只有』六个参数可能看起来并不那么糟糕，但随着参数数量的增加，它会很快失控。</p><p>简而言之，可伸缩构造方法模式是有效的，但是当有很多参数时，很难编写客户端代码，而且很难读懂它。读者不知道这些值是什么意思，并且必须仔细地计算参数才能找到答案。一长串相同类型的参数可能会导致一些细微的bug。如果客户端意外地反转了两个这样的参数，编译器并不会抱怨，但是程序在运行时会出现错误行为(条目51)。</p><p>当在构造方法中遇到许多可选参数时，另一种选择是JavaBeans模式，在这种模式中，调用一个无参数的构造函数来创建对象，然后调用setter方法来设置每个必需的参数和可选参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// JavaBeans Pattern - allows inconsistency, mandates mutability</span><br><span class="line"></span><br><span class="line">public class NutritionFacts &#123;</span><br><span class="line">    // Parameters initialized to default values (if any)</span><br><span class="line">    private int servingSize  = -1; // Required; no default value</span><br><span class="line">    private int servings     = -1; // Required; no default value</span><br><span class="line">    private int calories     = 0;</span><br><span class="line">    private int fat          = 0;</span><br><span class="line">    private int sodium       = 0;</span><br><span class="line">    private int carbohydrate = 0;</span><br><span class="line"></span><br><span class="line">    public NutritionFacts() &#123; &#125;</span><br><span class="line"></span><br><span class="line">    // Setters</span><br><span class="line">    public void setServingSize(int val)  &#123; servingSize = val; &#125;</span><br><span class="line">    public void setServings(int val)    &#123; servings = val; &#125;</span><br><span class="line">    public void setCalories(int val)    &#123; calories = val; &#125;</span><br><span class="line">    public void setFat(int val)         &#123; fat = val; &#125;</span><br><span class="line">    public void setSodium(int val)      &#123; sodium = val; &#125;</span><br><span class="line">    public void setCarbohydrate(int val) &#123; carbohydrate = val; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种模式没有伸缩构造方法模式的缺点。有点冗长，但创建实例很容易，并且易于阅读所生成的代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NutritionFacts cocaCola = new NutritionFacts();</span><br><span class="line">cocaCola.setServingSize(240);</span><br><span class="line">cocaCola.setServings(8);</span><br><span class="line">cocaCola.setCalories(100);</span><br><span class="line">cocaCola.setSodium(35);</span><br><span class="line">cocaCola.setCarbohydrate(27);</span><br></pre></td></tr></table></figure><p>不幸的是，JavaBeans模式本身有严重的缺陷。由于构造方法在多次调用中被分割，所以在构造过程中JavaBean可能处于不一致的状态。该类没有通过检查构造参数参数的有效性来执行一致性的选项。在不一致的状态下尝试使用对象可能会导致与包含bug的代码大相径庭的错误，因此很难调试。一个相关的缺点是，JavaBeans模式排除了让类不可变的可能性(条目17)，并且需要在程序员的部分增加工作以确保线程安全。</p><p>当它的构造完成时，手动“冻结”对象，并且不允许它在解冻之前使用，可以减少这些缺点，但是这种变体在实践中很难使用并且很少使用。 而且，在运行时会导致错误，因为编译器无法确保程序员在使用对象之前调用<code>freeze</code>方法。</p><p>幸运的是，还有第三种选择，它结合了可伸缩构造方法模式的安全性和javabean模式的可读性。 它是Builder模式[Gamma95]的一种形式。客户端不直接调用所需的对象，而是调用构造方法(或静态工厂)，并使用所有必需的参数，并获得一个builder对象。然后，客户端调用builder对象的<code>setter</code>相似方法来设置每个可选参数。最后，客户端调用一个无参的<code>build</code>方法来生成对象，该对象通常是不可变的。Builder通常是它所构建的类的一个静态成员类(条目24)。以下是它在实践中的示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">// Builder Pattern</span><br><span class="line"></span><br><span class="line">public class NutritionFacts &#123;</span><br><span class="line">    private final int servingSize;</span><br><span class="line">    private final int servings;</span><br><span class="line">    private final int calories;</span><br><span class="line">    private final int fat;</span><br><span class="line">    private final int sodium;</span><br><span class="line">    private final int carbohydrate;</span><br><span class="line"></span><br><span class="line">    public static class Builder &#123;</span><br><span class="line">        // Required parameters</span><br><span class="line">        private final int servingSize;</span><br><span class="line">        private final int servings;</span><br><span class="line"></span><br><span class="line">        // Optional parameters - initialized to default values</span><br><span class="line">        private int calories      = 0;</span><br><span class="line">        private int fat           = 0;</span><br><span class="line">        private int sodium        = 0;</span><br><span class="line">        private int carbohydrate  = 0;</span><br><span class="line"></span><br><span class="line">        public Builder(int servingSize, int servings) &#123;</span><br><span class="line">            this.servingSize = servingSize;</span><br><span class="line">            this.servings    = servings;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Builder calories(int val) &#123; </span><br><span class="line">            calories = val;      </span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Builder fat(int val) &#123; </span><br><span class="line">           fat = val;           </span><br><span class="line">           return this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Builder sodium(int val) &#123; </span><br><span class="line">           sodium = val;        </span><br><span class="line">           return this; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Builder carbohydrate(int val) &#123; </span><br><span class="line">           carbohydrate = val;  </span><br><span class="line">           return this; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public NutritionFacts build() &#123;</span><br><span class="line">            return new NutritionFacts(this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private NutritionFacts(Builder builder) &#123;</span><br><span class="line">        servingSize  = builder.servingSize;</span><br><span class="line">        servings     = builder.servings;</span><br><span class="line">        calories     = builder.calories;</span><br><span class="line">        fat          = builder.fat;</span><br><span class="line">        sodium       = builder.sodium;</span><br><span class="line">        carbohydrate = builder.carbohydrate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>NutritionFacts</code>类是不可变的，所有的参数默认值都在一个地方。builder的setter方法返回builder本身，这样调用就可以被链接起来，从而生成一个流畅的API。下面是客户端代码的示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NutritionFacts cocaCola = new NutritionFacts.Builder(240, 8)</span><br><span class="line">    .calories(100).sodium(35).carbohydrate(27).build();</span><br></pre></td></tr></table></figure><p>这个客户端代码很容易编写，更重要的是易于阅读。 Builder模式模拟Python和Scala中的命名可选参数。</p><p>为了简洁起见，省略了有效性检查。 要尽快检测无效参数，检查builder的构造方法和方法中的参数有效性。 在<code>build</code>方法调用的构造方法中检查包含多个参数的不变性。为了确保这些不变性不受攻击，在从builder复制参数后对对象属性进行检查（条目 50）。 如果检查失败，则抛出<code>IllegalArgumentException</code>异常（条目 72），其详细消息指示哪些参数无效（条目 75）。</p><p>Builder模式非常适合类层次结构。 使用平行层次的builder，每个嵌套在相应的类中。 抽象类有抽象的builder; 具体的类有具体的builder。 例如，考虑代表各种比萨饼的根层次结构的抽象类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// Builder pattern for class hierarchies</span><br><span class="line"></span><br><span class="line">import java.util.EnumSet;</span><br><span class="line">import java.util.Objects;</span><br><span class="line">import java.util.Set;</span><br><span class="line"></span><br><span class="line">public abstract class Pizza &#123;</span><br><span class="line">    public enum Topping &#123;HAM, MUSHROOM, ONION, PEPPER, SAUSAGE&#125;</span><br><span class="line">    final Set&lt;Topping&gt; toppings;</span><br><span class="line">    </span><br><span class="line">    abstract static class Builder&lt;T extends Builder&lt;T&gt;&gt; &#123;</span><br><span class="line">        EnumSet&lt;Topping&gt; toppings = EnumSet.noneOf(Topping.class);</span><br><span class="line"></span><br><span class="line">        public T addTopping(Topping topping) &#123;</span><br><span class="line">            toppings.add(Objects.requireNonNull(topping));</span><br><span class="line">            return self();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        abstract Pizza build();</span><br><span class="line">        </span><br><span class="line">        // Subclasses must override this method to return &quot;this&quot;</span><br><span class="line">        protected abstract T self();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Pizza(Builder&lt;?&gt; builder) &#123;</span><br><span class="line">        toppings = builder.toppings.clone(); // See Item 50</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，<code>Pizza.Builder</code>是一个带有递归类型参数（ recursive type parameter）（条目 30）的泛型类型。 这与抽象的<code>self</code>方法一起，允许方法链在子类中正常工作，而不需要强制转换。 Java缺乏自我类型的这种变通解决方法被称为模拟自我类型（simulated self-type）的习惯用法。</p><p>这里有两个具体的<code>Pizza</code>的子类，其中一个代表标准的纽约风格的披萨，另一个是半圆形烤乳酪馅饼。前者有一个所需的尺寸参数，而后者则允许指定酱汁是否应该在里面或在外面：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Objects;</span><br><span class="line"></span><br><span class="line">public class NyPizza extends Pizza &#123;</span><br><span class="line">    public enum Size &#123; SMALL, MEDIUM, LARGE &#125;</span><br><span class="line">    private final Size size;</span><br><span class="line"></span><br><span class="line">    public static class Builder extends Pizza.Builder&lt;Builder&gt; &#123;</span><br><span class="line">        private final Size size;</span><br><span class="line"></span><br><span class="line">        public Builder(Size size) &#123;</span><br><span class="line">            this.size = Objects.requireNonNull(size);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override public NyPizza build() &#123;</span><br><span class="line">            return new NyPizza(this);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override protected Builder self() &#123;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private NyPizza(Builder builder) &#123;</span><br><span class="line">        super(builder);</span><br><span class="line">        size = builder.size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Calzone extends Pizza &#123;</span><br><span class="line">    private final boolean sauceInside;</span><br><span class="line">    </span><br><span class="line">    public static class Builder extends Pizza.Builder&lt;Builder&gt; &#123;</span><br><span class="line">        private boolean sauceInside = false; // Default</span><br><span class="line"></span><br><span class="line">        public Builder sauceInside() &#123;</span><br><span class="line">            sauceInside = true;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        @Override public Calzone build() &#123;</span><br><span class="line">            return new Calzone(this);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        @Override protected Builder self() &#123;</span><br><span class="line">            return this; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private Calzone(Builder builder) &#123;</span><br><span class="line">        super(builder);</span><br><span class="line">        sauceInside = builder.sauceInside;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，每个子类builder中的<code>build</code>方法被声明为返回正确的子类：<code>NyPizza.Builder</code>的<code>build</code>方法返回<code>NyPizza</code>，而<code>Calzone.Builder</code>中的<code>build</code>方法返回<code>Calzone</code>。 这种技术，其一个子类的方法被声明为返回在超类中声明的返回类型的子类型，称为协变返回类型( covariant return typing)。 它允许客户端使用这些builder，而不需要强制转换。</p><p>这些“分层builder”的客户端代码基本上与简单的<code>NutritionFacts</code> builder的代码相同。为了简洁起见,下面显示的示例客户端代码假设枚举常量的静态导入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NyPizza pizza = new NyPizza.Builder(SMALL)</span><br><span class="line">        .addTopping(SAUSAGE).addTopping(ONION).build();</span><br><span class="line">Calzone calzone = new Calzone.Builder()</span><br><span class="line">        .addTopping(HAM).sauceInside().build();</span><br></pre></td></tr></table></figure><p>builder对构造方法的一个微小的优势是，builder可以有多个可变参数，因为每个参数都是在它自己的方法中指定的。或者，builder可以将传递给多个调用的参数聚合到单个属性中，如前面的<code>addTopping</code>方法所演示的那样。</p><p>Builder模式非常灵活。 单个builder可以重复使用来构建多个对象。 builder的参数可以在构建方法的调用之间进行调整，以改变创建的对象。 builder可以在创建对象时自动填充一些属性，例如每次创建对象时增加的序列号。</p><p>Builder模式也有缺点。为了创建对象，首先必须创建它的builder。虽然创建这个builder的成本在实践中不太可能被注意到，但在性能关键的情况下可能会出现问题。而且，builder模式比伸缩构造方法模式更冗长，因此只有在有足够的参数时才值得使用它，比如四个或更多。但是请记住，如果希望在将来添加更多的参数。但是，如果从构造方法或静态工厂开始，并切换到builder，当类演化到参数数量失控的时候，过时的构造方法或静态工厂就会面临尴尬的处境。因此，所以，最好从一开始就创建一个builder。</p><p>总而言之，当设计类的构造方法或静态工厂的参数超过几个时，Builder模式是一个不错的选择，特别是如果许多参数是可选的或相同类型的。客户端代码比使用伸缩构造方法（telescoping constructors）更容易读写，并且builder比JavaBeans更安全。</p><h2 id="3-使用私有构造方法或枚类实现Singleton属性"><a href="#3-使用私有构造方法或枚类实现Singleton属性" class="headerlink" title="3. 使用私有构造方法或枚类实现Singleton属性"></a>3. 使用私有构造方法或枚类实现Singleton属性</h2><p>单例是一个仅实例化一次的类[Gamma95]。单例对象通常表示无状态对象，如函数(条目 24)或一个本质上唯一的系统组件。让一个类成为单例会使测试它的客户变得困难，因为除非实现一个作为它类型的接口，否则不可能用一个模拟实现替代单例。</p><p>有两种常见的方法来实现单例。两者都基于保持构造方法私有和导出公共静态成员以提供对唯一实例的访问。在第一种方法中，成员是<code>final</code>修饰的属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Singleton with public final field</span><br><span class="line">public class Elvis &#123;</span><br><span class="line">    public static final Elvis INSTANCE = new Elvis();</span><br><span class="line">    private Elvis() &#123; ... &#125;</span><br><span class="line">    public void leaveTheBuilding() &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>私有构造方法只调用一次，来初始化公共静态 final <code>Elvis.INSTANCE</code>属性。缺少一个公共的或受保护的构造方法，保证了全局的唯一性：一旦Elvis类被初始化，一个Elvis的实例就会存在——不多也不少。客户端所做的任何事情都不能改变这一点，但需要注意的是：特权客户端可以使用<code>AccessibleObject.setAccessible</code>方法，以反射方式调用私有构造方法(条目 65)。如果需要防御此攻击，请修改构造函数，使其在请求创建第二个实例时抛出异常。</p><p>在第二个实现单例的方法中，公共成员是一个静态的工厂方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// Singleton with static factory</span><br><span class="line">public class Elvis &#123;</span><br><span class="line">    private static final Elvis INSTANCE = new Elvis();</span><br><span class="line">    private Elvis() &#123; ... &#125;</span><br><span class="line">    public static Elvis getInstance() &#123; return INSTANCE; &#125;</span><br><span class="line"></span><br><span class="line">    public void leaveTheBuilding() &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有对<code>Elvis.getInstance</code>的调用都返回相同的对象引用，并且不会创建其他的Elvis实例（与前面提到的警告相同）。</p><p>公共属性方法的主要优点是API明确表示该类是一个单例：公共静态属性是final的，所以它总是包含相同的对象引用。 第二个好处是它更简单。</p><p>静态工厂方法的一个优点是，它可以灵活地改变你的想法，无论该类是否为单例而不必更改其API。 工厂方法返回唯一的实例，但是可以修改，比如，返回调用它的每个线程的单独实例。 第二个好处是，如果你的应用程序需要它，可以编写一个泛型单例工厂（generic singleton factory ）（条目30）。 使用静态工厂的最后一个优点是方法引用可以用<code>supplier</code>，例如<code>Elvis :: instance</code>等同于<code>Supplier&lt;Elvis&gt;</code>。 除非与这些优点相关的，否则公共属性方法是可取的。</p><p>创建一个使用这两种方法的单例类(第12章)，仅仅将<code>implements Serializable</code>添加到声明中是不够的。为了维护单例的保证，声明所有的实例属性为<code>transient</code>，并提供一个<code>readResolve</code>方法(条目89)。否则，每当序列化实例被反序列化时，就会创建一个新的实例，在我们的例子中，导致出现新的Elvis实例。为了防止这种情况发生，将这个<code>readResolve</code>方法添加到Elvis类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// readResolve method to preserve singleton property</span><br><span class="line">private Object readResolve() &#123;</span><br><span class="line">     // Return the one true Elvis and let the garbage collector</span><br><span class="line">     // take care of the Elvis impersonator.</span><br><span class="line">    return INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现一个单例的第三种方法是声明单一元素的枚举类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Enum singleton - the preferred approach</span><br><span class="line">public enum Elvis &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    public void leaveTheBuilding() &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式类似于公共属性方法，但更简洁，提供了免费的序列化机制，并提供了针对多个实例化的坚固保证，即使是在复杂的序列化或反射攻击的情况下。这种方法可能感觉有点不自然，但是<strong>单一元素枚举类通常是实现单例的最佳方式</strong>。注意，如果单例必须继承<code>Enum</code>以外的父类(尽管可以声明一个<code>Enum</code>来实现接口)，那么就不能使用这种方法。</p><h2 id="4-使用私有构造方法执行非实例化"><a href="#4-使用私有构造方法执行非实例化" class="headerlink" title="4. 使用私有构造方法执行非实例化"></a>4. 使用私有构造方法执行非实例化</h2><p>偶尔你会想写一个类，它只是一组静态方法和静态属性。 这样的类获得了不好的名声，因为有些人滥用这些类而避免以面向对象方式思考，但是它们确实有着特殊的用途。 它们可以用来按照<code>java.lang.Math</code>或<code>java.util.Arrays</code>的方式，在基本类型的数值或数组上组织相关的方法。 它们也可以用于将静态方法（包括工厂（条目 1））分组，用于实现某个接口的对象，其方式为<code>java.util.Collections</code>。 （从Java 8开始，你也可以将这些方法放在接口中，假如它是你自己修改的。）最后，这样的类可以用于在final类上对方法进行分组，因为不能将它们放在子类中。</p><p>这样的实用类（ utility classes）不是设计用来被实例化的：一个实例是没有意义的。然而，在没有显式构造方法的情况下，编译器提供了一个公共的、无参的默认构造方法。对于用户来说，该构造方法与其他构造方法没有什么区别。在已发布的 API中经常看到无意识的被实例的类。</p><p><strong>试图通过创建抽象类来强制执行非实例化是行不通的。</strong>该类可以被子类化，子类可以被实例化。此外，它误导用户认为该类是为继承而设计的(条目 19)。不过，有一个简单的方法来确保非实例化。只有当类不包含显式构造方法时，才会生成一个默认构造方法，<strong>因此可以通过包含一个私有构造方法来实现类的非实例化：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// Noninstantiable utility class</span><br><span class="line">public class UtilityClass &#123;</span><br><span class="line">    // Suppress default constructor for noninstantiability</span><br><span class="line">    private UtilityClass() &#123;</span><br><span class="line">        throw new AssertionError();</span><br><span class="line">    &#125;</span><br><span class="line">    ... // Remainder omitted</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为显式构造方法是私有的，所以在类之外是不可访问的。<code>AssertionError</code>异常不是严格要求的，但是它提供了一种保证，以防在类中意外地调用构造方法。它保证类在任何情况下都不会被实例化。这个习惯用法有点违反直觉，好像构造方法就是设计成不能调用的一样。因此，如前面所示，添加注释是种明智的做法。</p><p>这种习惯有一个副作用，阻止了类的子类化。所有的构造方法都必须显式或隐式地调用父类构造方法，而子类则没有可访问的父类构造方法来调用。</p><h2 id="5-使用依赖注入取代硬连接资源（hardwiring-resources）"><a href="#5-使用依赖注入取代硬连接资源（hardwiring-resources）" class="headerlink" title="5. 使用依赖注入取代硬连接资源（hardwiring resources）"></a>5. 使用依赖注入取代硬连接资源（hardwiring resources）</h2><p>许多类依赖于一个或多个底层资源。例如，拼写检查器依赖于字典。将此类类实现为静态实用工具类并不少见(条目 4):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// Inappropriate use of static utility - inflexible &amp; untestable!</span><br><span class="line">public class SpellChecker &#123;</span><br><span class="line">    private static final Lexicon dictionary = ...;</span><br><span class="line"></span><br><span class="line">    private SpellChecker() &#123;&#125; // Noninstantiable</span><br><span class="line"></span><br><span class="line">    public static boolean isValid(String word) &#123; ... &#125;</span><br><span class="line">    public static List&lt;String&gt; suggestions(String typo) &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样地，将它们实现为单例也并不少见(条目 3)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// Inappropriate use of singleton - inflexible &amp; untestable!</span><br><span class="line">public class SpellChecker &#123;</span><br><span class="line">    private final Lexicon dictionary = ...;</span><br><span class="line"></span><br><span class="line">    private SpellChecker(...) &#123;&#125;</span><br><span class="line">    public static INSTANCE = new SpellChecker(...);</span><br><span class="line"></span><br><span class="line">    public boolean isValid(String word) &#123; ... &#125;</span><br><span class="line">    public List&lt;String&gt; suggestions(String typo) &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两种方法都不令人满意，因为他们假设只有一本字典值得使用。在实际中，每种语言都有自己的字典，特殊的字典被用于特殊的词汇表。另外，使用专门的字典来进行测试也是可取的。想当然地认为一本字典就足够了，这是一厢情愿的想法。</p><p>可以通过使<code>dictionary</code>属性设置为非<code>final</code>，并添加一个方法来更改现有拼写检查器中的字典，从而让拼写检查器支持多个字典，但是在并发环境中，这是笨拙的、容易出错的和不可行的。<strong>静态实用类和单例对于那些行为被底层资源参数化的类来说是不合适的</strong>。</p><p>所需要的是能够支持类的多个实例(在我们的示例中，即<code>SpellChecker</code>)，每个实例都使用客户端所期望的资源(在我们的例子中是<code>dictionary</code>)。满足这一需求的简单模式是在创建新实例时将资源传递到构造方法中。这是依赖项注入（dependency injection）的一种形式：字典是拼写检查器的一个依赖项，当它创建时被注入到拼写检查器中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// Dependency injection provides flexibility and testability</span><br><span class="line">public class SpellChecker &#123;</span><br><span class="line">    private final Lexicon dictionary;</span><br><span class="line"></span><br><span class="line">    public SpellChecker(Lexicon dictionary) &#123;</span><br><span class="line">        this.dictionary = Objects.requireNonNull(dictionary);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isValid(String word) &#123; ... &#125;</span><br><span class="line">    public List&lt;String&gt; suggestions(String typo) &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>依赖注入模式非常简单，许多程序员使用它多年而不知道它有一个名字。 虽然我们的拼写检查器的例子只有一个资源（字典），但是依赖项注入可以使用任意数量的资源和任意依赖图。 它保持了不变性（条目 17），因此多个客户端可以共享依赖对象（假设客户需要相同的底层资源）。 依赖注入同样适用于构造方法，静态工厂（条目 1）和 builder模式（条目 2）。</p><p>该模式的一个有用的变体是将资源工厂传递给构造方法。 工厂是可以重复调用以创建类型实例的对象。 这种工厂体现了工厂方法模式（Factory Method pattern ）[Gamma95]。 Java 8中引入的<code>Supplier &lt;T&gt;</code>接口非常适合代表工厂。 在输入上采用<code>Supplier&lt;T&gt;</code>的方法通常应该使用有界的通配符类型( bounded wildcard type)（条目 31）约束工厂的类型参数，以允许客户端传入工厂，创建指定类型的任何子类型。 例如，下面是一个使用客户端提供的工厂生成tile的方法：<br><code>Mosaic create(Supplier&lt;? extends Tile&gt; tileFactory) { ... }</code></p><p>尽管依赖注入极大地提高了灵活性和可测试性，但它可能使大型项目变得混乱，这些项目通常包含数千个依赖项。使用依赖注入框架(如Dagger[Dagger]、Guice[Guice]或Spring[Spring])可以消除这些混乱。这些框架的使用超出了本书的范围，但是请注意，为手动依赖注入而设计的API非常适合这些框架的使用。</p><p>总之，不要使用单例或静态的实用类来实现一个类，该类依赖于一个或多个底层资源，这些资源的行为会影响类的行为，并且不让类直接创建这些资源。相反，将资源或工厂传递给构造方法(或静态工厂或builder模式)。这种称为依赖注入的实践将极大地增强类的灵活性、可重用性和可测试性。</p><h2 id="6-避免创建不必要的对象"><a href="#6-避免创建不必要的对象" class="headerlink" title="6. 避免创建不必要的对象"></a>6. 避免创建不必要的对象</h2><p>在每次需要时重用一个对象而不是创建一个新的相同功能对象通常是恰当的。重用可以更快更流行。如果对象是不可变的(条目 17)，它总是可以被重用。</p><p>作为一个不应该这样做的极端例子，请考虑以下语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s = new String(&quot;bikini&quot;);  // DON&apos;T DO THIS!</span><br></pre></td></tr></table></figure><p>语句每次执行时都会创建一个新的String实例，而这些对象的创建都不是必需的。String构造方法<code>(“bikini”)</code>的参数本身就是一个<code>bikini</code>实例，它与构造方法创建的所有对象的功能相同。如果这种用法发生在循环中，或者在频繁调用的方法中，就可以毫无必要地创建数百万个String实例。</p><p>改进后的版本如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s = &quot;bikini&quot;;</span><br></pre></td></tr></table></figure><p>该版本使用单个String实例，而不是每次执行时创建一个新实例。此外，它可以保证对象运行在同一虚拟机上的任何其他代码重用，而这些代码恰好包含相同的字符串字面量[JLS,3.10.5]。</p><p>通过使用静态工厂方法(static factory methods(项目1)，可以避免创建不需要的对象。例如，工厂方法<code>Boolean.valueOf(String)</code>比构造方法<code>Boolean(String</code>)更可取，后者在Java 9中被弃用。构造方法每次调用时都必须创建一个新对象，而工厂方法永远不需要这样做，在实践中也不需要。除了重用不可变对象，如果知道它们不会被修改，还可以重用可变对象。</p><p>一些对象的创建比其他对象的创建要昂贵得多。 如果要重复使用这样一个“昂贵的对象”，建议将其缓存起来以便重复使用。 不幸的是，当创建这样一个对象时并不总是很直观明显的。 假设你想写一个方法来确定一个字符串是否是一个有效的罗马数字。 以下是使用正则表达式完成此操作时最简单方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Performance can be greatly improved!</span><br><span class="line">static boolean isRomanNumeral(String s) &#123;</span><br><span class="line">    return s.matches(&quot;^(?=.)M*(C[MD]|D?C&#123;0,3&#125;)&quot;</span><br><span class="line">            + &quot;(X[CL]|L?X&#123;0,3&#125;)(I[XV]|V?I&#123;0,3&#125;)$&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个实现的问题在于它依赖于<code>String.matches</code>方法。 虽然<code>String.matches</code>是检查字符串是否与正则表达式匹配的最简单方法，但它不适合在性能临界的情况下重复使用。 问题是它在内部为正则表达式创建一个<code>Pattern</code>实例，并且只使用它一次，之后它就有资格进行垃圾收集。 创建<code>Pattern</code>实例是昂贵的，因为它需要将正则表达式编译成有限状态机（finite state machine）。</p><p>为了提高性能，作为类初始化的一部分，将正则表达式显式编译为一个<code>Pattern</code>实例（不可变），缓存它，并在<code>isRomanNumeral</code>方法的每个调用中重复使用相同的实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// Reusing expensive object for improved performance</span><br><span class="line">public class RomanNumerals &#123;</span><br><span class="line">    private static final Pattern ROMAN = Pattern.compile(</span><br><span class="line">            &quot;^(?=.)M*(C[MD]|D?C&#123;0,3&#125;)&quot;</span><br><span class="line">            + &quot;(X[CL]|L?X&#123;0,3&#125;)(I[XV]|V?I&#123;0,3&#125;)$&quot;);</span><br><span class="line"></span><br><span class="line">    static boolean isRomanNumeral(String s) &#123;</span><br><span class="line">        return ROMAN.matcher(s).matches();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果经常调用，<code>isRomanNumera</code>l的改进版本的性能会显著提升。 在我的机器上，原始版本在输入8个字符的字符串上需要1.1微秒，而改进的版本则需要0.17微秒，速度提高了6.5倍。 性能上不仅有所改善，而且更明确清晰了。 为不可见的Pattern实例创建静态final修饰的属性，并允许给它一个名字，这个名字比正则表达式本身更具可读性。</p><p>如果包含<code>isRomanNumeral</code>方法的改进版本的类被初始化，但该方法从未被调用，则<code>ROMAN</code>属性则没必要初始化。 在第一次调用<code>isRomanNumeral</code>方法时，可以通过延迟初始化（ lazily initializing）属性（条目 83）来排除初始化，但一般不建议这样做。 延迟初始化常常会导致实现复杂化，而性能没有可衡量的改进（条目 67）。</p><p>当一个对象是不可变的时，很明显它可以被安全地重用，但是在其他情况下，它远没有那么明显，甚至是违反直觉的。考虑适配器（adapters）的情况[Gamma95]，也称为视图（views）。一个适配器是一个对象，它委托一个支持对象（backing object），提供一个可替代的接口。由于适配器没有超出其支持对象的状态，因此不需要为给定对象创建多个给定适配器的实例。</p><p>例如，Map接口的<code>keySet方法</code>返回Map对象的Set视图，包含Map中的所有key。 天真地说，似乎每次调用keySet都必须创建一个新的Set实例，但是对给定Map对象的<code>keySet</code>的每次调用都返回相同的Set实例。 尽管返回的Set实例通常是可变的，但是所有返回的对象在功能上都是相同的：当其中一个返回的对象发生变化时，所有其他对象也都变化，因为它们全部由相同的Map实例支持。 虽然创建<code>keySet</code>视图对象的多个实例基本上是无害的，但这是没有必要的，也没有任何好处。</p><p>另一种创建不必要的对象的方法是自动装箱（autoboxing），它允许程序员混用基本类型和包装的基本类型，根据需要自动装箱和拆箱。 自动装箱模糊不清，但不会消除基本类型和装箱基本类型之间的区别。 有微妙的语义区别和不那么细微的性能差异（条目 61）。 考虑下面的方法，它计算所有正整数的总和。 要做到这一点，程序必须使用<code>long</code>类型，因为<code>int</code>类型不足以保存所有正整数的总和：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// Hideously slow! Can you spot the object creation?</span><br><span class="line">private static long sum() &#123;</span><br><span class="line">    Long sum = 0L;</span><br><span class="line">    for (long i = 0; i &lt;= Integer.MAX_VALUE; i++)</span><br><span class="line">        sum += i;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序的结果是正确的，但由于写错了一个字符，运行的结果要比实际慢很多。变量<code>sum</code>被声明成了<code>Long</code>而不是<code>long</code>，这意味着程序构造了大约231不必要的<code>Long</code>实例（大约每次往<code>Long</code>类型的 <code>sum</code>变量中增加一个<code>long</code>类型构造的实例），把<code>sum</code>变量的类型由<code>Long</code>改为<code>long</code>，在我的机器上运行时间从6.3秒降低到0.59秒。这个教训很明显：<strong>优先使用基本类型而不是装箱的基本类型，也要注意无意识的自动装箱</strong>。</p><p>这个条目不应该被误解为暗示对象创建是昂贵的，应该避免创建对象。 相反，使用构造方法创建和回收小的对象是非常廉价，构造方法只会做很少的显示工作，，尤其是在现代JVM实现上。 创建额外的对象以增强程序的清晰度，简单性或功能性通常是件好事。</p><p>相反，除非池中的对象非常重量级，否则通过维护自己的对象池来避免对象创建是一个坏主意。对象池的典型例子就是数据库连接。建立连接的成本非常高，因此重用这些对象是有意义的。但是，一般来说，维护自己的对象池会使代码混乱，增加内存占用，并损害性能。现代JVM实现具有高度优化的垃圾收集器，它们在轻量级对象上轻松胜过此类对象池。</p><p>这个条目的对应点是针对条目 50的防御性复制（defensive copying）。 目前的条目说：“当你应该重用一个现有的对象时，不要创建一个新的对象”，而条目 50说：“不要重复使用现有的对象，当你应该创建一个新的对象时。”请注意，重用防御性复制所要求的对象所付出的代价，要远远大于不必要地创建重复的对象。 未能在需要的情况下防御性复制会导致潜在的错误和安全漏洞；而不必要地创建对象只会影响程序的风格和性能。</p><h2 id="7-消除过期的对象引用"><a href="#7-消除过期的对象引用" class="headerlink" title="7. 消除过期的对象引用"></a>7. 消除过期的对象引用</h2><p>如果你从使用手动内存管理的语言(如C或c++)切换到像Java这样的带有垃圾收集机制的语言，那么作为程序员的工作就会变得容易多了，因为你的对象在使用完毕以后就自动回收了。当你第一次体验它的时候，它就像魔法一样。这很容易让人觉得你不需要考虑内存管理，但这并不完全正确。</p><p>考虑以下简单的堆栈实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// Can you spot the &quot;memory leak&quot;?</span><br><span class="line">public class Stack &#123;</span><br><span class="line">    private Object[] elements;</span><br><span class="line">    private int size = 0;</span><br><span class="line">    private static final int DEFAULT_INITIAL_CAPACITY = 16;</span><br><span class="line"></span><br><span class="line">    public Stack() &#123;</span><br><span class="line">        elements = new Object[DEFAULT_INITIAL_CAPACITY];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void push(Object e) &#123;</span><br><span class="line">        ensureCapacity();</span><br><span class="line">        elements[size++] = e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object pop() &#123;</span><br><span class="line">        if (size == 0)</span><br><span class="line">            throw new EmptyStackException();</span><br><span class="line">        return elements[--size];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Ensure space for at least one more element, roughly</span><br><span class="line">     * doubling the capacity each time the array needs to grow.</span><br><span class="line">     */</span><br><span class="line">    private void ensureCapacity() &#123;</span><br><span class="line">        if (elements.length == size)</span><br><span class="line">            elements = Arrays.copyOf(elements, 2 * size + 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序没有什么明显的错误（但是对于泛型版本，请参阅条目 29）。 你可以对它进行详尽的测试，它都会成功地通过每一项测试，但有一个潜在的问题。 笼统地说，程序有一个“内存泄漏”，由于垃圾回收器的活动的增加，或内存占用的增加，静默地表现为性能下降。 在极端的情况下，这样的内存泄漏可能会导致磁盘分页（ disk paging），甚至导致内存溢出（OutOfMemoryError）的失败，但是这样的故障相对较少。</p><p>那么哪里发生了内存泄漏？ 如果一个栈增长后收缩，那么从栈弹出的对象不会被垃圾收集，即使使用栈的程序不再引用这些对象。 这是因为栈维护对这些对象的过期引用（ obsolete references）。 过期引用简单来说就是永远不会解除的引用。 在这种情况下，元素数组“活动部分（active portion）”之外的任何引用都是过期的。 活动部分是由索引下标小于size的元素组成。</p><p>垃圾收集语言中的内存泄漏（更适当地称为无意的对象保留 unintentional object retentions）是隐蔽的。 如果无意中保留了对象引用，那么不仅这个对象排除在垃圾回收之外，而且该对象引用的任何对象也是如此。 即使只有少数对象引用被无意地保留下来，也可以阻止垃圾回收机制对许多对象的回收，这对性能产生很大的影响。</p><p>这类问题的解决方法很简单：一旦对象引用过期，将它们设置为 null。 在我们的<code>Stack</code>类的情景下，只要从栈中弹出，元素的引用就设置为过期。 <code>pop</code>方法的修正版本如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public Object pop() &#123;</span><br><span class="line">    if (size == 0)</span><br><span class="line">        throw new EmptyStackException();</span><br><span class="line">    Object result = elements[--size];</span><br><span class="line">    elements[size] = null; // Eliminate obsolete reference</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>取消过期引用的另一个好处是，如果它们随后被错误地引用，程序立即抛出<code>NullPointerException</code>异常，而不是悄悄地做继续做错误的事情。尽可能快地发现程序中的错误是有好处的。</p><p>当程序员第一次被这个问题困扰时，他们可能会在程序结束后立即清空所有对象引用。这既不是必要的，也不是可取的；它不必要地搞乱了程序。<strong>清空对象引用应该是例外而不是规范</strong>。消除过期引用的最好方法是让包含引用的变量超出范围。如果在最近的作用域范围内定义每个变量(条目 57)，这种自然就会出现这种情况。</p><p>那么什么时候应该清空一个引用呢？<code>Stack</code>类的哪个方面使它容易受到内存泄漏的影响？简单地说，它管理自己的内存。存储池（storage pool）由<code>elements</code>数组的元素组成(对象引用单元，而不是对象本身)。数组中活动部分的元素(如前面定义的)被分配，其余的元素都是空闲的。垃圾收集器没有办法知道这些；对于垃圾收集器来说，<code>elements</code>数组中的所有对象引用都同样有效。只有程序员知道数组的非活动部分不重要。程序员可以向垃圾收集器传达这样一个事实，一旦数组中的元素变成非活动的一部分，就可以手动清空这些元素的引用。</p><p>一般来说，<strong>当一个类自己管理内存时，程序员应该警惕内存泄漏问题</strong>。 每当一个元素被释放时，元素中包含的任何对象引用都应该被清除。</p><p><strong>另一个常见的内存泄漏来源是缓存</strong>。一旦将对象引用放入缓存中，很容易忘记它的存在，并且在它变得无关紧要之后，仍然保留在缓存中。对于这个问题有几种解决方案。如果你正好想实现了一个缓存：只要在缓存之外存在对某个项（entry）的键（key）引用，那么这项就是明确有关联的，就可以用<code>WeakHashMap</code>来表示缓存；这些项在过期之后自动删除。记住，只有当缓存中某个项的生命周期是由外部引用到键（key）而不是值（value）决定时，<code>WeakHashMap</code>才有用。</p><p>更常见的情况是，缓存项有用的生命周期不太明确，随着时间的推移一些项变得越来越没有价值。在这种情况下，缓存应该偶尔清理掉已经废弃的项。这可以通过一个后台线程(也许是<code>ScheduledThreadPoolExecutor</code>)或将新的项添加到缓存时顺便清理。<code>LinkedHashMap</code>类使用它的<code>removeEldestEntry</code>方法实现了后一种方案。对于更复杂的缓存，可能直接需要使用<code>java.lang.ref</code>。</p><p>第三个常见的内存泄漏来源是监听器和其他回调。如果你实现了一个API，其客户端注册回调，但是没有显式地撤销注册回调，除非采取一些操作，否则它们将会累积。确保回调是垃圾收集的一种方法是只存储弱引用（weak references），例如，仅将它们保存在<code>WeakHashMap</code>的键（key）中。</p><p>因为内存泄漏通常不会表现为明显的故障，所以它们可能会在系统中保持多年。 通常仅在仔细的代码检查或借助堆分析器（ heap profiler）的调试工具才会被发现。 因此，学习如何预见这些问题，并防止这些问题发生，是非常值得的。</p><h2 id="8-避免使用Finalizer和Cleaner机制"><a href="#8-避免使用Finalizer和Cleaner机制" class="headerlink" title="8. 避免使用Finalizer和Cleaner机制"></a>8. 避免使用Finalizer和Cleaner机制</h2><p>Finalizer机制是不可预知的，往往是危险的，而且通常是不必要的。 它们的使用会导致不稳定的行为，糟糕的性能和移植性问题。 Finalizer机制有一些特殊的用途，我们稍后会在这个条目中介绍，但是通常应该避免它们。 从Java 9开始，Finalizer机制已被弃用，但仍被Java类库所使用。 Java 9中 Cleaner机制代替了Finalizer机制。 Cleaner机制不如Finalizer机制那样危险，但仍然是不可预测，运行缓慢并且通常是不必要的。</p><p>提醒C++程序员不要把Java中的Finalizer或Cleaner机制当成的C ++析构函数的等价物。 在C++中，析构函数是回收对象相关资源的正常方式，是与构造方法相对应的。 在Java中，当一个对象变得不可达时，垃圾收集器回收与对象相关联的存储空间，不需要开发人员做额外的工作。 C ++析构函数也被用来回收其他非内存资源。 在Java中，try-with-resources或try-finally块用于此目的（条目 9）。</p><p>Finalizer和Cleaner机制的一个缺点是不能保证他们能够及时执行[JLS，12.6]。 在一个对象变得无法访问时，到Finalizer和Cleaner机制开始运行时，这期间的时间是任意长的。 这意味着你永远不应该Finalizer和Cleaner机制做任何时间敏感（time-critical）的事情。 例如，依赖于Finalizer和Cleaner机制来关闭文件是严重的错误，因为打开的文件描述符是有限的资源。 如果由于系统迟迟没有运行Finalizer和Cleaner机制而导致许多文件被打开，程序可能会失败，因为它不能再打开文件了。</p><p>及时执行Finalizer和 Cleaner机制是垃圾收集算法的一个功能，这种算法在不同的实现中有很大的不同。程序的行为依赖于Finalizer和 Cleaner机制的及时执行，其行为也可能大不不同。 这样的程序完全可以在你测试的JVM上完美运行，然而在你最重要的客户的机器上可能运行就会失败。</p><p>延迟终结（finalization）不只是一个理论问题。为一个类提供一个Finalizer机制可以任意拖延它的实例的回收。一位同事调试了一个长时间运行的GUI应用程序，这个应用程序正在被一个OutOfMemoryError错误神秘地死掉。分析显示，在它死亡的时候，应用程序的Finalizer机制队列上有成千上万的图形对象正在等待被终结和回收。不幸的是，Finalizer机制线程的运行优先级低于其他应用程序线程，所以对象被回收的速度低于进入队列的速度。语言规范并不保证哪个线程执行Finalizer机制，因此除了避免使用Finalizer机制之外，没有轻便的方法来防止这类问题。在这方面， Cleaner机制比Finalizer机制要好一些，因为Java类的创建者可以控制自己cleaner机制的线程，但cleaner机制仍然在后台运行，在垃圾回收器的控制下运行，但不能保证及时清理。</p><p>Java规范不能保证Finalizer和Cleaner机制能及时运行；它甚至不能能保证它们是否会运行。当一个程序结束后，一些不可达对象上的Finalizer和Cleaner机制仍然没有运行。因此，不应该依赖于Finalizer和Cleaner机制来更新持久化状态。例如，依赖于Finalizer和Cleaner机制来释放对共享资源(如数据库)的持久锁，这是一个使整个分布式系统陷入停滞的好方法。</p><p>不要相信<code>System.gc</code>和<code>System.runFinalization</code>方法。 他们可能会增加Finalizer和Cleaner机制被执行的几率，但不能保证一定会执行。 曾经声称做出这种保证的两个方法：<code>System.runFinalizersOnExit</code>和它的孪生兄弟<code>Runtime.runFinalizersOnExit</code>，包含致命的缺陷，并已被弃用了几十年[ThreadStop]。</p><p>Finalizer机制的另一个问题是在执行Finalizer机制过程中，未捕获的异常会被忽略，并且该对象的Finalizer机制也会终止 [JLS, 12.6]。未捕获的异常会使其他对象陷入一种损坏的状态（corrupt state）。如果另一个线程试图使用这样一个损坏的对象，可能会导致任意不确定的行为。通常情况下，未捕获的异常将终止线程并打印堆栈跟踪（ stacktrace），但如果发生在Finalizer机制中，则不会发出警告。Cleaner机制没有这个问题，因为使用Cleaner机制的类库可以控制其线程。</p><p>使用finalizer和cleaner机制会导致严重的性能损失。 在我的机器上，创建一个简单的<code>AutoCloseable</code>对象，使用try-with-resources关闭它，并让垃圾回收器回收它的时间大约是12纳秒。 使用finalizer机制，而时间增加到550纳秒。 换句话说，使用finalizer机制创建和销毁对象的速度要慢50倍。 这主要是因为finalizer机制会阻碍有效的垃圾收集。 如果使用它们来清理类的所有实例(在我的机器上的每个实例大约是500纳秒)，那么cleaner机制的速度与finalizer机制的速度相当，但是如果仅将它们用作安全网（ safety net），则cleaner机制要快得多，如下所述。 在这种环境下，创建，清理和销毁一个对象在我的机器上需要大约66纳秒，这意味着如果你不使用安全网的话，需要支付5倍(而不是50倍)的保险。</p><p>finalizer机制有一个严重的安全问题：它们会打开你的类来进行finalizer机制攻击。finalizer机制攻击的想法很简单：如果一个异常是从构造方法或它的序列化中抛出的——<code>readObjec</code>t和<code>readResolve</code>方法(第12章)——恶意子类的finalizer机制可以运行在本应该“中途夭折（died on the vine）”的部分构造对象上。finalizer机制可以在静态字属性记录对对象的引用，防止其被垃圾收集。一旦记录了有缺陷的对象，就可以简单地调用该对象上的任意方法，而这些方法本来就不应该允许存在。从构造方法中抛出异常应该足以防止对象出现；而在finalizer机制存在下，则不是。这样的攻击会带来可怕的后果。Final类不受finalizer机制攻击的影响，因为没有人可以编写一个final类的恶意子类。为了保护非final类不受finalizer机制攻击，编写一个final的<code>finalize</code>方法，它什么都不做。</p><p>那么，你应该怎样做呢？为对象封装需要结束的资源(如文件或线程)，而不是为该类编写Finalizer和Cleaner机制？让你的类实现<code>AutoCloseable</code>接口即可，并要求客户在在不再需要时调用每个实例close方法，通常使用try-with-resources确保终止，即使面对有异常抛出情况（条目 9）。一个值得一提的细节是实例必须跟踪是否已经关闭：close方法必须记录在对象里不再有效的属性，其他方法必须检查该属性，如果在对象关闭后调用它们，则抛出IllegalStateException异常。</p><p>那么，Finalizer和Cleaner机制有什么好处呢？它们可能有两个合法用途。一个是作为一个安全网（safety net），以防资源的拥有者忽略了它的<code>close</code>方法。虽然不能保证Finalizer和Cleaner机制会迅速运行(或者根本就没有运行)，最好是把资源释放晚点出来，也要好过客户端没有这样做。如果你正在考虑编写这样的安全网Finalizer机制，请仔细考虑一下这样保护是否值得付出对应的代价。一些Java库类，如<code>FileInputStream</code>、<code>FileOutputStream</code>、<code>ThreadPoolExecutor</code>和<code>java.sql.Connection</code>，都有作为安全网的Finalizer机制。</p><p>第二种合理使用Cleaner机制的方法与本地对等类（native peers）有关。本地对等类是一个由普通对象委托的本地(非Java)对象。由于本地对等类不是普通的 Java对象，所以垃圾收集器并不知道它，当它的Java对等对象被回收时，本地对等类也不会回收。假设性能是可以接受的，并且本地对等类没有关键的资源，那么Finalizer和Cleaner机制可能是这项任务的合适的工具。但如果性能是不可接受的，或者本地对等类持有必须迅速回收的资源，那么类应该有一个<code>close</code>方法，正如前面所述。</p><p>Cleaner机制使用起来有点棘手。下面是演示该功能的一个简单的<code>Room</code>类。假设<code>Room</code>对象必须在被回收前清理干净。<code>Room</code>类实现<code>AutoCloseable</code>接口；它的自动清理安全网使用的是一个Cleaner机制，这仅仅是一个实现细节。与Finalizer机制不同，Cleaner机制不污染一个类的公共API：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// An autocloseable class using a cleaner as a safety net</span><br><span class="line">public class Room implements AutoCloseable &#123;</span><br><span class="line">    private static final Cleaner cleaner = Cleaner.create();</span><br><span class="line"></span><br><span class="line">    // Resource that requires cleaning. Must not refer to Room!</span><br><span class="line">    private static class State implements Runnable &#123;</span><br><span class="line">        int numJunkPiles; // Number of junk piles in this room</span><br><span class="line"></span><br><span class="line">        State(int numJunkPiles) &#123;</span><br><span class="line">            this.numJunkPiles = numJunkPiles;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Invoked by close method or cleaner</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(&quot;Cleaning room&quot;);</span><br><span class="line">            numJunkPiles = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // The state of this room, shared with our cleanable</span><br><span class="line">    private final State state;</span><br><span class="line"></span><br><span class="line">    // Our cleanable. Cleans the room when it’s eligible for gc</span><br><span class="line">    private final Cleaner.Cleanable cleanable;</span><br><span class="line"></span><br><span class="line">    public Room(int numJunkPiles) &#123;</span><br><span class="line">        state = new State(numJunkPiles);</span><br><span class="line">        cleanable = cleaner.register(this, state);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void close() &#123;</span><br><span class="line">        cleanable.clean();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态内部<code>State</code>类拥有Cleaner机制清理房间所需的资源。 在这里，它仅仅包含<code>numJunkPiles</code>属性，它代表混乱房间的数量。 更实际地说，它可能是一个final修饰的<code>long</code>类型的指向本地对等类的指针。 <code>State</code>类实现了<code>Runnable</code>接口，其<code>run</code>方法最多只能调用一次，只能被我们在<code>Room</code>构造方法中用Cleaner机制注册<code>State</code>实例时得到的<code>Cleanable</code>调用。 对<code>run</code>方法的调用通过以下两种方法触发：通常，通过调用<code>Room</code>的<code>close</code>方法内调用<code>Cleanable</code>的<code>clean</code>方法来触发。 如果在<code>Room</code>实例有资格进行垃圾回收的时候客户端没有调用<code>close</code>方法，那么Cleaner机制将（希望）调用<code>State</code>的<code>run</code>方法。</p><p>一个<code>State</code>实例不引用它的<code>Room</code>实例是非常重要的。如果它引用了，则创建了一个循环，阻止了<code>Room</code>实例成为垃圾收集的资格(以及自动清除)。因此，<code>State</code>必须是静态的嵌内部类，因为非静态内部类包含对其宿主类的实例的引用(条目 24)。同样，使用lambda表达式也是不明智的，因为它们很容易获取对宿主类对象的引用。</p><p>就像我们之前说的，<code>Room</code>的Cleaner机制仅仅被用作一个安全网。如果客户将所有<code>Room</code>的实例放在try-with-resource块中，则永远不需要自动清理。行为良好的客户端如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Adult &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try (Room myRoom = new Room(7)) &#123;</span><br><span class="line">            System.out.println(&quot;Goodbye&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如你所预料的，运行<code>Adult</code>程序会打印<code>Goodbye</code>字符串，随后打印<code>Cleaning room</code>字符串。但是如果时不合规矩的程序，它从来不清理它的房间会是什么样的?</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Teenager &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new Room(99);</span><br><span class="line">        System.out.println(&quot;Peace out&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可能期望它打印出<code>Peace out</code>，然后打印<code>Cleaning room</code>字符串，但在我的机器上，它从不打印<code>Cleaning room</code>字符串；仅仅是程序退出了。 这是我们之前谈到的不可预见性。 Cleaner机制的规范说：“<code>System.exit</code>方法期间的清理行为是特定于实现的。 不保证清理行为是否被调用。”虽然规范没有说明，但对于正常的程序退出也是如此。 在我的机器上，将<code>System.gc()</code>方法添加到<code>Teenager</code>类的<code>main</code>方法足以让程序退出之前打印<code>Cleaning room</code>，但不能保证在你的机器上会看到相同的行为。</p><p>总之，除了作为一个安全网或者终止非关键的本地资源，不要使用Cleaner机制，或者是在Java 9发布之前的finalizers机制。即使是这样，也要当心不确定性和性能影响。</p><h2 id="9-使用try-with-resources语句替代try-finally语句"><a href="#9-使用try-with-resources语句替代try-finally语句" class="headerlink" title="9. 使用try-with-resources语句替代try-finally语句"></a>9. 使用try-with-resources语句替代try-finally语句</h2><p>Java类库中包含许多必须通过调用<code>close</code>方法手动关闭的资源。 比如<code>InputStream</code>，<code>OutputStream</code>和<code>java.sql.Connection</code>。 客户经常忽视关闭资源，其性能结果可想而知。 尽管这些资源中有很多使用finalizer机制作为安全网，但finalizer机制却不能很好地工作（条目 8）。</p><p>从以往来看，try-finally语句是保证资源正确关闭的最佳方式，即使是在程序抛出异常或返回的情况下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// try-finally - No longer the best way to close resources!</span><br><span class="line">static String firstLineOfFile(String path) throws IOException &#123;</span><br><span class="line">    BufferedReader br = new BufferedReader(new FileReader(path));</span><br><span class="line">    try &#123;</span><br><span class="line">        return br.readLine();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这可能看起来并不坏，但是当添加第二个资源时，情况会变得更糟：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// try-finally is ugly when used with more than one resource!</span><br><span class="line">static void copy(String src, String dst) throws IOException &#123;</span><br><span class="line">    InputStream in = new FileInputStream(src);</span><br><span class="line">    try &#123;</span><br><span class="line">        OutputStream out = new FileOutputStream(dst);</span><br><span class="line">        try &#123;</span><br><span class="line">            byte[] buf = new byte[BUFFER_SIZE];</span><br><span class="line">            int n;</span><br><span class="line">            while ((n = in.read(buf)) &gt;= 0)</span><br><span class="line">                out.write(buf, 0, n);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            out.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这可能很难相信，但即使是优秀的程序员，大多数时候也会犯错误。首先，我在Java Puzzlers[Bloch05]的第88页上弄错了，多年来没有人注意到。事实上，2007年Java类库中使用<code>close</code>方法的三分之二都是错误的。</p><p>即使是用try-finally语句关闭资源的正确代码，如前面两个代码示例所示，也有一个微妙的缺陷。 try-with-resources块和finally块中的代码都可以抛出异常。 例如，在<code>firstLineOfFile</code>方法中，由于底层物理设备发生故障，对<code>readLine</code>方法的调用可能会引发异常，并且由于相同的原因，调用<code>close</code>方法可能会失败。 在这种情况下，第二个异常完全冲掉了第一个异常。 在异常堆栈跟踪中没有第一个异常的记录，这可能使实际系统中的调试非常复杂——通常这是你想要诊断问题的第一个异常。 虽然可以编写代码来抑制第二个异常，但是实际上没有人这样做，因为它太冗长了。</p><p>当Java 7引入了try-with-resources语句时，所有这些问题一下子都得到了解决[JLS,14.20.3]。要使用这个构造，资源必须实现 <code>AutoCloseable</code>接口，该接口由一个返回为<code>void</code>的<code>close</code>组成。Java类库和第三方类库中的许多类和接口现在都实现或继承了<code>AutoCloseable</code>接口。如果你编写的类表示必须关闭的资源，那么这个类也应该实现<code>AutoCloseable</code>接口。</p><p>以下是我们的第一个使用try-with-resources的示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// try-with-resources - the the best way to close resources!</span><br><span class="line">static String firstLineOfFile(String path) throws IOException &#123;</span><br><span class="line">    try (BufferedReader br = new BufferedReader(</span><br><span class="line">           new FileReader(path))) &#123;</span><br><span class="line">       return br.readLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是我们的第二个使用try-with-resources的示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// try-with-resources on multiple resources - short and sweet</span><br><span class="line">static void copy(String src, String dst) throws IOException &#123;</span><br><span class="line">    try (InputStream   in = new FileInputStream(src);</span><br><span class="line">         OutputStream out = new FileOutputStream(dst)) &#123;</span><br><span class="line">        byte[] buf = new byte[BUFFER_SIZE];</span><br><span class="line">        int n;</span><br><span class="line">        while ((n = in.read(buf)) &gt;= 0)</span><br><span class="line">            out.write(buf, 0, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不仅 try-with-resources版本比原始版本更精简，更好的可读性，而且它们提供了更好的诊断。 考虑<code>firstLineOfFile</code>方法。 如果调用<code>readLine</code>和（不可见）<code>close</code>方法都抛出异常，则后一个异常将被抑制（suppressed），而不是前者。 事实上，为了保留你真正想看到的异常，可能会抑制多个异常。 这些抑制的异常没有呗被抛弃， 而是打印在堆栈跟踪中，并标注为被抑制了。 你也可以使用<code>getSuppressed</code>方法以编程方式访问它们，该方法在Java 7中已添加到的<code>Throwable</code>中。</p><p>可以在 try-with-resources语句中添加catch子句，就像在常规的try-finally语句中一样。这允许你处理异常，而不会在另一层嵌套中污染代码。作为一个稍微有些做作的例子，这里有一个版本的<code>firstLineOfFile</code>方法，它不会抛出异常，但是如果它不能打开或读取文件，则返回默认值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// try-with-resources with a catch clause</span><br><span class="line">static String firstLineOfFile(String path, String defaultVal) &#123;</span><br><span class="line">    try (BufferedReader br = new BufferedReader(</span><br><span class="line">           new FileReader(path))) &#123;</span><br><span class="line">        return br.readLine();</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        return defaultVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结论明确：在处理必须关闭的资源时，使用try-with-resources语句替代try-finally语句。 生成的代码更简洁，更清晰，并且生成的异常更有用。 try-with-resources语句在编写必须关闭资源的代码时会更容易，也不会出错，而使用try-finally语句实际上是不可能的。</p><h2 id="10-重写equals方法时遵守通用约定"><a href="#10-重写equals方法时遵守通用约定" class="headerlink" title="10. 重写equals方法时遵守通用约定"></a>10. 重写equals方法时遵守通用约定</h2><p>虽然<code>Object</code>是一个具体的类，但它主要是为继承而设计的。它的所有非 final方法(equals、hashCode、toString、clone和finalize)都有清晰的通用约定（ general contracts），因为它们被设计为被子类重写。任何类都有义务重写这些方法，以遵从他们的通用约定；如果不这样做，将会阻止其他依赖于约定的类(例如HashMap和HashSet)与此类一起正常工作。</p><p>本章论述何时以及如何重写<code>Object</code>类的非final的方法。这一章省略了finalize方法，因为它在条目 8中进行了讨论。<code>Comparable.compareTo</code>方法虽然不是<code>Object</code>中的方法，因为具有很多的相似性，所以也在这里讨论。</p><p>重写equals方法看起来很简单，但是有很多方式会导致重写出错，其结果可能是可怕的。避免此问题的最简单方法不是覆盖equals方法，在这种情况下，类的每个实例只与自身相等。如果满足以下任一下条件，则说明是正确的做法：</p><ul><li><p>每个类的实例都是固有唯一的。 对于像Thread这样代表活动实体而不是值的类来说，这是正确的。 Object提供的equals实现对这些类完全是正确的行为。</p></li><li><p>类不需要提供一个“逻辑相等（logical equality）”的测试功能。例如<code>java.util.regex.Pattern</code>可以重写equals 方法检查两个是否代表完全相同的正则表达式Pattern实例，但是设计者并不认为客户需要或希望使用此功能。在这种情况下，从Object继承的equals实现是最合适的。</p></li><li><p>父类已经重写了equals方法，则父类行为完全适合于该子类。例如，大多数Set从AbstractSet继承了equals实现、List从AbstractList继承了equals实现，Map从AbstractMap的Map继承了equals实现。</p></li><li><p>类是私有的或包级私有的，可以确定它的equals方法永远不会被调用。如果你非常厌恶风险，可以重写equals方法，以确保不会被意外调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Override public boolean equals(Object o) &#123;</span><br><span class="line">throw new AssertionError(); // Method is never called</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>那什么时候需要重写 equals 方法呢？如果一个类包含一个逻辑相等（ logical equality）的概念，此概念有别于对象标识（object identity），而且父类还没有重写过equals 方法。这通常用在值类（ value classes）的情况。值类只是一个表示值的类，例如Integer或String类。程序员使用equals方法比较值对象的引用，期望发现它们在逻辑上是否相等，而不是引用相同的对象。重写 equals方法不仅可以满足程序员的期望，它还支持重写过equals 的实例作为Map 的键（key），或者 Set 里的元素，以满足预期和期望的行为。</p><p>一种不需要equals方法重写的值类是使用实例控制（instance control）（条目 1）的类，以确保每个值至多存在一个对象。 枚举类型（条目 34）属于这个类别。 对于这些类，逻辑相等与对象标识是一样的，所以Object的equals方法作用逻辑equals方法。</p><p>当你重写equals方法时，必须遵守它的通用约定。Object的规范如下：<br>equals方法实现了一个等价关系（equivalence relation）。它有以下这些属性:<br>•自反性：对于任何非空引用x，<code>x.equals(x)</code>必须返回true。<br>•对称性：对于任何非空引用x和y，如果且仅当<code>y.equals(x)</code>返回true时<code>x.equals(y)</code>必须返回true。<br>•传递性：对于任何非空引用x、y、z，如果<code>x.equals(y)</code>返回true，<code>y.equals(z)</code>返回true，则<code>x.equals(z)</code>必须返回true。<br>•一致性：对于任何非空引用x和y，如果在equals比较中使用的信息没有修改，则<code>x.equals(y)</code>的多次调用必须始终返回true或始终返回false。<br>•对于任何非空引用x，<code>x.equals(null)</code>必须返回false。</p><p>除非你喜欢数学，否则这看起来有点吓人，但不要忽略它！如果一旦违反了它，很可能会发现你的程序运行异常或崩溃，并且很难确定失败的根源。套用约翰·多恩(John Donne)的说法，没有哪个类是孤立存在的。一个类的实例常常被传递给另一个类的实例。许多类，包括所有的集合类，都依赖于传递给它们遵守equals约定的对象。</p><p>既然已经意识到违反equals约定的危险，让我们详细地讨论一下这个约定。好消息是，表面上看，这并不是很复杂。一旦你理解了，就不难遵守这一约定。</p><p>那么什么是等价关系？ 笼统地说，它是一个运算符，它将一组元素划分为彼此元素相等的子集。 这些子集被称为等价类（equivalence classes）。 为了使equals方法有用，每个等价类中的所有元素必须从用户的角度来说是可以互换（interchangeable）的。 现在让我们依次看下这个五个要求：</p><p>自反性（Reflexivity）——第一个要求只是说一个对象必须与自身相等。 很难想象无意中违反了这个规定。 如果你违反了它，然后把类的实例添加到一个集合中，那么<code>contains</code>方法可能会说集合中没有包含刚添加的实例。</p><p>对称性（Symmetry）——第二个要求是，任何两个对象必须在是否相等的问题上达成一致。与第一个要求不同的是，我们不难想象在无意中违反了这一要求。例如，考虑下面的类，它实现了不区分大小写的字符串。字符串被toString保存，但在equals比较中被忽略：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Objects;</span><br><span class="line"></span><br><span class="line">public final class CaseInsensitiveString &#123;</span><br><span class="line">    private final String s;</span><br><span class="line"></span><br><span class="line">    public CaseInsensitiveString(String s) &#123;</span><br><span class="line">        this.s = Objects.requireNonNull(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Broken - violates symmetry!</span><br><span class="line">    @Override</span><br><span class="line">    public boolean equals(Object o) &#123;</span><br><span class="line">        if (o instanceof CaseInsensitiveString)</span><br><span class="line">            return s.equalsIgnoreCase(</span><br><span class="line">                    ((CaseInsensitiveString) o).s);</span><br><span class="line">        if (o instanceof String)  // One-way interoperability!</span><br><span class="line">            return s.equalsIgnoreCase((String) o);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    ...// Remainder omitted</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面类中的 equals 试图与正常的字符串进行操作，假设我们有一个不区分大小写的字符串和一个正常的字符串：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CaseInsensitiveString cis = new CaseInsensitiveString(&quot;Polish&quot;);</span><br><span class="line">String s = &quot;polish”;</span><br><span class="line"></span><br><span class="line">System.out.println(cis.equals(s)); // true</span><br><span class="line">System.out.println(s.equals(cis)); // false</span><br></pre></td></tr></table></figure><p>正如所料，<code>cis.equals(s)</code>返回true。 问题是，尽管<code>CaseInsensitiveString</code>类中的equals方法知道正常字符串，但String类中的equals方法却忽略了不区分大小写的字符串。 因此，<code>s.equals(cis</code>)返回false，明显违反对称性。 假设把一个不区分大小写的字符串放入一个集合中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;CaseInsensitiveString&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">list.add(cis);</span><br></pre></td></tr></table></figure><p><code>list.contains(s)</code>返回了什么？谁知道呢？在当前的OpenJDK实现中，它会返回false，但这只是一个实现构件。在另一个实现中，它可以很容易地返回true或抛出运行时异常。一旦违反了equals约定，就不知道其他对象在面对你的对象时会如何表现了。</p><p>要消除这个问题，只需删除equals方法中与String类相互操作的恶意尝试。这样做之后，可以将该方法重构为单个返回语句:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean equals(Object o) &#123;</span><br><span class="line">    return o instanceof CaseInsensitiveString &amp;&amp;</span><br><span class="line">            ((CaseInsensitiveString) o).s.equalsIgnoreCase(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传递性（Transitivity）——equals 约定的第三个要求是，如果第一个对象等于第二个对象，第二个对象等于第三个对象，那么第一个对象必须等于第三个对象。同样，也不难想象，无意中违反了这一要求。考虑子类的情况， 将新值组件（ value component）添加到其父类中。换句话说，子类添加了一个信息，它影响了equals方法比较。让我们从一个简单不可变的二维整数类型Point类开始：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Point &#123;</span><br><span class="line">    private final int x;</span><br><span class="line">    private final int y;</span><br><span class="line"></span><br><span class="line">    public Point(int x, int y) &#123;</span><br><span class="line">        this.x = x;</span><br><span class="line">        this.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean equals(Object o) &#123;</span><br><span class="line">        if (!(o instanceof Point))</span><br><span class="line">            return false;</span><br><span class="line">        Point p = (Point) o;</span><br><span class="line">        return p.x == x &amp;&amp; p.y == y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...  // Remainder omitted</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设想继承这个类，将表示颜色的Color类添加到Point类中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class ColorPoint extends Point &#123;</span><br><span class="line">    private final Color color;</span><br><span class="line"></span><br><span class="line">    public ColorPoint(int x, int y, Color color) &#123;</span><br><span class="line">        super(x, y);</span><br><span class="line">        this.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...  // Remainder omitted</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>equals方法应该是什么样子?如果完全忽略，则实现是从Point类上继承的，颜色信息在equals方法比较中被忽略。虽然这并不违反equals约定，但这显然是不可接受的。假设你写了一个equals方法，它只在它的参数是另一个具有相同位置和颜色的ColorPoint实例时返回true：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Broken - violates symmetry!</span><br><span class="line">@Override public boolean equals(Object o) &#123;</span><br><span class="line">    if (!(o instanceof ColorPoint))</span><br><span class="line">        return false;</span><br><span class="line">    return super.equals(o) &amp;&amp; ((ColorPoint) o).color == color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当你比较Point对象和ColorPoint对象时，可以会得到不同的结果，反之亦然。前者的比较忽略了颜色属性，而后者的比较会一直返回 false，因为参数的类型是错误的。为了让问题更加具体，我们创建一个Point对象和ColorPoint对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Point p = new Point(1, 2);</span><br><span class="line">ColorPoint cp = new ColorPoint(1, 2, Color.RED);</span><br></pre></td></tr></table></figure><p>p.equals(cp)返回 true，但是 cp.equals(p)返回 false。你可能想使用ColorPoint.equals 通过混合比较的方式来解决这个问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean equals(Object o) &#123;</span><br><span class="line">    if (!(o instanceof Point))</span><br><span class="line">        return false;</span><br><span class="line"></span><br><span class="line">    // If o is a normal Point, do a color-blind comparison</span><br><span class="line">    if (!(o instanceof ColorPoint))</span><br><span class="line">        return o.equals(this);</span><br><span class="line"></span><br><span class="line">    // o is a ColorPoint; do a full comparison</span><br><span class="line">    return super.equals(o) &amp;&amp; ((ColorPoint) o).color == color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法确实提供了对称性，但是丧失了传递性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ColorPoint p1 = new ColorPoint(1, 2, Color.RED);</span><br><span class="line">Point p2 = new Point(1, 2);</span><br><span class="line">ColorPoint p3 = new ColorPoint(1, 2, Color.BLUE);</span><br></pre></td></tr></table></figure><p>现在，<code>p1.equals(p2)</code>和<code>p2.equals(p3)</code> 返回了 true，但是<code>p1.equals(p3)</code>却返回了 false，很明显违背了传递性的要求。前两个比较都是不考虑颜色信息的，而第三个比较时却包含颜色信息。</p><p>此外，这种方法可能导致无限递归：假设有两个Point的子类，比如ColorPoint和SmellPoint，每个都有这种equals方法。 然后调用<code>myColorPoint.equals(mySmellPoint)</code>将抛出一个StackOverflowError异常。</p><p>那么解决方案是什么？ 事实证明，这是面向对象语言中关于等价关系的一个基本问题。 除非您愿意放弃面向对象抽象的好处，否则无法继承可实例化的类，并在保留 equals 约定的同时添加一个值组件。</p><p>你可能听说过，可以继承一个可实例化的类并添加一个值组件，同时通过在equals方法中使用一个getClass测试代替instanceof测试来保留equals约定：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean equals(Object o) &#123;</span><br><span class="line">    if (o == null || o.getClass() != getClass())</span><br><span class="line">        return false;</span><br><span class="line">    Point p = (Point) o;</span><br><span class="line">    return p.x == x &amp;&amp; p.y == y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只有当对象具有相同的实现类时，才会产生相同的效果。这看起来可能不是那么糟糕，但是结果是不可接受的:一个Point类子类的实例仍然是一个Point的实例，它仍然需要作为一个Point来运行，但是如果你采用这个方法，就会失败！假设我们要写一个方法来判断一个Point 对象是否在unitCircle集合中。我们可以这样做：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private static final Set&lt;Point&gt; unitCircle = Set.of(</span><br><span class="line">        new Point( 1,  0), new Point( 0,  1),</span><br><span class="line">        new Point(-1,  0), new Point( 0, -1));</span><br><span class="line"></span><br><span class="line">public static boolean onUnitCircle(Point p) &#123;</span><br><span class="line">    return unitCircle.contains(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然这可能不是实现功能的最快方法，但它可以正常工作。假设以一种不添加值组件的简单方式继承 Point 类，比如让它的构造方法跟踪记录创建了多少实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class CounterPoint extends Point &#123;</span><br><span class="line">    private static final AtomicInteger counter =</span><br><span class="line">            new AtomicInteger();</span><br><span class="line"></span><br><span class="line">    public CounterPoint(int x, int y) &#123;</span><br><span class="line">        super(x, y);</span><br><span class="line">        counter.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int numberCreated() &#123;</span><br><span class="line">        return counter.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>里氏替代原则（ Liskov substitution principle）指出，任何类型的重要属性都应该适用于所有的子类型，因此任何为这种类型编写的方法都应该在其子类上同样适用[Liskov87]。 这是我们之前声明的一个正式陈述，即Point的子类（如CounterPoint）仍然是一个Point，必须作为一个Point类来看待。 但是，假设我们将一个CounterPoint对象传递给onUnitCircle方法。 如果Point类使用基于getClass的equals方法，则无论CounterPoint实例的x和y坐标如何，onUnitCircle方法都将返回false。 这是因为大多数集合（包括onUnitCircle方法使用的HashSet）都使用equals方法来测试是否包含元素，并且CounterPoint实例并不等于任何Point实例。 但是，如果在Point上使用了适当的基于<code>instanceof</code>的equals方法，则在使用CounterPoint实例呈现时，同样的onUnitCircle方法可以正常工作。</p><p>虽然没有令人满意的方法来继承一个可实例化的类并添加一个值组件，但是有一个很好的变通方法：按照条目18的建议，“优先使用组合而不是继承”。取代继承Point类的ColorPoint类，可以在ColorPoint类中定义一个私有Point属性，和一个公共的试图（view）（条目6）方法，用来返回具有相同位置的ColorPoint对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// Adds a value component without violating the equals contract</span><br><span class="line">public class ColorPoint &#123;</span><br><span class="line">    private final Point point;</span><br><span class="line">    private final Color color;</span><br><span class="line"></span><br><span class="line">    public ColorPoint(int x, int y, Color color) &#123;</span><br><span class="line">        point = new Point(x, y);</span><br><span class="line">        this.color = Objects.requireNonNull(color);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * Returns the point-view of this color point.</span><br><span class="line">     */</span><br><span class="line">    public Point asPoint() &#123;</span><br><span class="line">        return point;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override public boolean equals(Object o) &#123;</span><br><span class="line">        if (!(o instanceof ColorPoint))</span><br><span class="line">            return false;</span><br><span class="line">        ColorPoint cp = (ColorPoint) o;</span><br><span class="line">        return cp.point.equals(point) &amp;&amp; cp.color.equals(color);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...    // Remainder omitted</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java平台类库中有一些类可以继承可实例化的类并添加一个值组件。 例如，<code>java.sql.Timestamp</code>继承了<code>java.util.Date</code>并添加了一个nanoseconds字段。 Timestamp的等价equals确实违反了对称性，并且如果Timestamp和Date对象在同一个集合中使用，或者以其他方式混合使用，则可能导致不稳定的行为。 Timestamp类有一个免责声明，告诫程序员不要混用Timestamp和Date。 虽然只要将它们分开使用就不会遇到麻烦，但没有什么可以阻止你将它们混合在一起，并且由此产生的错误可能很难调试。 Timestamp类的这种行为是一个错误，不应该被仿效。</p><p>你可以将值组件添加到抽象类的子类中，而不会违反equals约定。这对于通过遵循第23个条目中“优先考虑类层级（class hierarchies）来代替标记类（tagged classes）”中的建议而获得的类层级，是非常重要的。例如，可以有一个没有值组件的抽象类Shape，子类Circle有一个radius属性，另一个子类Rectangle包含length和width属性 。 只要不直接创建父类实例，就不会出现前面所示的问题。</p><p>一致性——equals 约定的第四个要求是，如果两个对象是相等的，除非一个（或两个）对象被修改了， 那么它们必须始终保持相等。 换句话说，可变对象可以在不同时期可以与不同的对象相等，而不可变对象则不会。 当你写一个类时，要认真思考它是否应该设计为不可变的（条目 17）。 如果你认为应该这样做，那么确保你的equals方法强制执行这样的限制：相等的对象永远相等，不相等的对象永远都不会相等。</p><p>不管一个类是不是不可变的，都不要写一个依赖于不可靠资源的equals方法。 如果违反这一禁令，满足一致性要求是非常困难的。 例如，java.net.URL类中的equals方法依赖于与URL关联的主机的IP地址的比较。 将主机名转换为IP地址可能需要访问网络，并且不能保证随着时间的推移会产生相同的结果。 这可能会导致URL类的equals方法违反equals 约定，并在实践中造成问题。 URL类的equals方法的行为是一个很大的错误，不应该被效仿。 不幸的是，由于兼容性的要求，它不能改变。 为了避免这种问题，equals方法应该只对内存驻留对象执行确定性计算。</p><p>非空性（Non-nullity）——最后equals 约定的要求没有官方的名称，所以我冒昧地称之为“非空性”。意思是说说所有的对象都必须不等于 null。虽然很难想象在调用 <code>o.equals(null)</code>的响应中意外地返回true，但不难想象不小心抛出<code>NullPointerException</code>异常的情况。通用的约定禁止抛出这样的异常。许多类中的 equals方法都会明确阻止对象为null的情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override public boolean equals(Object o) &#123;</span><br><span class="line">    if (o == null)</span><br><span class="line">        return false;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个判断是不必要的。 为了测试它的参数是否相等，equals方法必须首先将其参数转换为合适类型，以便调用访问器或允许访问的属性。 在执行类型转换之前，该方法必须使用instanceof运算符来检查其参数是否是正确的类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Override public boolean equals(Object o) &#123;</span><br><span class="line">    if (!(o instanceof MyType))</span><br><span class="line">        return false;</span><br><span class="line">    MyType mt = (MyType) o;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果此类型检查漏掉，并且equals方法传递了错误类型的参数，那么equals方法将抛出<code>ClassCastException</code>异常，这违反了equals约定。 但是，如果第一个操作数为 null，则指定instanceof运算符返回false，而不管第二个操作数中出现何种类型[JLS，15.20.2]。 因此，如果传入null，类型检查将返回false，因此不需要 明确的 null检查。</p><p>综合起来，以下是编写高质量equals方法的配方（recipe）：</p><ol><li>使用= =运算符检查参数是否为该对象的引用。如果是，返回true。这只是一种性能优化，但是如果这种比较可能很昂贵的话，那就值得去做。</li><li>使用<code>instanceof</code>运算符来检查参数是否具有正确的类型。 如果不是，则返回false。 通常，正确的类型是equals方法所在的那个类。 有时候，改类实现了一些接口。 如果类实现了一个接口，该接口可以改进 equals约定以允许实现接口的类进行比较，那么使用接口。 集合接口（如Set，List，Map和Map.Entry）具有此特性。</li><li>参数转换为正确的类型。因为转换操作在instanceof中已经处理过，所以它肯定会成功。</li><li>对于类中的每个“重要”的属性，请检查该参数属性是否与该对象对应的属性相匹配。如果所有这些测试成功，返回true，否则返回false。如果步骤2中的类型是一个接口，那么必须通过接口方法访问参数的属性;如果类型是类，则可以直接访问属性，这取决于属性的访问权限。</li></ol><p>对于类型为非float或double的基本类型，使用= =运算符进行比较；对于对象引用属性，递归地调用equals方法；对于float 基本类型的属性，使用静态<code>Float.compare(float, float)</code>方法；对于double 基本类型的属性，使用<code>Double.compare(double, double)</code>方法。由于存在<code>Float.NaN</code>，<code>-0.0f</code>和类似的double类型的值，所以需要对float和double属性进行特殊的处理；有关详细信息，请参阅JLS 15.21.1或Float.equals方法的详细文档。 虽然你可以使用静态方法Float.equals和Double.equals方法对float和double基本类型的属性进行比较，这会导致每次比较时发生自动装箱，引发非常差的性能。 对于数组属性，将这些准则应用于每个元素。 如果数组属性中的每个元素都很重要，请使用其中一个重载的Arrays.equals方法。</p><p>某些对象引用的属性可能合法地包含null。 为避免出现NullPointerException异常，请使用静态方法 Objects.equals(Object, Object)检查这些属性是否相等。</p><p>对于一些类，例如上的<code>CaseInsensitiveString</code>类，属性比较相对于简单的相等性测试要复杂得多。在这种情况下，你想要保存属性的一个规范形式（ canonical form），这样 equals 方法就可以基于这个规范形式去做开销很小的精确比较，来取代开销很大的非标准比较。这种方式其实最适合不可变类（条目 17）。一旦对象发生改变，一定要确保把对应的规范形式更新到最新。</p><p>equals方法的性能可能受到属性比较顺序的影响。 为了获得最佳性能，你应该首先比较最可能不同的属性，开销比较小的属性，或者最好是两者都满足（derived fields）。 你不要比较不属于对象逻辑状态的属性，例如用于同步操作的lock 属性。 不需要比较可以从“重要属性”计算出来的派生属性，但是这样做可以提高equals方法的性能。 如果派生属性相当于对整个对象的摘要描述，比较这个属性将节省在比较失败时再去比较实际数据的开销。 例如，假设有一个Polygon类，并缓存该区域。 如果两个多边形的面积不相等，则不必费心比较它们的边和顶点。</p><p>当你完成编写完equals方法时，问你自己三个问题：它是对称的吗?它是传递吗?它是一致的吗?除此而外，编写单元测试加以排查，除非使用AutoValue框架(第49页)来生成equals方法，在这种情况下可以安全地省略测试。如果持有的属性失败，找出原因，并相应地修改equals方法。当然，equals方法也必须满足其他两个属性(自反性和非空性)，但这两个属性通常都会满足。</p><p>在下面这个简单的<code>PhoneNumber</code>类中展示了根据之前的配方构建的equals方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public final class PhoneNumber &#123;</span><br><span class="line"></span><br><span class="line">    private final short areaCode, prefix, lineNum;</span><br><span class="line"></span><br><span class="line">    public PhoneNumber(int areaCode, int prefix, int lineNum) &#123;</span><br><span class="line">        this.areaCode = rangeCheck(areaCode, 999, &quot;area code&quot;);</span><br><span class="line">        this.prefix = rangeCheck(prefix, 999, &quot;prefix&quot;);</span><br><span class="line">        this.lineNum = rangeCheck(lineNum, 9999, &quot;line num&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static short rangeCheck(int val, int max, String arg) &#123;</span><br><span class="line">        if (val &lt; 0 || val &gt; max)</span><br><span class="line">            throw new IllegalArgumentException(arg + &quot;: &quot; + val);</span><br><span class="line">        </span><br><span class="line">        return (short) val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean equals(Object o) &#123;</span><br><span class="line">        if (o == this)</span><br><span class="line">            return true;</span><br><span class="line">        if (!(o instanceof PhoneNumber))</span><br><span class="line">            return false;</span><br><span class="line"></span><br><span class="line">        PhoneNumber pn = (PhoneNumber) o;</span><br><span class="line"></span><br><span class="line">        return pn.lineNum == lineNum &amp;&amp; pn.prefix == prefix</span><br><span class="line">                &amp;&amp; pn.areaCode == areaCode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ... // Remainder omitted</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是一些最后提醒：</p><ol><li><p><strong>当重写equals方法时，同时也要重写hashCode方法（条目 11）。</strong></p></li><li><p><strong>不要让equals方法试图太聪明</strong>。如果只是简单地测试用于相等的属性，那么要遵守equals约定并不困难。如果你在寻找相等方面过于激进，那么很容易陷入麻烦。一般来说，考虑到任何形式的别名通常是一个坏主意。例如，File类不应该试图将引用的符号链接等同于同一文件对象。幸好 File 类并没这么做。</p></li><li><p><strong>在equal 时方法声明中，不要将参数Object替换成其他类型</strong>。对于程序员来说，编写一个看起来像这样的equals方法并不少见，然后花上几个小时苦苦思索为什么它不能正常工作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// Broken - parameter type must be Object!public boolean equals(MyClass o) &#123;   </span><br><span class="line"> …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题在于这个方法并没有重写Object.equals方法，它的参数是Object类型的，这样写只是重载了 equals 方法（Item 52）。 即使除了正常的方法之外，提供这种“强类型”的equals方法也是不可接受的，因为它可能会导致子类中的Override注解产生误报，提供不安全的错觉。<br>在这里，使用Override注解会阻止你犯这个错误(条目 40)。这个equals方法不会编译，错误消息会告诉你到底错在哪里：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Still broken, but won’t compile</span><br><span class="line">@Override public boolean equals(MyClass o) &#123;</span><br><span class="line">…</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写和测试equals(和hashCode)方法很繁琐，生的代码也很普通。替代手动编写和测试这些方法的优雅的手段是，使用谷歌AutoValue开源框架，该框架自动为你生成这些方法，只需在类上添加一个注解即可。在大多数情况下，AutoValue框架生成的方法与你自己编写的方法本质上是相同的。</p></li></ol><p>很多 IDE（例如 Eclipse，NetBeans，IntelliJ IDEA 等）也有生成equals和hashCode方法的功能，但是生成的源代码比使用AutoValue框架的代码更冗长、可读性更差，不会自动跟踪类中的更改，因此需要进行测试。这就是说，使用IDE工具生成equals(和hashCode)方法通常比手动编写它们更可取，因为IDE工具不会犯粗心大意的错误，而人类则会。</p><p>总之，除非必须：在很多情况下，不要重写equals方法，从Object继承的实现完全是你想要的。 如果你确实重写了equals 方法，那么一定要比较这个类的所有重要属性，并且以保护前面equals约定里五个规定的方式去比较。</p><h2 id="11-重写equals方法时同时也要重写hashcode方法"><a href="#11-重写equals方法时同时也要重写hashcode方法" class="headerlink" title="11. 重写equals方法时同时也要重写hashcode方法"></a>11. 重写equals方法时同时也要重写hashcode方法</h2><p><strong>在每个类中，在重写 equals 方法的时侯，一定要重写 hashcode 方法</strong>。如果不这样做，你的类违反了hashCode的通用约定，这会阻止它在HashMap和HashSet这样的集合中正常工作。根据 Object 规范，以下时具体约定。</p><ol><li>当在一个应用程序执行过程中，如果在equals方法比较中没有修改任何信息，在一个对象上重复调用hashCode方法时，它必须始终返回相同的值。从一个应用程序到另一个应用程序的每一次执行返回的值可以是不一致的。</li><li>如果两个对象根据equals(Object)方法比较是相等的，那么在两个对象上调用hashCode就必须产生的结果是相同的整数。</li><li>如果两个对象根据equals(Object)方法比较并不相等，则不要求在每个对象上调用hashCode都必须产生不同的结果。 但是，程序员应该意识到，为不相等的对象生成不同的结果可能会提高散列表（hash tables）的性能。</li></ol><p><strong>当无法重写hashCode时，所违反第二个关键条款是：相等的对象必须具有相等的哈希码（ hash codes）</strong>。根据类的equals方法，两个不同的实例可能在逻辑上是相同的，但是对于Object 类的hashCode方法，它们只是两个没有什么共同之处的对象。因此， Object 类的hashCode方法返回两个看似随机的数字，而不是按约定要求的两个相等的数字。</p><p>举例说明，假设你使用条目 10中的<code>PhoneNumber</code>类的实例做为HashMap的键（key）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;PhoneNumber, String&gt; m = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">m.put(new PhoneNumber(707, 867, 5309), &quot;Jenny&quot;);</span><br></pre></td></tr></table></figure><p>你可能期望<code>m.get(new PhoneNumber(707, 867, 5309))</code>方法返回<code>Jenny</code>字符串，但实际上，返回了 null。注意，这里涉及到两个<code>PhoneNumber</code>实例：一个实例插入到 HashMap 中，另一个作为判断相等的实例用来检索。<code>PhoneNumber</code>类没有重写 hashCode 方法导致两个相等的实例返回了不同的哈希码，违反了 hashCode 约定。put 方法把<code>PhoneNumber</code>实例保存在了一个哈希桶（ hash bucket）中，但get方法却是从不同的哈希桶中去查找，即使恰好两个实例放在同一个哈希桶中，get 方法几乎肯定也会返回 null。因为HashMap 做了优化，缓存了与每一项（entry）相关的哈希码，如果哈希码不匹配，则不会检查对象是否相等了。</p><p>解决这个问题很简单，只需要为<code>PhoneNumber</code>类重写一个合适的 hashCode 方法。hashCode方法是什么样的？写一个不规范的方法的是很简单的。以下示例，虽然永远是合法的，但绝对不能这样使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// The worst possible legal hashCode implementation - never use!</span><br><span class="line"></span><br><span class="line">@Override public int hashCode() &#123; return 42; &#125;</span><br></pre></td></tr></table></figure><p>这是合法的，因为它确保了相等的对象具有相同的哈希码。这很糟糕，因为它确保了每个对象都有相同的哈希码。因此，每个对象哈希到同一个桶中，哈希表退化为链表。应该在线性时间内运行的程序，运行时间变成了平方级别。对于数据很大的哈希表而言，会影响到能够正常工作。</p><p>一个好的 hash 方法趋向于为不相等的实例生成不相等的哈希码。这也正是 hashCode 约定中第三条的表达。理想情况下，hash 方法为集合中不相等的实例均匀地分配int 范围内的哈希码。实现这种理想情况可能是困难的。 幸运的是，要获得一个合理的近似的方式并不难。 以下是一个简单的配方：</p><ol><li><p>声明一个 int 类型的变量result，并将其初始化为对象中第一个重要属性<code>c</code>的哈希码，如下面步骤2.a中所计算的那样。（回顾条目10，重要的属性是影响比较相等的领域。）</p></li><li><p>对于对象中剩余的重要属性<code>f</code>，请执行以下操作：</p><p>a. 比较属性<code>f</code>与属性<code>c</code>的 int 类型的哈希码：<br>– i. 如果这个属性是基本类型的，使用<code>Type.hashCode(f)</code>方法计算，其中<code>Type</code>类是对应属性 f 基本类型的包装类。<br>– ii 如果该属性是一个对象引用，并且该类的equals方法通过递归调用equals来比较该属性，并递归地调用hashCode方法。 如果需要更复杂的比较，则计算此字段的“范式（“canonical representation）”，并在范式上调用hashCode。 如果该字段的值为空，则使用0（也可以使用其他常数，但通常来使用0表示）。<br>– iii 如果属性<code>f</code>是一个数组，把它看作每个重要的元素都是一个独立的属性。 也就是说，通过递归地应用这些规则计算每个重要元素的哈希码，并且将每个步骤2.b的值合并。 如果数组没有重要的元素，则使用一个常量，最好不要为0。如果所有元素都很重要，则使用<code>Arrays.hashCode</code>方法。</p><p>b. 将步骤2.a中属性<code>c</code>计算出的哈希码合并为如下结果：<code>result = 31 * result + c;</code></p></li><li><p>返回 result 值。</p></li></ol><p>当你写完hashCode方法后，问自己是否相等的实例有相同的哈希码。 编写单元测试来验证你的直觉（除非你使用AutoValue框架来生成你的equals和hashCode方法，在这种情况下，你可以放心地忽略这些测试）。 如果相同的实例有不相等的哈希码，找出原因并解决问题。</p><p>可以从哈希码计算中排除派生属性（derived fields）。换句话说，如果一个属性的值可以根据参与计算的其他属性值计算出来，那么可以忽略这样的属性。您必须排除在equals比较中没有使用的任何属性，否则可能会违反hashCode约定的第二条。</p><p>步骤2.b中的乘法计算结果取决于属性的顺序，如果类中具有多个相似属性，则产生更好的散列函数。 例如，如果乘法计算从一个String散列函数中被省略，则所有的字符将具有相同的散列码。 之所以选择31，因为它是一个奇数的素数。 如果它是偶数，并且乘法溢出，信息将会丢失，因为乘以2相当于移位。 使用素数的好处不太明显，但习惯上都是这么做的。 31的一个很好的特性，是在一些体系结构中乘法可以被替换为移位和减法以获得更好的性能：<code>31 * i ==（i &lt;&lt; 5） - i</code>。 现代JVM可以自动进行这种优化。</p><p>让我们把上述办法应用到PhoneNumber类中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// Typical hashCode method</span><br><span class="line"></span><br><span class="line">@Override public int hashCode() &#123;</span><br><span class="line"></span><br><span class="line">    int result = Short.hashCode(areaCode);</span><br><span class="line"></span><br><span class="line">    result = 31 * result + Short.hashCode(prefix);</span><br><span class="line"></span><br><span class="line">    result = 31 * result + Short.hashCode(lineNum);</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为这个方法返回一个简单的确定性计算的结果，它的唯一的输入是<code>PhoneNumber</code>实例中的三个重要的属性，所以显然相等的<code>PhoneNumber</code>实例具有相同的哈希码。 实际上，这个方法是<code>PhoneNumber</code>的一个非常好的hashCode实现，与Java平台类库中的实现一样。 它很简单，速度相当快，并且合理地将不相同的电话号码分散到不同的哈希桶中。</p><p>虽然在这个项目的方法产生相当好的哈希函数，但并不是最先进的。 它们的质量与Java平台类库的值类型中找到的哈希函数相当，对于大多数用途来说都是足够的。 如果真的需要哈希函数而不太可能产生碰撞，请参阅Guava框架的的<a href="http://com.google.common.hash.hashing/" target="_blank" rel="noopener">com.google.common.hash.Hashing</a> [Guava]方法。</p><p><code>Objects</code>类有一个静态方法，它接受任意数量的对象并为它们返回一个哈希码。 这个名为hash的方法可以让你编写一行hashCode方法，其质量与根据这个项目中的上面编写的方法相当。 不幸的是，它们的运行速度更慢，因为它们需要创建数组以传递可变数量的参数，以及如果任何参数是基本类型，则进行装箱和取消装箱。 这种哈希函数的风格建议仅在性能不重要的情况下使用。 以下是使用这种技术编写的<code>PhoneNumber</code>的哈希函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// One-line hashCode method - mediocre performance</span><br><span class="line"></span><br><span class="line">@Override public int hashCode() &#123;</span><br><span class="line"></span><br><span class="line">   return Objects.hash(lineNum, prefix, areaCode);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一个类是不可变的，并且计算哈希码的代价很大，那么可以考虑在对象中缓存哈希码，而不是在每次请求时重新计算哈希码。 如果你认为这种类型的大多数对象将被用作哈希键，那么应该在创建实例时计算哈希码。 否则，可以选择在首次调用hashCode时延迟初始化（lazily initialize）哈希码。 需要注意确保类在存在延迟初始化属性的情况下保持线程安全（项目83）。 <code>PhoneNumber</code>类不适合这种情况，但只是为了展示它是如何完成的。 请注意，属性hashCode的初始值（在本例中为0）不应该是通常创建的实例的哈希码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// hashCode method with lazily initialized cached hash code</span><br><span class="line"></span><br><span class="line">private int hashCode; // Automatically initialized to 0</span><br><span class="line"></span><br><span class="line">@Override public int hashCode() &#123;</span><br><span class="line"></span><br><span class="line">    int result = hashCode;</span><br><span class="line"></span><br><span class="line">    if (result == 0) &#123;</span><br><span class="line"></span><br><span class="line">        result = Short.hashCode(areaCode);</span><br><span class="line"></span><br><span class="line">        result = 31 * result + Short.hashCode(prefix);</span><br><span class="line"></span><br><span class="line">        result = 31 * result + Short.hashCode(lineNum);</span><br><span class="line"></span><br><span class="line">        hashCode = result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>不要试图从哈希码计算中排除重要的属性来提高性能</strong>。 由此产生的哈希函数可能运行得更快，但其质量较差可能会降低哈希表的性能，使其无法使用。 具体来说，哈希函数可能会遇到大量不同的实例，这些实例主要在你忽略的区域中有所不同。 如果发生这种情况，哈希函数将把所有这些实例映射到少许哈希码上，而应该以线性时间运行的程序将会运行平方级的时间。</p><p>这不仅仅是一个理论问题。 在Java 2之前，String 类哈希函数在整个字符串中最多使用16个字符，从第一个字符开始，在整个字符串中均匀地选取。 对于大量的带有层次名称的集合（如URL），此功能正好显示了前面描述的病态行为。</p><p><strong>不要为hashCode返回的值提供详细的规范，因此客户端不能合理地依赖它； 你可以改变它的灵活性</strong>。 Java类库中的许多类（例如String和Integer）都将hashCode方法返回的确切值指定为实例值的函数。 这不是一个好主意，而是一个我们不得不忍受的错误：它妨碍了在未来版本中改进哈希函数的能力。 如果未指定细节并在散列函数中发现缺陷，或者发现了更好的哈希函数，则可以在后续版本中对其进行更改。</p><p>总之，每次重写equals方法时都必须重写hashCode方法，否则程序将无法正常运行。你的hashCode方法必须遵从Object类指定的常规约定，并且必须执行合理的工作，将不相等的哈希码分配给不相等的实例。如果使用第51页的配方，这很容易实现。如条目 10所述，AutoValue框架为手动编写equals和hashCode方法提供了一个很好的选择，IDE也提供了一些这样的功能。</p><h2 id="12-始终重写-toString-方法"><a href="#12-始终重写-toString-方法" class="headerlink" title="12. 始终重写 toString 方法"></a>12. 始终重写 toString 方法</h2><p>虽然Object类提供了toString方法的实现，但它返回的字符串通常不是你的类的用户想要看到的。 它由类名后跟一个“at”符号（@）和哈希码的无符号十六进制表示组成，例如<code>PhoneNumber@163b91</code>。 toString的通用约定要求，返回的字符串应该是“一个简洁但内容丰富的表示，对人们来说是很容易阅读的”。虽然可以认为<code>PhoneNumber@163b91</code>简洁易读，但相比于<code>707-867-5309</code>，但并不是很丰富 。 toString通用约定“建议所有的子类重写这个方法”。好的建议，的确如此！</p><p>虽然它并不像遵守equals和hashCode约定那样重要(条目 10和11)，但是提供一个良好的toString实现使你的类更易于使用，并对使用此类的系统更易于调试。当对象被传递到println、printf、字符串连接操作符或断言，或者由调试器打印时，toString方法会自动被调用。即使你从不调用对象上的toString，其他人也可以。例如，对对象有引用的组件可能包含在日志错误消息中对象的字符串表示。如果未能重写toString，则消息可能是无用的。</p><p>如果为<code>PhoneNumber</code>提供了一个很好的toString方法，那么生成一个有用的诊断消息就像下面这样简单：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(&quot;Failed to connect to &quot; + phoneNumber);</span><br></pre></td></tr></table></figure><p>程序员将以这种方式生成诊断消息，不管你是否重写toString，但是除非你这样做，否则这些消息将不会有用。 提供一个很好的toString方法的好处不仅包括类的实例，同样有益于包含实例引用的对象，特别是集合。 打印map 对象时你会看到哪一个，<code>{Jenny=PhoneNumber@163b91}</code>还是<code>{Jenny=707-867-5309}</code>?</p><p>实际上，toString方法应该返回对象中包含的所有需要关注的信息，如电话号码示例中所示。 如果对象很大或者包含不利于字符串表示的状态，这是不切实际的。 在这种情况下，toString应该返回一个摘要，如 <code>Manhattan residential phone directory (1487536 listings)</code>或线程<code>[main，5，main]</code>。 理想情况下，字符串应该是不言自明的（线程示例并没有遵守这点）。 如果未能将所有对象的值得关注的信息包含在字符串表示中，则会导致一个特别烦人的处罚：测试失败报告如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Assertion failure: expected &#123;abc, 123&#125;, but was &#123;abc, 123&#125;.</span><br></pre></td></tr></table></figure><p>实现toString方法时，必须做出的一个重要决定是：在文档中指定返回值的格式。 建议你对值类进行此操作，例如电话号码或矩阵类。 指定格式的好处是它可以作为标准的，明确的，可读的对象表示。 这种表示形式可以用于输入、输出以及持久化可读性的数据对象，如CSV文件。 如果指定了格式，通常提供一个匹配的静态工厂或构造方法，是个好主意，所以程序员可以轻松地在对象和字符串表示之间来回转换。 Java平台类库中的许多值类都采用了这种方法，包括BigInteger，BigDecimal和大部分基本类型包装类。</p><p>指定toString返回值的格式的缺点是，假设你的类被广泛使用，一旦指定了格式，就会终身使用。程序员将编写代码来解析表达式，生成它，并将其嵌入到持久数据中。如果在将来的版本中更改了格式的表示，那么会破坏他们的代码和数据，并且还会抱怨。但通过选择不指定格式，就可以保留在后续版本中添加信息或改进格式的灵活性。</p><p>无论是否决定指定格式，你都应该清楚地在文档中表明你的意图。如果指定了格式，则应该这样做。例如，这里有一个toString方法，该方法在条目 11中使用<code>PhoneNumber</code>类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Returns the string representation of this phone number.</span><br><span class="line"> * The string consists of twelve characters whose format is</span><br><span class="line"> * &quot;XXX-YYY-ZZZZ&quot;, where XXX is the area code, YYY is the</span><br><span class="line"> * prefix, and ZZZZ is the line number. Each of the capital</span><br><span class="line"> * letters represents a single decimal digit.</span><br><span class="line"> *</span><br><span class="line"> * If any of the three parts of this phone number is too small</span><br><span class="line"> * to fill up its field, the field is padded with leading zeros.</span><br><span class="line"> * For example, if the value of the line number is 123, the last</span><br><span class="line"> * four characters of the string representation will be &quot;0123&quot;.</span><br><span class="line"> */</span><br><span class="line">@Override public String toString() &#123;</span><br><span class="line">    return String.format(&quot;%03d-%03d-%04d&quot;,</span><br><span class="line">            areaCode, prefix, lineNum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你决定不指定格式，那么文档注释应该是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Returns a brief description of this potion. The exact details</span><br><span class="line"> * of the representation are unspecified and subject to change,</span><br><span class="line"> * but the following may be regarded as typical:</span><br><span class="line"> *</span><br><span class="line"> * &quot;[Potion #9: type=love, smell=turpentine, look=india ink]&quot;</span><br><span class="line"> */</span><br><span class="line">@Override public String toString() &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>在阅读了这条注释之后，那些生成依赖于格式细节的代码或持久化数据的程序员，在这种格式发生改变的时候，只能怪他们自己。</p><p>无论是否指定格式，都可以通过编程方式访问toString返回的值中包含的信息。 例如，<code>PhoneNumber</code>类应该包含 areaCode, prefix, lineNum这三个属性。 如果不这样做，就会强迫程序员需要这些信息来解析字符串。 除了降低性能和程序员做不必要的工作之外，这个过程很容易出错，如果改变格式就会中断，并导致脆弱的系统。 由于未能提供访问器，即使已指定格式可能会更改，也可以将字符串格式转换为事实上的API。</p><p>在静态工具类（条目 4）中编写toString方法是没有意义的。 你也不应该在大多数枚举类型（条目 34）中写一个toString方法，因为Java为你提供了一个非常好的方法。 但是，你应该在任何抽象类中定义toString方法，该类的子类共享一个公共字符串表示形式。 例如，大多数集合实现上的toString方法都是从抽象集合类继承的。</p><p>Google的开放源代码AutoValue工具在条目 10中讨论过，它为你生成一个toString方法，就像大多数IDE工具一样。 这些方法非常适合告诉你每个属性的内容，但并不是专门针对类的含义。 因此，例如，为我们的<code>PhoneNumber</code>类使用自动生成的toString方法是不合适的（因为电话号码具有标准的字符串表示形式），但是对于我们的<code>Potion</code>类来说，这是完全可以接受的。 也就是说，自动生成的toString方法比从Object继承的方法要好得多，它不会告诉你对象的值。</p><p>回顾一下，除非父类已经这样做了，否则在每个实例化的类中重写Object的toString实现。 它使得类更加舒适地使用和协助调试。 toString方法应该以一种美观的格式返回对象的简明有用的描述。</p><h2 id="13-谨慎地重写-clone-方法"><a href="#13-谨慎地重写-clone-方法" class="headerlink" title="13. 谨慎地重写 clone 方法"></a>13. 谨慎地重写 clone 方法</h2><p>Cloneable接口的目的是作为一个mixin接口(条目 20)，公布这样的类允许克隆。不幸的是，它没有达到这个目的。它的主要缺点是缺少clone方法，而Object的clone方法是受保护的。你不能，不借助反射(条目 65)，仅仅因为它实现了Cloneable接口，就调用对象上的 clone 方法。即使是反射调用也可能失败，因为不能保证对象具有可访问的 clone方法。尽管存在许多缺陷，该机制在合理的范围内使用，所以理解它是值得的。这个条目告诉你如何实现一个行为良好的 clone方法，在适当的时候讨论这个方法，并提出替代方案。</p><p>既然Cloneable接口不包含任何方法，那它用来做什么？ 它决定了Object的受保护的clone 方法实现的行为：如果一个类实现了Cloneable接口，那么Object的clone方法将返回该对象的逐个属性（field-by-field）拷贝；否则会抛出<code>CloneNotSupportedException</code>异常。这是一个非常反常的接口使用，而不应该被效仿。 通常情况下，实现一个接口用来表示可以为客户做什么。但对于Cloneable接口，它会修改父类上受保护方法的行为。</p><p>虽然规范并没有说明，但在实践中，实现Cloneable接口的类希望提供一个正常运行的公共 clone方法。为了实现这一目标，该类及其所有父类必须遵循一个复杂的、不可执行的、稀疏的文档协议。由此产生的机制是脆弱的、危险的和不受语言影响的（extralinguistic）：它创建对象而不需要调用构造方法。</p><p>clone方法的通用规范很薄弱的。 以下内容是从 Object 规范中复制出来的：</p><p>创建并返回此对象的副本。 “复制（copy）”的确切含义可能取决于对象的类。 一般意图是，对于任何对象x，表达式<code>x.clone() != x</code>返回 true，并且<code>x.clone().getClass() == x.getClass()</code>也返回 true，但它们不是绝对的要求，但通常情况下，<code>x.clone().equals(x)</code>返回 true，当然这个要求也不是绝对的。</p><p>根据约定，这个方法返回的对象应该通过调用<code>super.clone</code>方法获得的。 如果一个类和它的所有父类（Object除外）都遵守这个约定，情况就是如此，<code>x.clone().getClass() == x.getClass()</code>。</p><p>根据约定，返回的对象应该独立于被克隆的对象。 为了实现这种独立性，在返回对象之前，可能需要修改由super.clone返回的对象的一个或多个属性。</p><p>这种机制与构造方法链（chaining）很相似，只是它没有被强制执行；如果一个类的clone方法返回一个通过调用构造方法获得而不是通过调用super.clone的实例，那么编译器不会抱怨，但是如果一个类的子类调用了super.clone，那么返回的对象包含错误的类，从而阻止子类 clone 方法正常执行。如果一个类重写的 clone 方法是有 final 修饰的，那么这个约定可以被安全地忽略，因为子类不需要担心。但是，如果一个final类有一个不调用super.clone的clone方法，那么这个类没有理由实现Cloneable接口，因为它不依赖于Object的clone实现的行为。</p><p>假设你希望在一个类中实现Cloneable接口，它的父类提供了一个行为良好的 clone方法。首先调用super.clone。 得到的对象将是原始的完全功能的复制品。 在你的类中声明的任何属性将具有与原始属性相同的值。 如果每个属性包含原始值或对不可变对象的引用，则返回的对象可能正是你所需要的，在这种情况下，不需要进一步的处理。 例如，对于条目 11中的<code>PhoneNumber</code>类，情况就是这样，但是请注意，不可变类永远不应该提供clone方法，因为这只会浪费复制。 有了这个警告，以下是<code>PhoneNumber</code>类的clone方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// Clone method for class with no references to mutable state</span><br><span class="line">@Override public PhoneNumber clone() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        return (PhoneNumber) super.clone();</span><br><span class="line">    &#125; catch (CloneNotSupportedException e) &#123;</span><br><span class="line">        throw new AssertionError();  // Can&apos;t happen</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了使这个方法起作用，<code>PhoneNumber</code>的类声明必须被修改，以表明它实现了Cloneable接口。 虽然Object类的clone方法返回Object类，但是这个clone方法返回<code>PhoneNumber</code>类。 这样做是合法和可取的，因为Java支持协变返回类型。 换句话说，重写方法的返回类型可以是重写方法的返回类型的子类。 这消除了在客户端转换的需要。 在返回之前，我们必须将Object的super.clone的结果强制转换为<code>PhoneNumber</code>，但保证强制转换成功。</p><p>super.clone的调用包含在一个try-catch块中。 这是因为Object声明了它的clone方法来抛出<code>CloneNotSupportedException</code>异常，这是一个检查时异常。 由于<code>PhoneNumber</code>实现了Cloneable接口，所以我们知道调用super.clone会成功。 这里引用的需要表明<code>CloneNotSupportedException</code>应该是未被检查的（条目 71）。</p><p>如果对象包含引用可变对象的属性，则前面显示的简单clone实现可能是灾难性的。 例如，考虑条目 7中的Stack类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class Stack &#123;</span><br><span class="line"></span><br><span class="line">    private Object[] elements;</span><br><span class="line">    private int size = 0;</span><br><span class="line">    private static final int DEFAULT_INITIAL_CAPACITY = 16;</span><br><span class="line"></span><br><span class="line">    public Stack() &#123;</span><br><span class="line">        this.elements = new Object[DEFAULT_INITIAL_CAPACITY];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void push(Object e) &#123;</span><br><span class="line">        ensureCapacity();</span><br><span class="line">        elements[size++] = e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object pop() &#123;</span><br><span class="line">        if (size == 0)</span><br><span class="line">            throw new EmptyStackException();</span><br><span class="line">        Object result = elements[--size];</span><br><span class="line"></span><br><span class="line">        elements[size] = null; // Eliminate obsolete reference</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Ensure space for at least one more element.</span><br><span class="line">    private void ensureCapacity() &#123;</span><br><span class="line">        if (elements.length == size)</span><br><span class="line">            elements = Arrays.copyOf(elements, 2 * size + 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设你想让这个类可以克隆。 如果clone方法仅返回super.clone()调用的对象，那么生成的Stack实例在其size 属性中具有正确的值，但elements属性引用与原始Stack实例相同的数组。 修改原始实例将破坏克隆中的不变量，反之亦然。 你会很快发现你的程序产生了无意义的结果，或者抛出<code>NullPointerException</code>异常。</p><p>这种情况永远不会发生，因为调用Stack类中的唯一构造方法。 实际上，clone方法作为另一种构造方法; 必须确保它不会损坏原始对象，并且可以在克隆上正确建立不变量。 为了使Stack上的clone方法正常工作，它必须复制stack 对象的内部。 最简单的方法是对元素数组递归调用clone方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// Clone method for class with references to mutable state</span><br><span class="line">@Override public Stack clone() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        Stack result = (Stack) super.clone();</span><br><span class="line">        result.elements = elements.clone();</span><br><span class="line">        return result;</span><br><span class="line">    &#125; catch (CloneNotSupportedException e) &#123;</span><br><span class="line">        throw new AssertionError();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，我们不必将elements.clone的结果转换为Object[]数组。 在数组上调用clone会返回一个数组，其运行时和编译时类型与被克隆的数组相同。 这是复制数组的首选习语。 事实上，数组是clone 机制的唯一有力的用途。</p><p>还要注意，如果elements属性是final的，则以前的解决方案将不起作用，因为克隆将被禁止向该属性分配新的值。 这是一个基本的问题：像序列化一样，Cloneable体系结构与引用可变对象的final 属性的正常使用不兼容，除非可变对象可以在对象和其克隆之间安全地共享。 为了使一个类可以克隆，可能需要从一些属性中移除 final修饰符。</p><p>仅仅递归地调用clone方法并不总是足够的。 例如，假设您正在为哈希表编写一个clone方法，其内部包含一个哈希桶数组，每个哈希桶都指向“键-值”对链表的第一项。 为了提高性能，该类实现了自己的轻量级单链表，而没有使用java内部提供的java.util.LinkedList：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class HashTable implements Cloneable &#123;</span><br><span class="line">    private Entry[] buckets = ...;</span><br><span class="line">    private static class Entry &#123;</span><br><span class="line">        final Object key;</span><br><span class="line">        Object value;</span><br><span class="line">        Entry  next;</span><br><span class="line"></span><br><span class="line">        Entry(Object key, Object value, Entry next) &#123;</span><br><span class="line">            this.key   = key;</span><br><span class="line">            this.value = value;</span><br><span class="line">            this.next  = next;  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ... // Remainder omitted</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设你只是递归地克隆哈希桶数组，就像我们为Stack所做的那样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// Broken clone method - results in shared mutable state!</span><br><span class="line">@Override public HashTable clone() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        HashTable result = (HashTable) super.clone();</span><br><span class="line">        result.buckets = buckets.clone();</span><br><span class="line">        return result;</span><br><span class="line">    &#125; catch (CloneNotSupportedException e) &#123;</span><br><span class="line">        throw new AssertionError();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然被克隆的对象有自己的哈希桶数组，但是这个数组引用与原始数组相同的链表，这很容易导致克隆对象和原始对象中的不确定性行为。 要解决这个问题，你必须复制包含每个桶的链表。 下面是一种常见的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// Recursive clone method for class with complex mutable state</span><br><span class="line">public class HashTable implements Cloneable &#123;</span><br><span class="line">    private Entry[] buckets = ...;</span><br><span class="line"></span><br><span class="line">    private static class Entry &#123;</span><br><span class="line">        final Object key;</span><br><span class="line">        Object value;</span><br><span class="line">        Entry  next;</span><br><span class="line"></span><br><span class="line">        Entry(Object key, Object value, Entry next) &#123;</span><br><span class="line">            this.key   = key;</span><br><span class="line">            this.value = value;</span><br><span class="line">            this.next  = next;  </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Recursively copy the linked list headed by this Entry</span><br><span class="line">        Entry deepCopy() &#123;</span><br><span class="line">            return new Entry(key, value,</span><br><span class="line">                next == null ? null : next.deepCopy());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override public HashTable clone() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            HashTable result = (HashTable) super.clone();</span><br><span class="line">            result.buckets = new Entry[buckets.length];</span><br><span class="line">            for (int i = 0; i &lt; buckets.length; i++)</span><br><span class="line">                if (buckets[i] != null)</span><br><span class="line">                    result.buckets[i] = buckets[i].deepCopy();</span><br><span class="line">            return result;</span><br><span class="line">        &#125; catch (CloneNotSupportedException e) &#123;</span><br><span class="line">            throw new AssertionError();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ... // Remainder omitted</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>私有类HashTable.Entry已被扩充以支持“深度复制”方法。 HashTable上的clone方法分配一个合适大小的新哈希桶数组，迭代原来哈希桶数组，深度复制每个非空的哈希桶。 Entry上的deepCopy方法递归地调用它自己以复制由头节点开始的整个链表。 如果哈希桶不是太长，这种技术很聪明并且工作正常。但是，克隆链表不是一个好方法，因为它为列表中的每个元素消耗一个栈帧（stack frame）。 如果列表很长，这很容易导致堆栈溢出。 为了防止这种情况发生，可以用迭代来替换deepCopy中的递归：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// Iteratively copy the linked list headed by this Entry</span><br><span class="line">Entry deepCopy() &#123;</span><br><span class="line">   Entry result = new Entry(key, value, next);</span><br><span class="line">   for (Entry p = result; p.next != null; p = p.next)</span><br><span class="line">      p.next = new Entry(p.next.key, p.next.value, p.next.next);</span><br><span class="line">   return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>克隆复杂可变对象的最后一种方法是调用super.clone，将结果对象中的所有属性设置为其初始状态，然后调用更高级别的方法来重新生成原始对象的状态。 以HashTable为例，bucket属性将被初始化为一个新的bucket数组，并且 put(key, value)方法（未示出）被调用用于被克隆的哈希表中的键值映射。 这种方法通常产生一个简单，合理的优雅clone方法，其运行速度不如直接操纵克隆内部的方法快。 虽然这种方法是干净的，但它与整个Cloneable体系结构是对立的，因为它会盲目地重写构成体系结构基础的逐个属性对象复制。</p><p>与构造方法一样，clone 方法绝对不可以在构建过程中，调用一个可以重写的方法（条目 19）。如果 clone 方法调用一个在子类中重写的方法，则在子类有机会在克隆中修复它的状态之前执行该方法，很可能导致克隆和原始对象的损坏。因此，我们在前面讨论的 put(key, value)方法应该时 final 或 private 修饰的。（如果时 private 修饰，那么大概是一个非 final 公共方法的辅助方法）。</p><p>Object 类的 clone方法被声明为抛出CloneNotSupportedException异常，但重写方法时不需要。 公共clone方法应该省略throws子句，因为不抛出检查时异常的方法更容易使用（条目 71）。</p><p>在为继承设计一个类时（条目 19），通常有两种选择，但无论选择哪一种，都不应该实现 Clonable 接口。你可以选择通过实现正确运行的受保护的 clone方法来模仿Object的行为，该方法声明为抛出CloneNotSupportedException异常。 这给了子类实现Cloneable接口的自由，就像直接继承Object一样。 或者，可以选择不实现工作的 clone方法，并通过提供以下简并clone实现来阻止子类实现它：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// clone method for extendable class not supporting Cloneable</span><br><span class="line">@Override</span><br><span class="line">protected final Object clone() throws CloneNotSupportedException &#123;</span><br><span class="line">    throw new CloneNotSupportedException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一个值得注意的细节。 如果你编写一个实现了Cloneable的线程安全的类，记得它的clone方法必须和其他方法一样（条目 78）需要正确的同步。 Object 类的clone方法是不同步的，所以即使它的实现是令人满意的，也可能需要编写一个返回super.clone()的同步clone方法。</p><p>回顾一下，实现Cloneable的所有类应该重写公共clone方法，而这个方法的返回类型是类本身。 这个方法应该首先调用super.clone，然后修复任何需要修复的属性。 通常，这意味着复制任何包含内部“深层结构”的可变对象，并用指向新对象的引用来代替原来指向这些对象的引用。虽然这些内部拷贝通常可以通过递归调用clone来实现，但这并不总是最好的方法。 如果类只包含基本类型或对不可变对象的引用，那么很可能是没有属性需要修复的情况。 这个规则也有例外。 例如，表示序列号或其他唯一ID的属性即使是基本类型的或不可变的，也需要被修正。</p><p>这么复杂是否真的有必要？很少。 如果你继承一个已经实现了Cloneable接口的类，你别无选择，只能实现一个行为良好的clone方法。 否则，通常你最好提供另一种对象复制方法。 对象复制更好的方法是提供一个复制构造方法或复制工厂。 复制构造方法接受参数，其类型为包含此构造方法的类，例如，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// Copy constructor</span><br><span class="line">public Yum(Yum yum) &#123; ... &#125;;</span><br></pre></td></tr></table></figure><p>复制工厂类似于复制构造方法的静态工厂：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// Copy factory</span><br><span class="line">public static Yum newInstance(Yum yum) &#123; ... &#125;;</span><br></pre></td></tr></table></figure><p>复制构造方法及其静态工厂变体与Cloneable/clone相比有许多优点：它们不依赖风险很大的语言外的对象创建机制；不要求遵守那些不太明确的惯例；不会与final 属性的正确使用相冲突; 不会抛出不必要的检查异常; 而且不需要类型转换。</p><p>此外，复制构造方法或复制工厂可以接受类型为该类实现的接口的参数。 例如，按照惯例，所有通用集合实现都提供了一个构造方法，其参数的类型为Collection或Map。 基于接口的复制构造方法和复制工厂（更适当地称为转换构造方法和转换工厂）允许客户端选择复制的实现类型，而不是强制客户端接受原始实现类型。 例如，假设你有一个HashSet，并且你想把它复制为一个TreeSet。 clone方法不能提供这种功能，但使用转换构造方法很容易：<code>new TreeSet&lt;&gt;(s)</code>。</p><p>考虑到与Cloneable接口相关的所有问题，新的接口不应该继承它，新的可扩展类不应该实现它。 虽然实现Cloneable接口对于final类没有什么危害，但应该将其视为性能优化的角度，仅在极少数情况下才是合理的（条目67）。 通常，复制功能最好由构造方法或工厂提供。 这个规则的一个明显的例外是数组，它最好用 clone方法复制。</p><h2 id="14-考虑实现Comparable接口"><a href="#14-考虑实现Comparable接口" class="headerlink" title="14.考虑实现Comparable接口"></a>14.考虑实现Comparable接口</h2><p>与本章讨论的其他方法不同，<code>compareTo</code>方法并没有在<code>Object</code>类中声明。 相反，它是<code>Comparable</code>接口中的唯一方法。 它与<code>Object</code>类的<code>equals</code>方法在性质上是相似的，除了它允许在简单的相等比较之外的顺序比较，它是泛型的。 通过实现<code>Comparable</code>接口，一个类表明它的实例有一个自然顺序（ natural ordering）。 对实现<code>Comparable</code>接口的对象数组排序非常简单，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(a);</span><br></pre></td></tr></table></figure><p>它很容易查找，计算极端数值，以及维护<code>Comparable</code>对象集合的自动排序。例如，在下面的代码中，依赖于<code>String</code>类实现了<code>Comparable</code>接口，去除命令行参数输入重复的字符串，并按照字母顺序排序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class WordList &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Set&lt;String&gt; s = new TreeSet&lt;&gt;();</span><br><span class="line">        Collections.addAll(s, args);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过实现<code>Comparable</code>接口，可以让你的类与所有依赖此接口的通用算法和集合实现进行互操作。 只需少量的努力就可以获得巨大的能量。 几乎Java平台类库中的所有值类以及所有枚举类型（条目 34）都实现了<code>Comparable</code>接口。 如果你正在编写具有明显自然顺序（如字母顺序，数字顺序或时间顺序）的值类，则应该实现<code>Comparable</code>接口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Comparable&lt;T&gt; &#123;</span><br><span class="line">    int compareTo(T t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>compareTo</code>方法的通用约定与<code>equals</code>相似：</p><p>将此对象与指定的对象按照排序进行比较。 返回值可能为负整数，零或正整数，因为此对象对应小于，等于或大于指定的对象。 如果指定对象的类型与此对象不能进行比较，则引发<code>ClassCastException</code>异常。</p><p>下面的描述中，符号sgn(expression)表示数学中的 signum 函数，它根据表达式的值为负数、零、正数，对应返回-1、0和1。</p><ul><li>实现类必须确保所有<code>x</code>和<code>y</code>都满足<code>sgn(x.compareTo(y)) == -sgn(y. compareTo(x))</code>。 （这意味着当且仅当<code>y.compareTo(x)</code>抛出异常时，<code>x.compareTo(y)</code>必须抛出异常。）</li><li>实现类还必须确保该关系是可传递的：<code>(x. compareTo(y) &gt; 0 &amp;&amp; y.compareTo(z) &gt; 0)</code>意味着<code>x.compareTo(z) &gt; 0</code>。</li><li>最后，对于所有的z，实现类必须确保<code>[x.compareTo(y) == 0</code>意味着<code>sgn(x.compareTo(z)) == sgn(y.compareTo(z))</code>。</li><li>强烈推荐<code>x.compareTo(y) == 0) == (x.equals(y))</code>，但不是必需的。 一般来说，任何实现了<code>Comparable</code>接口的类违反了这个条件都应该清楚地说明这个事实。 推荐的语言是“注意：这个类有一个自然顺序，与<code>equals</code>不一致”。</li></ul><p>与<code>equals</code>方法一样，不要被上述约定的数学特性所退缩。这个约定并不像看起来那么复杂。 与<code>equals</code>方法不同，<code>equals</code>方法在所有对象上施加了全局等价关系，<code>compareTo</code>不必跨越不同类型的对象：当遇到不同类型的对象时，<code>compareTo</code>被允许抛出<code>ClassCastException</code>异常。 通常，这正是它所做的。 约定确实允许进行不同类型间比较，这种比较通常在由被比较的对象实现的接口中定义。</p><p>正如一个违反<code>hashCode</code>约定的类可能会破坏依赖于哈希的其他类一样，违反<code>compareTo</code>约定的类可能会破坏依赖于比较的其他类。 依赖于比较的类，包括排序后的集合<code>TreeSet</code>和<code>TreeMap</code>类，以及包含搜索和排序算法的实用程序类<code>Collections</code>和<code>Arrays</code>。</p><p>我们来看看<code>compareTo</code>约定的规定。 第一条规定，如果反转两个对象引用之间的比较方向，则会发生预期的事情：如果第一个对象小于第二个对象，那么第二个对象必须大于第一个; 如果第一个对象等于第二个，那么第二个对象必须等于第一个; 如果第一个对象大于第二个，那么第二个必须小于第一个。 第二项约定说，如果一个对象大于第二个对象，而第二个对象大于第三个对象，则第一个对象必须大于第三个对象。 最后一条规定，所有比较相等的对象与任何其他对象相比，都必须得到相同的结果。</p><p>这三条规定的一个结果是，<code>compareTo</code>方法所实施的平等测试必须遵守<code>equals</code>方法约定所施加的相同限制：自反性，对称性和传递性。 因此，同样需要注意的是：除非你愿意放弃面向对象抽象（条目 10）的好处，否则无法在保留<code>compareTo</code>约定的情况下使用新的值组件继承可实例化的类。 同样的解决方法也适用。 如果要将值组件添加到实现<code>Comparable</code>的类中，请不要继承它；编写一个包含第一个类实例的不相关的类。 然后提供一个返回包含实例的“视图”方法。 这使你可以在包含类上实现任何<code>compareTo</code>方法，同时客户端在需要时，把包含类的实例视同以一个类的实例。</p><p><code>compareTo</code>约定的最后一段是一个强烈的建议，而不是一个真正的要求，只是声明<code>compareTo</code>方法施加的相等性测试，通常应该返回与<code>equals</code>方法相同的结果。 如果遵守这个约定，则<code>compareTo</code>方法施加的顺序被认为与<code>equals</code>相一致。 如果违反，顺序关系被认为与<code>equals</code>不一致。 其<code>compareTo</code>方法施加与<code>equals</code>不一致顺序关系的类仍然有效，但包含该类元素的有序集合可能不服从相应集合接口（<code>Collection</code>，<code>Set</code>或<code>Map</code>）的一般约定。 这是因为这些接口的通用约定是用<code>equals</code>方法定义的，但是排序后的集合使用<code>compareTo</code>强加的相等性测试来代替<code>equals</code>。 如果发生这种情况，虽然不是一场灾难，但仍是一件值得注意的事情。</p><p>例如，考虑<code>BigDecimal</code>类，其<code>compareTo</code>方法与<code>equals</code>不一致。 如果你创建一个空的<code>HashSet</code>实例，然后添加<code>new BigDecimal(&quot;1.0&quot;)</code>和<code>new BigDecimal(&quot;1.00&quot;)</code>，则该集合将包含两个元素，因为与<code>equals</code>方法进行比较时，添加到集合的两个<code>BigDecimal</code>实例是不相等的。 但是，如果使用<code>TreeSet</code>而不是<code>HashSet</code>执行相同的过程，则该集合将只包含一个元素，因为使用<code>compareTo</code>方法进行比较时，两个<code>BigDecimal</code>实例是相等的。 （有关详细信息，请参阅<code>BigDecimal</code>文档。）</p><p>编写<code>compareTo</code>方法与编写<code>equals</code>方法类似，但是有一些关键的区别。 因为<code>Comparable</code>接口是参数化的，<code>compareTo</code>方法是静态类型的，所以你不需要输入检查或者转换它的参数。 如果参数是错误的类型，那么调用将不会编译。 如果参数为null，则调用应该抛出一个<code>NullPointerException</code>异常，并且一旦该方法尝试访问其成员，它就会立即抛出这个异常。</p><p>在<code>compareTo</code>方法中，比较属性的顺序而不是相等。 要比较对象引用属性，请递归调用<code>compareTo</code>方法。 如果一个属性没有实现<code>Comparable</code>，或者你需要一个非标准的顺序，那么使用<code>Comparator</code>接口。 可以编写自己的比较器或使用现有的比较器，如在条目 10中的<code>CaseInsensitiveString</code>类的<code>compareTo</code>方法中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// Single-field Comparable with object reference field</span><br><span class="line">public final class CaseInsensitiveString</span><br><span class="line">        implements Comparable&lt;CaseInsensitiveString&gt; &#123;</span><br><span class="line">    public int compareTo(CaseInsensitiveString cis) &#123;</span><br><span class="line">        return String.CASE_INSENSITIVE_[ORDER.compare(s](http://ORDER.compare(s), cis.s);</span><br><span class="line">    &#125;</span><br><span class="line">    ... // Remainder omitted</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，<code>CaseInsensitiveString</code>类实现了<code>Comparable &lt;CaseInsensitiveString&gt;</code>接口。 这意味着<code>CaseInsensitiveString</code>引用只能与另一个<code>CaseInsensitiveString</code>引用进行比较。 当声明一个类来实现<code>Comparable</code>接口时，这是正常模式。</p><p>在本书第二版中，曾经推荐如果比较整型基本类型的属性，使用关系运算符“&lt;” 和 “&gt;”，对于浮点类型基本类型的属性，使用<code>Double.compare</code>和[<code>Float.compare</code>静态方法。在Java 7中，静态比较方法被添加到Java的所有包装类中。 在<code>compareTo</code>方法中使用关系运算符“&lt;” 和“&gt;”是冗长且容易出错的，不再推荐。</p><p>如果一个类有多个重要的属性，那么比较他们的顺序是至关重要的。 从最重要的属性开始，逐步比较所有的重要属性。 如果比较结果不是零（零表示相等），则表示比较完成; 只是返回结果。 如果最重要的字段是相等的，比较下一个重要的属性，依此类推，直到找到不相等的属性或比较剩余不那么重要的属性。 以下是条目 11中<code>PhoneNumber</code>类的<code>compareTo</code>方法，演示了这种方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// Multiple-field Comparable with primitive fields</span><br><span class="line">public int compareTo(PhoneNumber pn) &#123;</span><br><span class="line">    int result = [Short.compare(areaCode](http://Short.compare(areaCode), pn.areaCode);</span><br><span class="line">    if (result == 0)  &#123;</span><br><span class="line">        result = [Short.compare(prefix](http://Short.compare(prefix), pn.prefix);</span><br><span class="line">        if (result == 0)</span><br><span class="line">            result = [Short.compare(lineNum](http://Short.compare(lineNum), pn.lineNum);</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Java 8中<code>Comparator</code>接口提供了一系列比较器方法，可以使比较器流畅地构建。 这些比较器可以用来实现<code>compareTo</code>方法，就像<code>Comparable</code>接口所要求的那样。 许多程序员更喜欢这种方法的简洁性，尽管它的性能并不出众：在我的机器上排序<code>PhoneNumber</code>实例的数组速度慢了大约10％。 在使用这种方法时，考虑使用Java的静态导入，以便可以通过其简单名称来引用比较器静态方法，以使其清晰简洁。 以下是<code>PhoneNumber</code>的<code>compareTo</code>方法的使用方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// Comparable with comparator construction methods</span><br><span class="line">private static final Comparator&lt;PhoneNumber&gt; COMPARATOR =</span><br><span class="line">        comparingInt((PhoneNumber pn) -&gt; pn.areaCode)</span><br><span class="line">          .thenComparingInt(pn -&gt; pn.prefix)</span><br><span class="line">          .thenComparingInt(pn -&gt; pn.lineNum);</span><br><span class="line"></span><br><span class="line">public int compareTo(PhoneNumber pn) &#123;</span><br><span class="line">    return [COMPARATOR.compare(this](http://COMPARATOR.compare(this), pn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此实现在类初始化时构建比较器，使用两个比较器构建方法。第一个是<code>comparingInt</code>方法。它是一个静态方法，它使用一个键提取器函数式接口（ key extractor function）作为参数，将对象引用映射为int类型的键，并返回一个根据该键排序的实例的比较器。在前面的示例中，<code>comparingInt</code>方法使用lambda表达式，它从<code>PhoneNumber</code>中提取区域代码，并返回一个<code>Comparator&lt;PhoneNumber&gt;</code>，根据它们的区域代码来排序电话号码。注意，lambda表达式显式指定了其输入参数的类型<code>(PhoneNumber pn)</code>。事实证明，在这种情况下，Java的类型推断功能不够强大，无法自行判断类型，因此我们不得不帮助它以使程序编译。</p><p>如果两个电话号码实例具有相同的区号，则需要进一步细化比较，这正是第二个比较器构建方法，即<code>thenComparingInt</code>方法做的。 它是<code>Comparator</code>上的一个实例方法，接受一个int类型键提取器函数式接口（ key extractor function）作为参数，并返回一个比较器，该比较器首先应用原始比较器，然后使用提取的键来打破连接。 你可以按照喜欢的方式多次调用<code>thenComparingIn</code>t方法，从而产生一个字典顺序。 在上面的例子中，我们将两个调用叠加到<code>thenComparingInt</code>，产生一个排序，它的二级键是<code>prefix</code>，而其三级键是<code>lineNum</code>。 请注意，我们不必指定传递给<code>thenComparingInt</code>的任何一个调用的键提取器函数式接口的参数类型：Java的类型推断足够聪明，可以自己推断出参数的类型。</p><p><code>Comparator</code>类具有完整的构建方法。对于<code>long</code>和<code>double</code>基本类型，也有对应的类似于<code>comparingInt</code>和<code>thenComparingInt的</code>方法，<code>int</code>版本的方法也可以应用于取值范围小于 <code>int</code>的类型上，如<code>short</code>类型，如<code>PhoneNumber</code>实例中所示。对于<code>double</code>版本的方法也可以用在<code>float</code>类型上。这提供了所有Java的基本数字类型的覆盖。</p><p>也有对象引用类型的比较器构建方法。静态方法<code>comparing</code>有两个重载方式。第一个方法使用键提取器函数式接口并按键的自然顺序。第二种方法是键提取器函数式接口和比较器，用于键的排序。<code>thenComparing</code>方法有三种重载。第一个重载只需要一个比较器，并使用它来提供一个二级排序。第二次重载只需要一个键提取器函数式接口，并使用键的自然顺序作为二级排序。最后的重载方法同时使用一个键提取器函数式接口和一个比较器来用在提取的键上。</p><p>有时，你可能会看到<code>compareTo</code>或<code>compare</code>方法依赖于两个值之间的差值，如果第一个值小于第二个值，则为负；如果两个值相等则为零，如果第一个值大于，则为正值。这是一个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// BROKEN difference-based comparator - violates transitivity!</span><br><span class="line"></span><br><span class="line">static Comparator&lt;Object&gt; hashCodeOrder = new Comparator&lt;&gt;() &#123;</span><br><span class="line">    public int compare(Object o1, Object o2) &#123;</span><br><span class="line">        return o1.hashCode() - o2.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>不要使用这种技术！它可能会导致整数最大长度溢出和IEEE 754浮点运算失真的危险[JLS 15.20.1,15.21.1]。 此外，由此产生的方法不可能比使用上述技术编写的方法快得多。 使用静态<code>compare</code>方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">**// Comparator based on static compare method**</span><br><span class="line">static Comparator&lt;Object&gt; hashCodeOrder = new Comparator&lt;&gt;() &#123;</span><br><span class="line">    public int compare(Object o1, Object o2) &#123;</span><br><span class="line">        return Integer.compare(o1.hashCode(), o2.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>或者使用<code>Comparator</code>的构建方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// Comparator based on Comparator construction method</span><br><span class="line">static Comparator&lt;Object&gt; hashCodeOrder =</span><br><span class="line">        Comparator.comparingInt(o -&gt; o.hashCode());</span><br></pre></td></tr></table></figure><p>总而言之，无论何时实现具有合理排序的值类，你都应该让该类实现<code>Comparable</code>接口，以便在基于比较的集合中轻松对其实例进行排序，搜索和使用。 比较<code>compareTo</code>方法的实现中的字段值时，请避免使用”&lt;”和”&gt;”运算符。 相反，使用包装类中的静态<code>compare</code>方法或<code>Comparator</code>接口中的构建方法。</p><h2 id="15-使类和成员的可访问性最小化"><a href="#15-使类和成员的可访问性最小化" class="headerlink" title="15. 使类和成员的可访问性最小化"></a>15. 使类和成员的可访问性最小化</h2><p>将设计良好的组件与设计不佳的组件区分开来的最重要的因素是，组件将其内部数据和其他组件的其他实现细节隐藏起来。一个设计良好的组件隐藏了它的所有实现细节，干净地将它的API与它的实现分离开来。然后，组件只通过它们的API进行通信，并且对彼此的内部工作一无所知。这一概念，被称为信息隐藏或封装，是软件设计的基本原则[Parnas72]。</p><p>信息隐藏很重要有很多原因，其中大部分来源于它将组成系统的组件分离开来，允许它们被独立地开发，测试，优化，使用，理解和修改。这加速了系统开发，因为组件可以并行开发。它减轻了维护的负担，因为可以更快速地理解组件，调试或更换组件，而不用担心损害其他组件。虽然信息隐藏本身并不会导致良好的性能，但它可以有效地进行性能调整：一旦系统完成并且分析确定了哪些组件导致了性能问题（条目 67），则可以优化这些组件，而不会影响别人的正确的组件。信息隐藏增加了软件重用，因为松耦合的组件通常在除开发它们之外的其他环境中证明是有用的。最后，隐藏信息降低了构建大型系统的风险，因为即使系统不能运行，各个独立的组件也可能是可用的。</p><p>Java提供了许多机制来帮助信息隐藏。 访问控制机制（access control mechanism）[JLS，6.6]指定了类，接口和成员的可访问性。 实体的可访问性取决于其声明的位置，以及声明中存在哪些访问修饰符（private，protected和public）。 正确使用这些修饰符对信息隐藏至关重要。</p><p>经验法则很简单：<strong>让每个类或成员尽可能地不可访问</strong>。换句话说，使用尽可能低的访问级别，与你正在编写的软件的对应功能保持一致。</p><p>对于顶层(非嵌套的)类和接口，只有两个可能的访问级别:包级私有（package-private）和公共的（public）。如果你使用public修饰符声明顶级类或接口，那么它是公开的；否则，它是包级私有的。如果一个顶层类或接口可以被做为包级私有，那么它应该是。通过将其设置为包级私有，可以将其作为实现的一部分，而不是导出的API，你可以修改它、替换它，或者在后续版本中消除它，而不必担心损害现有的客户端。如果你把它公开，你就有义务永远地支持它，以保持兼容性。</p><p>如果一个包级私有顶级类或接口只被一个类使用，那么可以考虑这个类作为使用它的唯一类的私有静态嵌套类(条目 24)。这将它的可访问性从包级的所有类减少到使用它的一个类。但是，减少不必要的公共类的可访问性要比包级私有的顶级类更重要：公共类是包的API的一部分，而包级私有的顶级类已经是这个包实现的一部分了。</p><p>对于成员(属性、方法、嵌套类和嵌套接口)，有四种可能的访问级别，在这里，按照可访问性从小到大列出：</p><ul><li>private——该成员只能在声明它的顶级类内访问。</li><li>package-private——成员可以从被声明的包中的任何类中访问。从技术上讲，如果没有指定访问修饰符(接口成员除外，它默认是公共的)，这是默认访问级别。</li><li>protected——成员可以从被声明的类的子类中访问(受一些限制，JLS，6.6.2)，以及它声明的包中的任何类。</li><li>public——该成员可以从任何地方被访问。</li></ul><p>在仔细设计你的类的公共API之后，你的反应应该是让所有其他成员设计为私有的。 只有当同一个包中的其他类真的需要访问成员时，需要删除私有修饰符，从而使成员包成为包级私有的。 如果你发现自己经常这样做，你应该重新检查你的系统的设计，看看另一个分解可能产生更好的解耦的类。 也就是说，私有成员和包级私有成员都是类实现的一部分，通常不会影响其导出的API。 但是，如果类实现Serializable接口（条目 86和87），则这些属性可以“泄漏（leak）”到导出的API中。</p><p>对于公共类的成员，当访问级别从包私有到受保护级时，可访问性会大大增加。 受保护（protected）的成员是类导出的API的一部分，并且必须永远支持。 此外，导出类的受保护成员表示对实现细节的公开承诺（条目 19）。 对受保护成员的需求应该相对较少。</p><p>有一个关键的规则限制了你减少方法访问性的能力。 如果一个方法重写一个超类方法，那么它在子类中的访问级别就不能低于父类中的访问级别[JLS，8.4.8.3]。 这对于确保子类的实例在父类的实例可用的地方是可用的（Liskov替换原则，见条目 15）是必要的。 如果违反此规则，编译器将在尝试编译子类时生成错误消息。 这个规则的一个特例是，如果一个类实现了一个接口，那么接口中的所有类方法都必须在该类中声明为public。</p><p>为了便于测试你的代码，你可能会想要让一个类，接口或者成员更容易被访问。 这没问题。 为了测试将公共类的私有成员指定为包级私有是可以接受的，但是提高到更高的访问级别却是不可接受的。 换句话说，将类，接口或成员作为包级导出的API的一部分来促进测试是不可接受的。 幸运的是，这不是必须的，因为测试可以作为被测试包的一部分运行，从而获得对包私有元素的访问。</p><p><strong>公共类的实例属性很少公开(条目 16)</strong>。如果一个实例属性是非final的，或者是对可变对象的引用，那么通过将其公开，你就放弃了限制可以存储在属性中的值的能力。这意味着你放弃了执行涉及该属性的不变量的能力。另外，当属性被修改时，就放弃了采取任何操作的能力，因此<strong>公共可变属性的类通常不是线程安全的</strong>。即使属性是final的，并且引用了一个不可变的对象，通过使它公开，你就放弃切换到不存在属性的新的内部数据表示的灵活性。</p><p>同样的建议适用于静态属性，但有一个例外。 假设常量是类的抽象的一个组成部分，你可以通过<code>public static final</code>属性暴露常量。 按照惯例，这些属性的名字由大写字母组成，字母用下划线分隔（条目 68）。 很重要的一点是，这些属性包含基本类型的值或对不可变对象的引用（条目 17）。 包含对可变对象的引用的属性具有非final属性的所有缺点。 虽然引用不能被修改，但引用的对象可以被修改，并会带来灾难性的结果。</p><p>请注意，非零长度的数组总是可变的，所以<strong>类具有公共静态final数组属性，或返回这样一个属性的访问器是错误的</strong>。 如果一个类有这样的属性或访问方法，客户端将能够修改数组的内容。 这是安全漏洞的常见来源：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// Potential security hole!</span><br><span class="line">public static final Thing[] VALUES = &#123; ... &#125;;</span><br></pre></td></tr></table></figure><p>要小心这样的事实，一些IDE生成的访问方法返回对私有数组属性的引用，导致了这个问题。 有两种方法可以解决这个问题。 你可以使公共数组私有并添加一个公共的不可变列表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private static final Thing[] PRIVATE_VALUES = &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line">public static final List&lt;Thing&gt; VALUES =</span><br><span class="line"></span><br><span class="line">Collections.unmodifiableList(Arrays.asList(PRIVATE_VALUES));</span><br></pre></td></tr></table></figure><p>或者，可以将数组设置为private，并添加一个返回私有数组拷贝的公共方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private static final Thing[] PRIVATE_VALUES = &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line">public static final Thing[] values() &#123;</span><br><span class="line">    return PRIVATE_VALUES.clone();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要在这些方法之间进行选择，请考虑客户端可能如何处理返回的结果。 哪种返回类型会更方便？ 哪个会更好的表现？</p><p>在Java 9中，作为模块系统（module system）的一部分引入了两个额外的隐式访问级别。模块包含一组包，就像一个包包含一组类一样。模块可以通过模块声明中的导出（export）声明显式地导出某些包(这是module-info.java的源文件中包含的约定)。模块中的未导出包的公共和受保护成员在模块之外是不可访问的；在模块中，可访问性不受导出（export）声明的影响。使用模块系统允许你在模块之间共享类，而不让它们对整个系统可见。在未导出的包中，公共和受保护的公共类的成员会产生两个隐式访问级别，这是普通公共和受保护级别的内部类似的情况。这种共享的需求是相对少见的，并且可以通过重新安排包中的类来消除。</p><p>与四个主要访问级别不同，这两个基于模块的级别主要是建议（advisory）。 如果将模块的JAR文件放在应用程序的类路径而不是其模块路径中，那么模块中的包将恢复为非模块化行为：包的公共类的所有公共类和受保护成员都具有其普通的可访问性，不管包是否由模块导出[Reinhold，1.2]。 新引入的访问级别严格执行的地方是JDK本身：Java类库中未导出的包在模块之外真正无法访问。</p><p>对于典型的Java程序员来说，不仅程序模块所提供的访问保护存在局限性，而且在本质上是很大程度上建议性的；为了利用它，你必须把你的包组合成模块，在模块声明中明确所有的依赖关系，重新安排你的源码树层级，并采取特殊的行动来适应你的模块内任何对非模块化包的访问[Reinhold ，3]。 现在说模块是否会在JDK之外得到广泛的使用还为时尚早。 与此同时，除非你有迫切的需要，否则似乎最好避免它们。</p><p>总而言之，应该尽可能地减少程序元素的可访问性（在合理范围内）。 在仔细设计一个最小化的公共API之后，你应该防止任何散乱的类，接口或成员成为API的一部分。 除了作为常量的公共静态final属性之外，公共类不应该有公共属性。 确保<code>public static final</code>属性引用的对象是不可变的。</p><h2 id="16-在公共类中使用访问方法而不是公共属性"><a href="#16-在公共类中使用访问方法而不是公共属性" class="headerlink" title="16. 在公共类中使用访问方法而不是公共属性"></a>16. 在公共类中使用访问方法而不是公共属性</h2><p>有时候，你可能会试图写一些退化的类（degenerate classes），除了集中实例属性之外别无用处：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Degenerate classes like this should not be public!</span><br><span class="line">class Point &#123;</span><br><span class="line">    public double x;</span><br><span class="line">    public double y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于这些类的数据属性可以直接被访问，因此这些类不提供封装的好处（条目 15）。 如果不更改API，则无法更改其表示形式，无法强制执行不变量，并且在访问属性时无法执行辅助操作。 坚持面向对象的程序员觉得这样的类是厌恶的，应该被具有私有属性和公共访问方法的类（getter）所取代，而对于可变类来说，它们应该被替换为setter设值方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// Encapsulation of data by accessor methods and mutators</span><br><span class="line">class Point &#123;</span><br><span class="line">    private double x;</span><br><span class="line">    private double y;</span><br><span class="line"></span><br><span class="line">    public Point(double x, double y) &#123;</span><br><span class="line">        this.x = x;</span><br><span class="line">        this.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public double getX() &#123; return x; &#125;</span><br><span class="line"></span><br><span class="line">    public double getY() &#123; return y; &#125;</span><br><span class="line"></span><br><span class="line">    public void setX(double x) &#123; this.x = x; &#125;</span><br><span class="line"></span><br><span class="line">    public void setY(double y) &#123; this.y = y; &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，对于公共类来说，坚持面向对象是正确的：<strong>如果一个类在其包之外是可访问的，则提供访问方法</strong>来保留更改类内部表示的灵活性。如果一个公共类暴露其数据属性，那么以后更改其表示形式基本上没有可能，因为客户端代码可以散布在很多地方。</p><p>但是，<strong>如果一个类是包级私有的，或者是一个私有的内部类，那么暴露它的数据属性就没有什么本质上的错误</strong>——假设它们提供足够描述该类提供的抽象。在类定义和使用它的客户端代码中，这种方法比访问方法产生更少的视觉混乱。 虽然客户端代码绑定到类的内部表示，但是这些代码仅限于包含该类的包。 如果类的内部表示是可取的，可以在不触碰包外的任何代码的情况下进行更改。 在私有内部类的情况下，更改作用范围进一步限制在封闭类中。</p><p>Java平台类库中的几个类违反了公共类不应直接暴露属性的建议。 着名的例子包括java.awt包中的<code>Point</code>和<code>Dimension</code>类。 这些类别应该被视为警示性的示例，而不是模仿的例子。 如条目 67所述，暴露<code>Dimension</code>的内部结构的决定是一个严重的性能问题，这个问题在今天仍然存在。</p><p>虽然公共类直接暴露属性并不是一个好主意，但是如果属性是不可变的，那么危害就不那么大了。当一个属性是只读的时候，除了更改类的API外，你不能改变类的内部表示形式，也不能采取一些辅助的行为，但是可以加强不变性。例如，下面的例子中保证每个实例表示一个有效的时间：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// Public class with exposed immutable fields - questionable</span><br><span class="line"></span><br><span class="line">public final class Time &#123;</span><br><span class="line">    private static final int HOURS_PER_DAY    = 24;</span><br><span class="line">    private static final int MINUTES_PER_HOUR = 60;</span><br><span class="line">    public final int hour;</span><br><span class="line">    public final int minute;</span><br><span class="line"></span><br><span class="line">    public Time(int hour, int minute) &#123;</span><br><span class="line">        if (hour &lt; 0 || hour &gt;= HOURS_PER_DAY)</span><br><span class="line">           throw new IllegalArgumentException(&quot;Hour: &quot; + hour);</span><br><span class="line">        if (minute &lt; 0 || minute &gt;= MINUTES_PER_HOUR)</span><br><span class="line">           throw new IllegalArgumentException(&quot;Min: &quot; + minute);</span><br><span class="line">        this.hour = hour;</span><br><span class="line">        this.minute = minute;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ... // Remainder omitted</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总之，公共类不应该暴露可变属性。 公共累暴露不可变属性的危害虽然仍然存在问题，但其危害较小。 然而，有时需要包级私有或私有内部类来暴露属性，无论此类是否是可变的。</p><h2 id="17-最小化可变性"><a href="#17-最小化可变性" class="headerlink" title="17. 最小化可变性"></a>17. 最小化可变性</h2><p>不可变类简单来说是它的实例不能被修改的类。 包含在每个实例中的所有信息在对象的生命周期中是固定的，因此不会观察到任何变化。 Java平台类库包含许多不可变的类，包括String类，基本类型包装类以及BigInteger类和BigDecimal类。 有很多很好的理由：不可变类比可变类更容易设计，实现和使用。 他们不太容易出错，更安全。</p><p>要使一个类不可变，请遵循以下五条规则：</p><ol><li><strong>不要提供修改对象状态的方法</strong>（也称为mutators）。</li><li><strong>确保这个类不能被继承</strong>。 这可以防止粗心的或恶意的子类，假设对象的状态已经改变，从而破坏类的不可变行为。 防止子类化通常是通过final修饰类，但是我们稍后将讨论另一种方法。</li><li><strong>把所有属性设置为final</strong>。通过系统强制执行，清楚地表达了你的意图。 另外，如果一个新创建的实例的引用从一个线程传递到另一个线程而没有同步，就必须保证正确的行为，正如内存模型[JLS，17.5; Goetz06,16]所述。</li><li><strong>把所有的属性设置为private</strong>。 这可以防止客户端获得对属性引用的可变对象的访问权限并直接修改这些对象。 虽然技术上允许不可变类具有包含基本类型数值的公共final属性或对不可变对象的引用，但不建议这样做，因为它不允许在以后的版本中更改内部表示（项目15和16）。</li><li><strong>确保对任何可变组件的互斥访问</strong>。 如果你的类有任何引用可变对象的属性，请确保该类的客户端无法获得对这些对象的引用。 切勿将这样的属性初始化为客户端提供的对象引用，或从访问方法返回属性。 在构造方法，访问方法和<code>readObject方法</code>（条目 88）中进行防御性拷贝（条目 50）。</li></ol><p>以前条目中的许多示例类都是不可变的。 其中这样的类是条目 11中的<code>PhoneNumber</code>类，它具有每个属性的访问方法（accessors），但没有相应的设值方法（mutators）。 这是一个稍微复杂一点的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">// Immutable complex number class</span><br><span class="line"></span><br><span class="line">public final class Complex &#123;</span><br><span class="line"></span><br><span class="line">    private final double re;</span><br><span class="line"></span><br><span class="line">    private final double im;</span><br><span class="line"></span><br><span class="line">    public Complex(double re, double im) &#123;</span><br><span class="line"></span><br><span class="line">        this.re = re;</span><br><span class="line"></span><br><span class="line">        this.im = im;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public double realPart() &#123;</span><br><span class="line"></span><br><span class="line">        return re;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public double imaginaryPart() &#123;</span><br><span class="line"></span><br><span class="line">        return im;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Complex plus(Complex c) &#123;</span><br><span class="line"></span><br><span class="line">        return new Complex(re + c.re, im + c.im);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Complex minus(Complex c) &#123;</span><br><span class="line"></span><br><span class="line">        return new Complex(re - c.re, im - c.im);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Complex times(Complex c) &#123;</span><br><span class="line"></span><br><span class="line">        return new Complex(re * c.re - im * c.im,</span><br><span class="line"></span><br><span class="line">                re * c.im + im * c.re);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Complex dividedBy(Complex c) &#123;</span><br><span class="line"></span><br><span class="line">        double tmp = c.re * c.re + c.im * c.im;</span><br><span class="line"></span><br><span class="line">        return new Complex((re * c.re + im * c.im) / tmp,</span><br><span class="line"></span><br><span class="line">                (im * c.re - re * c.im) / tmp);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line"></span><br><span class="line">    public boolean equals(Object o) &#123;</span><br><span class="line"></span><br><span class="line">        if (o == this) &#123;</span><br><span class="line"></span><br><span class="line">            return true;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!(o instanceof Complex)) &#123;</span><br><span class="line"></span><br><span class="line">            return false;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Complex c = (Complex) o;</span><br><span class="line"></span><br><span class="line">        // See page 47 to find out why we use compare instead of ==</span><br><span class="line"></span><br><span class="line">        return Double.compare(c.re, re) == 0</span><br><span class="line"></span><br><span class="line">                &amp;&amp; Double.compare(c.im, im) == 0;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line"></span><br><span class="line">    public int hashCode() &#123;</span><br><span class="line"></span><br><span class="line">        return 31 * Double.hashCode(re) + Double.hashCode(im);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line"></span><br><span class="line">    public String toString() &#123;</span><br><span class="line"></span><br><span class="line">        return &quot;(&quot; + re + &quot; + &quot; + im + &quot;i)&quot;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类代表了一个复数（包含实部和虚部的数字）。 除了标准的Object方法之外，它还为实部和虚部提供访问方法，并提供四个基本的算术运算：加法，减法，乘法和除法。 注意算术运算如何创建并返回一个新的<code>Complex</code>实例，而不是修改这个实例。 这种模式被称为函数式方法，因为方法返回将操作数应用于函数的结果，而不修改它们。 与其对应的过程（procedural）或命令（imperative）的方法相对比，在这种方法中，将一个过程作用在操作数上，导致其状态改变。 请注意，方法名称是介词（如plus）而不是动词（如add）。 这强调了方法不会改变对象的值的事实。 <code>BigInteger</code>和<code>BigDecimal</code>类没有遵守这个命名约定，并导致许多使用错误。</p><p>如果你不熟悉函数式方法，可能会显得不自然，但它具有不变性，具有许多优点。 <strong>不可变对象很简单</strong>。 一个不可变的对象可以完全处于一种状态，也就是被创建时的状态。 如果确保所有的构造方法都建立了类不变量，那么就保证这些不变量在任何时候都保持不变，使用此类的程序员无需再做额外的工作。 另一方面，可变对象可以具有任意复杂的状态空间。 如果文档没有提供由设置（mutator）方法执行的状态转换的精确描述，那么可靠地使用可变类可能是困难的或不可能的。</p><p><strong>不可变对象本质上是线程安全的; 它们不需要同步</strong>。 被多个线程同时访问它们时并不会被破坏。 这是实现线程安全的最简单方法。 由于没有线程可以观察到另一个线程对不可变对象的影响，所以<strong>不可变对象可以被自由地共享</strong>。 因此，不可变类应鼓励客户端尽可能重用现有的实例。 一个简单的方法是为常用的值提供公共的静态 final常量。 例如，<code>Complex</code>类可能提供这些常量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static final Complex ZERO = new Complex(0, 0);</span><br><span class="line">public static final Complex ONE  = new Complex(1, 0);</span><br><span class="line">public static final Complex I    = new Complex(0, 1);</span><br></pre></td></tr></table></figure><p>这种方法可以更进一步。 一个不可变的类可以提供静态的工厂（条目 1）来缓存经常被请求的实例，以避免在现有的实例中创建新的实例。 所有基本类型的包装类和<code>BigInteger</code>类都是这样做的。 使用这样的静态工厂会使客户端共享实例而不是创建新实例，从而减少内存占用和垃圾回收成本。 在设计新类时，选择静态工厂代替公共构造方法，可以在以后增加缓存的灵活性，而不需要修改客户端。</p><p>不可变对象可以自由分享的结果是，你永远不需要做出防御性拷贝（ defensive copies）（条目 50）。 事实上，永远不需要做任何拷贝，因为这些拷贝永远等于原始对象。 因此，你不需要也不应该在一个不可变的类上提供一个clone方法或拷贝构造方法（copy constructor）（条目 13）。 这一点在Java平台的早期阶段还不是很好理解，所以String类有一个拷贝构造方法，但是它应该尽量很少使用（条目 6）。</p><p><strong>不仅可以共享不可变的对象，而且可以共享内部信息</strong>。 例如，<code>BigInteger</code>类在内部使用符号数值表示法。 符号用int值表示，数值用int数组表示。 <code>negate</code>方法生成了一个数值相同但符号相反的新<code>BigInteger</code>实例。 即使它是可变的，也不需要复制数组；新创建的<code>BigInteger</code>指向与原始相同的内部数组。</p><p><strong>不可变对象为其他对象提供了很好的构件（building blocks）</strong>，无论是可变的还是不可变的。 如果知道一个复杂组件的内部对象不会发生改变，那么维护复杂对象的不变量就容易多了。这一原则的特例是，不可变对象可以构成<code>Map</code>对象的键和<code>Set</code>的元素，一旦不可变对象作为<code>Map</code>的键或<code>Set</code>里的元素，即使破坏了<code>Map</code>和<code>Set</code>的不可变性，但不用担心它们的值会发生变化。</p><p><strong>不可变对象提供了免费的原子失败机制</strong>（条目 76）。它们的状态永远不会改变，所以不可能出现临时的不一致。</p><p><strong>不可变类的主要缺点是对于每个不同的值都需要一个单独的对象</strong>。 创建这些对象可能代价很高，特别是如果是大型的对象下。 例如，假设你有一个百万位的<code>BigInteger</code>    ，你想改变它的低位：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BigInteger moby = ...;</span><br><span class="line"></span><br><span class="line">moby = moby.flipBit(0);</span><br></pre></td></tr></table></figure><p><code>flipBit</code>方法创建一个新的<code>BigInteger</code>实例，也是一百万位长，与原始位置只有一位不同。 该操作需要与<code>BigInteger</code>大小成比例的时间和空间。 将其与<code>java.util.BitSet</code>对比。 像<code>BigIntege</code>r一样，<code>BitSet</code>表示一个任意长度的位序列，但与<code>BigInteger</code>不同，<code>BitSe</code>t是可变的。 <code>BitSet</code>类提供了一种方法，允许你在固定时间内更改百万位实例中单个位的状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BitSet moby = ...;</span><br><span class="line"></span><br><span class="line">moby.flip(0);</span><br></pre></td></tr></table></figure><p>如果执行一个多步操作，在每一步生成一个新对象，除最终结果之外丢弃所有对象，则性能问题会被放大。这里有两种方式来处理这个问题。第一种办法，先猜测一下会经常用到哪些多步的操作，然后讲它们作为基本类型提供。如果一个多步操作是作为一个基本类型提供的，那么不可变类就不必在每一步创建一个独立的对象。在内部，不可变的类可以是任意灵活的。 例如，<code>BigInteger</code>有一个包级私有的可变的“伙伴类（companion class）”，它用来加速多步操作，比如模幂运算（ modular exponentiation）。出于前面所述的所有原因，使用可变伙伴类比使用BigInteger要困难得多。 幸运的是，你不必使用它：<code>BigInteger</code>类的实现者为你做了很多努力。</p><p>如果你可以准确预测客户端要在你的不可变类上执行哪些复杂的操作，那么包级私有可变伙伴类的方式可以正常工作。如果不是的话，那么最好的办法就是提供一个公开的可变伙伴类。 这种方法在Java平台类库中的主要例子是String类，它的可变伙伴类是<code>StringBuilder</code>（及其过时的前身<code>StringBuffer</code>类）。</p><p>现在你已经知道如何创建一个不可改变类，并且了解不变性的优点和缺点，下面我们来讨论几个设计方案。 回想一下，为了保证不变性，一个类不得允许子类化。 这可以通过使类用 final 修饰，但是还有另外一个更灵活的选择。 而不是使不可变类设置为 final，可以使其所有的构造方法私有或包级私有，并添加公共静态工厂，而不是公共构造方法（条目 1）。 为了具体说明这种方法，下面以<code>Complex</code>为例，看看如何使用这种方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// Immutable class with static factories instead of constructors</span><br><span class="line"></span><br><span class="line">public class Complex &#123;</span><br><span class="line"></span><br><span class="line">    private final double re;</span><br><span class="line"></span><br><span class="line">    private final double im;</span><br><span class="line"></span><br><span class="line">    private Complex(double re, double im) &#123;</span><br><span class="line"></span><br><span class="line">        [this.re](http://this.re) = re;</span><br><span class="line"></span><br><span class="line">        [this.im](http://this.im) = im;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Complex valueOf(double re, double im) &#123;</span><br><span class="line"></span><br><span class="line">        return new Complex(re, im);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ... // Remainder unchanged</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法往往是最好的选择。 这是最灵活的，因为它允许使用多个包级私有实现类。 对于驻留在包之外的客户端，不可变类实际上是final的，因为不可能继承来自另一个包的类，并且缺少公共或受保护的构造方法。 除了允许多个实现类的灵活性以外，这种方法还可以通过改进静态工厂的对象缓存功能来调整后续版本中类的性能。</p><p>当<code>BigInteger</code>和<code>BigDecimal</code>被写入时，不可变类必须是有效的final，因此它们的所有方法都可能被重写。不幸的是，在保持向后兼容性的同时，这一事实无法纠正。如果你编写一个安全性取决于来自不受信任的客户端的<code>BigIntege</code>r或<code>BigDecimal</code>参数的不变类时，则必须检查该参数是“真实的”<code>BigInteger</code>还是<code>BigDecimal</code>，而不应该是不受信任的子类的实例。如果是后者，则必须在假设可能是可变的情况下保护性拷贝（defensively copy）（条目 50）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static BigInteger safeInstance(BigInteger val) &#123;</span><br><span class="line"></span><br><span class="line">    return val.getClass() == BigInteger.class ?</span><br><span class="line">            val : new BigInteger(val.toByteArray());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在本条目开头关于不可变类的规则说明，没有方法可以修改对象，并且它的所有属性必须是final的。事实上，这些规则比实际需要的要强硬一些，其实可以有所放松来提高性能。 事实上，任何方法都不能在对象的状态中产生外部可见的变化。 然而，一些不可变类具有一个或多个非final属性，在第一次需要时将开销昂贵的计算结果缓存在这些属性中。 如果再次请求相同的值，则返回缓存的值，从而节省了重新计算的成本。 这个技巧的作用恰恰是因为对象是不可变的，这保证了如果重复的话，计算会得到相同的结果。</p><p>例如，<code>PhoneNumber</code>类的<code>hashCode</code>方法（第53页的条目 11）在第一次调用改方法时计算哈希码，并在再次调用时对其进行缓存。 这种延迟初始化（条目 83）的一个例子，String类也使用到了。</p><p>关于序列化应该加上一个警告。 如果你选择使您的不可变类实现Serializable接口，并且它包含一个或多个引用可变对象的属性，则必须提供显式的<code>readObject</code>或<code>readResolve</code>方法，或者使用<code>ObjectOutputStream.writeUnshared</code>和<code>ObjectInputStream.readUnshared</code>方法，即默认的序列化形式也是可以接受的。 否则攻击者可能会创建一个可变的类的实例。 这个主题会在条目 88中会详细介绍。</p><p>总而言之，坚决不要为每个属性编写一个get方法后再编写一个对应的set方法。 <strong>除非有充分的理由使类成为可变类，否则类应该是不可变的</strong>。 不可变类提供了许多优点，唯一的缺点是在某些情况下可能会出现性能问题。 你应该始终使用较小的值对象（如<code>PhoneNumber</code>和<code>Complex</code>），使其不可变。 （Java平台类库中有几个类，如<code>java.util.Date</code>和<code>java.awt.Point</code>，本应该是不可变的，但实际上并不是）。你应该认真考虑创建更大的值对象，例如<code>String</code>和<code>BigInteger</code> ，设成不可改变的。 只有当你确认有必要实现令人满意的性能（条目 67）时，才应该为不可改变类提供一个公开的可变伙伴类。</p><p>对于一些类来说，不变性是不切实际的。<strong>如果一个类不能设计为不可变类，那么也要尽可能地限制它的可变性</strong>。减少对象可以存在的状态数量，可以更容易地分析对象，以及降低出错的可能性。因此，除非有足够的理由把属性设置为非 final 的情况下，否则应该每个属性都设置为 final 的。把本条目的建议与条目15的建议结合起来，你自然的倾向就是：<strong>除非有充分的理由不这样做，否则应该把每个属性声明为私有final的</strong>。</p><p><strong>构造方法应该创建完全初始化的对象，并建立所有的不变性</strong>。 除非有令人信服的理由，否则不要提供独立于构造方法或静态工厂的公共初始化方法。 同样，不要提供一个“reinitialize”方法，使对象可以被重用，就好像它是用不同的初始状态构建的。 这样的方法通常以增加的复杂度为代价，仅仅提供很少的性能优势。</p><p><code>CountDownLatch</code>类是这些原理的例证。 它是可变的，但它的状态空间有意保持最小范围内。 创建一个实例，使用它一次，并完成：一旦countdown锁的计数器已经达到零，不能再重用它。</p><p>在这个条目中，应该添加关于<code>Complex</code>类的最后一个注释。 这个例子只是为了说明不变性。 这不是一个工业强度复杂的复数实现。 它对复数使用了乘法和除法的标准公式，这些公式不正确会进行不正确的四舍五入，没有为复数的NaN和无穷大提供良好的语义[Kahan91，Smith62，Thomas94]。</p><h2 id="18-组合优于继承"><a href="#18-组合优于继承" class="headerlink" title="18. 组合优于继承"></a>18. 组合优于继承</h2><p>继承是实现代码重用的有效方式，但并不总是最好的工具。使用不当，会导致脆弱的软件。 在包中使用继承是安全的，其中子类和父类的实现都在同一个程序员的控制之下。对应专门为了继承而设计的，并且有文档说明的类来说（条目 19），使用继承也是安全的。 然而，从普通的具体类跨越包级边界继承，是危险的。 提醒一下，本书使用“继承”一词来表示实现继承（当一个类继承另一个类时）。 在这个项目中讨论的问题不适用于接口继承（当类实现接口或当接口继承另一个接口时）。</p><p><strong>与方法调用不同，继承打破了封装</strong>[Snyder86]。 换句话说，一个子类依赖于其父类的实现细节来保证其正确的功能。 父类的实现可能会从发布版本不断变化，如果是这样，子类可能会被破坏，即使它的代码没有任何改变。 因此，一个子类必须与其超类一起更新而变化，除非父类的作者为了继承的目的而专门设计它，并对应有文档的说明。</p><p>为了具体说明，假设有一个使用<code>HashSet</code>的程序。 为了调整程序的性能，需要查询<code>HashSe</code>，从创建它之后已经添加了多少个元素（不要和当前的元素数量混淆，当元素被删除时数量也会下降）。 为了提供这个功能，编写了一个<code>HashSet</code>变体，它保留了尝试元素插入的数量，并导出了这个插入数量的一个访问方法。 <code>HashSet</code>类包含两个添加元素的方法，分别是<code>add</code>和<code>addAll</code>，所以我们重写这两个方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// Broken - Inappropriate use of inheritance!</span><br><span class="line">public class InstrumentedHashSet&lt;E&gt; extends HashSet&lt;E&gt; &#123;</span><br><span class="line">    // The number of attempted element insertions</span><br><span class="line">    private int addCount = 0;</span><br><span class="line"></span><br><span class="line">    public InstrumentedHashSet() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public InstrumentedHashSet(int initCap, float loadFactor) &#123;</span><br><span class="line">        super(initCap, loadFactor);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override public boolean add(E e) &#123;</span><br><span class="line">        addCount++;</span><br><span class="line">        return super.add(e);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override public boolean addAll(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">        addCount += c.size();</span><br><span class="line">        return super.addAll(c);</span><br><span class="line">    &#125;</span><br><span class="line">    public int getAddCount() &#123;</span><br><span class="line">        return addCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类看起来很合理，但是不能正常工作。 假设创建一个实例并使用<code>addAll</code>方法添加三个元素。 顺便提一句，请注意，下面代码使用在Java 9中添加的静态工厂方法<code>List.of</code>来创建一个列表；如果使用的是早期版本，请改为使用<code>Arrays.asList</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InstrumentedHashSet&lt;String&gt; s = new InstrumentedHashSet&lt;&gt;();</span><br><span class="line">s.addAll(List.of(&quot;Snap&quot;, &quot;Crackle&quot;, &quot;Pop&quot;));</span><br></pre></td></tr></table></figure><p>我们期望<code>getAddCount</code>方法返回的结果是3，但实际上返回了6。哪里出来问题？在<code>HashSet</code>内部，<code>addAll</code>方法是基于它的<code>add</code>方法来实现的，即使<code>HashSet</code>文档中没有指名其实现细节，倒也是合理的。<code>InstrumentedHashSet</code>中的<code>addAll</code>方法首先给<code>addCount</code>属性设置为3，然后使用<code>super.addAll</code>方法调用了<code>HashSet</code>的<code>addAll</code>实现。然后反过来又调用在<code>InstrumentedHashSet</code>类中重写的<code>add</code>方法，每个元素调用一次。这三次调用又分别给<code>addCount</code>加1，所以，一共增加了6：通过<code>addAll</code>方法每个增加的元素都被计算了两次。</p><p>我们可以通过消除<code>addAll</code>方法的重写来“修复”子类。 尽管生成的类可以正常工作，但是它依赖于它的正确方法，因为<code>HashSet</code>的<code>addAll</code>方法是在其<code>add</code>方法之上实现的。 这个“自我使用（self-use）”是一个实现细节，并不保证在Java平台的所有实现中都可以适用，并且可以随发布版本而变化。 因此，产生的<code>InstrumentedHashSet</code>类是脆弱的。</p><p>稍微好一点的做法是，重写<code>addAll</code>方法遍历指定集合，为每个元素调用<code>add</code>方法一次。 不管<code>HashSet</code>的<code>addAll</code>方法是否在其<code>add</code>方法上实现，都会保证正确的结果，因为<code>HashSet</code>的<code>addAll</code>实现将不再被调用。然而，这种技术并不能解决所有的问题。 这相当于重新实现了父类方法，这样的方法可能不能确定到底是否时自用（self-use）的，实现起来也是困难的，耗时的，容易出错的，并且可能会降低性能。 此外，这种方式并不能总是奏效，因为子类无法访问一些私有属性，所以有些方法就无法实现。</p><p>导致子类脆弱的一个相关原因是，它们的父类在后续的发布版本中可以添加新的方法。假设一个程序的安全性依赖于这样一个事实：所有被插入到集中的元素都满足一个先决条件。可以通过对集合进行子类化，然后并重写所有添加元素的方法，以确保在添加每个元素之前满足这个先决条件，来确保这一问题。如果在后续的版本中，父类没有新增添加元素的方法，那么这样做没有问题。但是，一旦父类增加了这样的新方法，则很有肯能由于调用了未被重写的新方法，将非法的元素添加到子类的实例中。这不是个纯粹的理论问题。在把<code>Hashtable</code>和<code>Vector</code>类加入到Collections框架中的时候，就修复了几个类似性质的安全漏洞。</p><p>这两个问题都源于重写方法。 如果仅仅添加新的方法并且不要重写现有的方法，可能会认为继承一个类是安全的。 虽然这种扩展更为安全，但这并非没有风险。 如果父类在后续版本中添加了一个新的方法，并且你不幸给了子类一个具有相同签名和不同返回类型的方法，那么你的子类编译失败[JLS，8.4.8.3]。 如果已经为子类提供了一个与新的父类方法具有相同签名和返回类型的方法，那么你现在正在重写它，因此将遇到前面所述的问题。 此外，你的方法是否会履行新的父类方法的约定，这是值得怀疑的，因为在你编写子类方法时，这个约定还没有写出来。</p><p>幸运的是，有一种方法可以避免上述所有的问题。不要继承一个现有的类，而应该给你的新类增加一个私有属性，该属性是 现有类的实例引用，这种设计被称为组合（composition），因为现有的类成为新类的组成部分。新类中的每个实例方法调用现有类的包含实例上的相应方法并返回结果。这被称为转发（forwarding），而新类中的方法被称为转发方法。由此产生的类将坚如磐石，不依赖于现有类的实现细节。即使将新的方法添加到现有的类中，也不会对新类产生影响。为了具体说用，下面代码使用组合和转发方法替代<code>InstrumentedHashSet</code>类。请注意，实现分为两部分，类本身和一个可重用的转发类，其中包含所有的转发方法，没有别的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">// Reusable forwarding class</span><br><span class="line">import java.util.Collection;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line">import java.util.Set;</span><br><span class="line"></span><br><span class="line">public class ForwardingSet&lt;E&gt; implements Set&lt;E&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private final Set&lt;E&gt; s;</span><br><span class="line"></span><br><span class="line">    public ForwardingSet(Set&lt;E&gt; s) &#123;</span><br><span class="line">        this.s = s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void clear() &#123;</span><br><span class="line">        s.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean contains(Object o) &#123;</span><br><span class="line">        return s.contains(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isEmpty() &#123;</span><br><span class="line">        return s.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int size() &#123;</span><br><span class="line">        return s.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Iterator&lt;E&gt; iterator() &#123;</span><br><span class="line">        return s.iterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean add(E e) &#123;</span><br><span class="line">        return s.add(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean remove(Object o) &#123;</span><br><span class="line">        return s.remove(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean containsAll(Collection&lt;?&gt; c) &#123;</span><br><span class="line">        return s.containsAll(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean addAll(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">        return s.addAll(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean removeAll(Collection&lt;?&gt; c) &#123;</span><br><span class="line">        return s.removeAll(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean retainAll(Collection&lt;?&gt; c) &#123;</span><br><span class="line">        return s.retainAll(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object[] toArray() &#123;</span><br><span class="line">        return s.toArray();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">        return s.toArray(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean equals(Object o) &#123;</span><br><span class="line">        return s.equals(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int hashCode() &#123;</span><br><span class="line">        return s.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return s.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// Wrapper class - uses composition in place of inheritance</span><br><span class="line">import java.util.Collection;</span><br><span class="line">import java.util.Set;</span><br><span class="line"></span><br><span class="line">public class InstrumentedSet&lt;E&gt; extends ForwardingSet&lt;E&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private int addCount = 0;</span><br><span class="line"></span><br><span class="line">    public InstrumentedSet(Set&lt;E&gt; s) &#123;</span><br><span class="line">        super(s);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override public boolean add(E e) &#123;</span><br><span class="line">        addCount++;</span><br><span class="line">        return super.add(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override public boolean addAll(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">        addCount += c.size();</span><br><span class="line">        return super.addAll(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAddCount() &#123;</span><br><span class="line">        return addCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>InstrumentedSet</code>类的设计是通过存在的Set接口来实现的，该接口包含<code>HashSet</code>类的功能特性。除了功能强大，这个设计是非常灵活的。<code>InstrumentedSet</code>类实现了Set接口，并有一个构造方法，其参数也是Set类型的。本质上，这个类把<code>Set</code>转换为另一个类型<code>Set</code>， 同时添加了计数的功能。与基于继承的方法不同，该方法仅适用于单个具体类，并且父类中每个需要支持构造方法，提供单独的构造方法，所以可以使用包装类来包装任何<code>Set</code>实现，并且可以与任何预先存在的构造方法结合使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Instant&gt; times = new InstrumentedSet&lt;&gt;(new TreeSet&lt;&gt;(cmp));</span><br><span class="line">Set&lt;E&gt; s = new InstrumentedSet&lt;&gt;(new HashSet&lt;&gt;(INIT_CAPACITY));</span><br></pre></td></tr></table></figure><p><code>InstrumentedSet</code>类甚至可以用于临时替换没有计数功能下使用的集合实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static void walk(Set&lt;Dog&gt; dogs) &#123;</span><br><span class="line">    InstrumentedSet&lt;Dog&gt; iDogs = new InstrumentedSet&lt;&gt;(dogs);</span><br><span class="line">    ... // Within this method use iDogs instead of dogs</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>InstrumentedSet</code>类被称为包装类，因为每个<code>InstrumentedSet</code>实例都包含（“包装”）另一个<code>Set</code>实例。 这也被称为装饰器模式[Gamma95]，因为<code>InstrumentedSet</code>类通过添加计数功能来“装饰”一个集合。 有时组合和转发的结合被不精确地地称为委托（delegation）。 从技术上讲，除非包装对象把自身传递给被包装对象，否则不是委托[Lieberman86;Gamma95]。</p><p>包装类的缺点很少。 一个警告是包装类不适合在回调框架（callback frameworks）中使用，其中对象将自我引用传递给其他对象以用于后续调用（“回调”）。 因为一个被包装的对象不知道它外面的包装对象，所以它传递一个指向自身的引用（this），回调时并不记得外面的包装对象。 这被称为SELF问题[Lieberman86]。 有些人担心转发方法调用的性能影响，以及包装对象对内存占用。 两者在实践中都没有太大的影响。 编写转发方法有些繁琐，但是只需为每个接口编写一次可重用的转发类，并且提供转发类。 例如，Guava为所有的Collection接口提供转发类[Guava]。</p><p>只有在子类真的是父类的子类型的情况下，继承才是合适的。 换句话说，只有在两个类之间存在“is-a”关系的情况下，B类才能继承A类。 如果你试图让B类继承A类时，问自己这个问题：每个B都是A吗？ 如果你不能如实回答这个问题，那么B就不应该继承A。如果答案是否定的，那么B通常包含一个A的私有实例，并且暴露一个不同的API：A不是B的重要部分 ，只是其实现细节。</p><p>在Java平台类库中有一些明显的违反这个原则的情况。 例如，stacks实例并不是vector实例，所以<code>Stack</code>类不应该继承<code>Vector</code>类。 同样，一个属性列表不是一个哈希表，所以<code>Properties</code>不应该继承<code>Hashtable</code>类。 在这两种情况下，组合方式更可取。</p><p>如果在合适组合的地方使用继承，则会不必要地公开实现细节。由此产生的API将与原始实现联系在一起，永远限制类的性能。更严重的是，通过暴露其内部，客户端可以直接访问它们。至少，它可能导致混淆语义。例如，属性p指向<code>Properties</code>实例，那么 <code>p.getProperty(key)</code>和<code>p.get(key)</code>就有可能返回不同的结果：前者考虑了默认的属性表，而后者是继承<code>Hashtable</code>的，它则没有考虑默认属性列表。最严重的是，客户端可以通过直接修改超父类来破坏子类的不变性。在<code>Properties</code>类，设计者希望只有字符串被允许作为键和值，但直接访问底层的<code>Hashtable</code>允许违反这个不变性。一旦违反，就不能再使用属性API的其他部分（<code>load</code>和<code>store</code>方法）。在发现这个问题的时候，纠正这个问题为时已晚，因为客户端依赖于使用非字符串键和值了。</p><p>在决定使用继承来代替组合之前，你应该问自己最后一组问题。对于试图继承的类，它的API有没有缺陷呢？ 如果有，你是否愿意将这些缺陷传播到你的类的API中？继承传播父类的API中的任何缺陷，而组合可以让你设计一个隐藏这些缺陷的新API。</p><p>总之，继承是强大的，但它是有问题的，因为它违反封装。 只有在子类和父类之间存在真正的子类型关系时才适用。 即使如此，如果子类与父类不在同一个包中，并且父类不是为继承而设计的，继承可能会导致脆弱性。 为了避免这种脆弱性，使用合成和转发代替继承，特别是如果存在一个合适的接口来实现包装类。 包装类不仅比子类更健壮，而且更强大。</p><h2 id="19-如果使用继承则设计，并文档说明，否则不该使用"><a href="#19-如果使用继承则设计，并文档说明，否则不该使用" class="headerlink" title="19. 如果使用继承则设计，并文档说明，否则不该使用"></a>19. 如果使用继承则设计，并文档说明，否则不该使用</h2><p>条目 18中提醒你注意继承没有设计和文档说明的“外来”类的子类化的危险。 那么为了继承而设计和文档说明一个类是什么意思呢？</p><p>首先，这个类必须准确地描述重写这个方法带来的影响。 换句话说，该类必须文档说明可重写方法的自用性（self-use）。 对于每个公共或受保护的方法，文档必须指明方法调用哪些重写方法，以何种顺序以及每次调用的结果如何影响后续处理。 （重写方法，这里是指非final修饰的方法，无论是公开还是保护的。）更一般地说，一个类必须文档说明任何可能调用可重写方法的情况。 例如，后台线程或者静态初始化代码块可能会调用这样的方法。</p><p>调用可重写方法的方法在文档注释结束时包含对这些调用的描述。 这些描述在规范中特定部分，标记为“Implementation Requirements,”，由Javadoc标签<code>@implSpec</code>生成。 本节介绍该方法的内部工作原理。 下面是从<code>java.util.AbstractCollection</code>类的规范中拷贝的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public boolean remove(Object o)</span><br><span class="line">Removes a single instance of the specified element from this collection, if it is present (optional operation). More formally, removes an element e such that Objects.equals(o, e), if this collection contains one or more such elements. Returns true if this collection contained the specified element (or equivalently, if this collection changed as a result of the call).</span><br><span class="line"></span><br><span class="line">Implementation Requirements: This implementation iterates over the collection looking for the specified element. If it finds the element, it removes the element from the collection using the iterator’s remove method. Note that this implementation throws an UnsupportedOperationException if the iterator returned by this collection’s iterator method does not implement the remove method and this collection contains the specified object.</span><br></pre></td></tr></table></figure><p>从该集合中删除指定元素的单个实例（如果存在，<code>optional</code>实例操作）。 更正式地说，如果这个集合包含一个或多个这样的元素，删除使得<code>Objects.equals(o, e)</code>的一个元素e。 如果此集合包含指定的元素（或者等同于此集合因调用而发生了更改），则返回true。</p><p><strong>实现要求</strong>：这个实现迭代遍历集合查找指定元素。 如果找到元素，则使用迭代器的<code>remove</code>方法从集合中删除元素。 请注意，如果此集合的<code>iterator</code>方法返回的迭代器未实现<code>remove</code>方法，并且此集合包含指定的对象，则此实现将引发<code>UnsupportedOperationException</code>异常。</p><p>这个文档毫无疑问地说明，重写<code>iterator</code>方法会影响<code>remove</code>方法的行为。 它还描述了<code>iterator</code>方法返回的Iterator行为将如何影响<code>remove</code>方法的行为。 与条目 18中的情况相反，在这种情况下，程序员继承<code>HashSet</code>并不能说明重写add方法是否会影响addAll方法的行为。</p><p>但是，这是否违背了一个良好的API文档应该描述给定的方法是什么，而不是它是如何做的呢？ 是的，它确实！这是继承违反封装这一事实的不幸后果。要文档说明一个类以便可以安全地进行子类化，必须描述清楚那些没有详细说明的实现细节。</p><p><code>@implSpec</code>标签是在Java 8中添加的，并且在Java 9中被大量使用。这个标签应该默认启用，但是从Java 9开始，除非通过命令行开关<code>-tag &quot;apiNote:a:API Note:”</code>，否则Javadoc实用工具仍然会忽略它。</p><p>设计继承涉及的不仅仅是文档说明自用的模式。 为了让程序员能够写出有效的子类而不会带来不适当的痛苦，一个类可能以明智选择的受保护方法的形式提供内部工作，或者在罕见的情况下，提供受保护的属性。 例如，考虑<code>java.util.AbstractList</code>中的<code>removeRange</code>方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">protected void removeRange(int fromIndex, int toIndex)</span><br><span class="line">Removes from this list all of the elements whose index is between fromIndex, inclusive, and toIndex, exclusive. Shifts any succeeding elements to the left (reduces their index). This call shortens the list by (toIndex - fromIndex) elements. (If toIndex == fromIndex, this operation has no effect.)</span><br><span class="line">This method is called by the clear operation on this list and its sublists. Overriding this method to take advantage of the internals of the list implementation can substantially improve the performance of the clear operation on this list and its sublists.</span><br><span class="line">Implementation Requirements: This implementation gets a list iterator positioned before fromIndex and repeatedly calls ListIterator.nextfollowed by ListIterator.remove, until the entire range has been removed. Note: If ListIterator.remove requires linear time, this implementation requires quadratic time.</span><br><span class="line">Parameters:</span><br><span class="line">fromIndex       index of first element to be removed.</span><br><span class="line"></span><br><span class="line">toIndex           index after last element to be removed.</span><br></pre></td></tr></table></figure><p>从此列表中删除索引介于<code>fromIndex</code>（包含）和<code>inclusive</code>（不含）之间的所有元素。 将任何后续元素向左移（减少索引）。 这个调用通过<code>（toIndex - fromIndex）</code>元素来缩短列表。 （如果<code>toIndex == fromIndex</code>，则此操作无效。）</p><p>这个方法是通过列表及其子类的clear操作来调用的。重写这个方法利用列表内部实现的优势，可以大大提高列表和子类的clear操作性能。</p><p>实现要求：这个实现获取一个列表迭代器，它位于<code>fromIndex</code>之前，并重复调用<code>ListIterator.remove</code>和<code>ListIterator.next</code>方法，直到整个范围被删除。 注意：如果<code>ListIterator.remove</code>需要线性时间，则此实现需要平方级时间。</p><p>参数：<br>fromIndex 要移除的第一个元素的索引<br>toIndex 要移除的最后一个元素之后的索引</p><p>这个方法对List实现的最终用户来说是没有意义的。 它仅仅是为了使子类很容易提供一个快速clear方法。 在没有<code>removeRange</code>方法的情况下，当在子列表上调用clear方法，子类将不得不使用平方级的时间，否则，或从头重写整个subList机制——这不是一件容易的事情！</p><p>那么当你设计一个继承类的时候，你如何决定暴露哪些的受保护的成员呢？ 不幸的是，没有灵丹妙药。 所能做的最好的就是努力思考，做出最好的测试，然后通过编写子类来进行测试。 应该尽可能少地暴露受保护的成员，因为每个成员都表示对实现细节的承诺。 另一方面，你不能暴露太少，因为失去了保护的成员会导致一个类几乎不能用于继承。</p><p><strong>测试为继承而设计的类的唯一方法是编写子类</strong>。 如果你忽略了一个关键的受保护的成员，试图编写一个子类将会使得遗漏痛苦地变得明显。 相反，如果编写的几个子类，而且没有一个使用受保护的成员，那么应该将其设为私有。 经验表明，三个子类通常足以测试一个可继承的类。 这些子类应该由父类作者以外的人编写。</p><p>当你为继承设计一个可能被广泛使用的类的时候，要意识到你永远承诺你文档说明的自用模式以及隐含在其保护的方法和属性中的实现决定。 这些承诺可能会使后续版本中改善类的性能或功能变得困难或不可能。 因此，<strong>在发布它之前，你必须通过编写子类来测试你的类</strong>。</p><p>另外，请注意，继承所需的特殊文档混乱了正常的文档，这是为创建类的实例并在其上调用方法的程序员设计的。 在撰写本文时，几乎没有工具将普通的API文档从和仅仅针对子类实现的信息，分离出来。</p><p>还有一些类必须遵守允许继承的限制。 <strong>构造方法绝不能直接或间接调用可重写的方法</strong>。 如果违反这个规则，将导致程序失败。 父类构造方法在子类构造方法之前运行，所以在子类构造方法运行之前，子类中的重写方法被调用。 如果重写方法依赖于子类构造方法执行的任何初始化，则此方法将不会按预期运行。 为了具体说明，这是一个违反这个规则的类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Super &#123;</span><br><span class="line">    // Broken - constructor invokes an overridable method</span><br><span class="line">    public Super() &#123;</span><br><span class="line">        overrideMe();</span><br><span class="line">    &#125;</span><br><span class="line">    public void overrideMe() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是一个重写<code>overrideMe</code>方法的子类，Super类的唯一构造方法会错误地调用它：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public final class Sub extends Super &#123;</span><br><span class="line">    // Blank final, set by constructor</span><br><span class="line">    private final Instant instant;</span><br><span class="line"></span><br><span class="line">    Sub() &#123;</span><br><span class="line">        instant = Instant.now();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Overriding method invoked by superclass constructor</span><br><span class="line">    @Override public void overrideMe() &#123;</span><br><span class="line">        System.out.println(instant);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Sub sub = new Sub();</span><br><span class="line">        sub.overrideMe();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可能期望这个程序打印两次<code>instant</code>实例，但是它第一次打印出null，因为在Sub构造方法有机会初始化<code>instant</code>属性之前，<code>overrideMe</code>被Super构造方法调用。 请注意，这个程序观察两个不同状态的final属性！ 还要注意的是，如果<code>overrideMe</code>方法调用了<code>instant</code>实例中任何方法，那么当父类构造方法调用<code>overrideMe</code>时，它将抛出一个<code>NullPointerException</code>异常。 这个程序不会抛出<code>NullPointerException</code>的唯一原因是<code>println</code>方法容忍null参数。</p><p>请注意，从构造方法中调用私有方法，其中任何一个方法都不可重写的，那么final方法和静态方法是安全的。</p><p><code>Cloneable</code>和<code>Serializable</code>接口在设计继承时会带来特殊的困难。 对于为继承而设计的类来说，实现这些接口通常不是一个好主意，因为这会给继承类的程序员带来很大的负担。 然而，可以采取特殊的行动来允许子类实现这些接口，而不需要强制这样做。 这些操作在条目 13和条目 86中有描述。</p><p>如果你决定在为继承而设计的类中实现<code>Cloneable</code>或<code>Serializable</code>接口，那么应该知道，由于<code>clone</code>和<code>readObjec</code>t方法与构造方法相似，所以也有类似的限制：<strong>clone和readObject都不会直接或间接调用可重写的方法</strong>。在<code>readObject</code>的情况下，重写方法将在子类的状态被反序列化之前运行。 在<code>clone</code>的情况下，重写方法将在子类的<code>clone</code>方法有机会修复克隆的状态之前运行。 在任何一种情况下，都可能会出现程序故障。 在<code>clone</code>的情况下，故障可能会损坏原始对象以及被克隆对象本身。 例如，如果重写方法假定它正在修改对象的深层结构的拷贝，但是尚未创建拷贝，则可能发生这种情况。</p><p>最后，如果你决定在为继承设计的类中实现<code>Serializable</code>接口，并且该类有一个<code>readResolve</code>或<code>writeReplace</code>方法，则必须使<code>readResolve</code>或<code>writeReplace</code>方法设置为受保护而不是私有。 如果这些方法是私有的，它们将被子类无声地忽略。 这是另一种情况，把实现细节成为类的API的一部分，以允许继承。</p><p>到目前为止，<strong>设计一个继承类需要很大的努力，并且对这个类有很大的限制</strong>。 这不是一个轻率的决定。 有些情况显然是正确的，比如抽象类，包括接口的骨架实现（skeletal implementations）（条目 20）。 还有其他的情况显然是错误的，比如不可变的类（条目 17）。</p><p>但是普通的具体类呢？ 传统上，它们既不是final的，也不是为了子类化而设计和文档说明的，但是这种情况是危险的。每次修改这样的类，则继承此类的子类将被破坏。 这不仅仅是一个理论问题。 在修改非final的具体类的内部之后，接收与子类相关的错误报告并不少见，这些类没有为继承而设计和文档说明。</p><p><strong>解决这个问题的最好办法是，在没有想要安全地子类化的设计和文档说明的类中禁止子类化</strong>。 有两种方法禁止子类化。 两者中较容易的是声明类为final。 另一种方法是使所有的构造方法都是私有的或包级私有的，并且添加公共静态工厂来代替构造方法。 这个方案在内部提供了使用子类的灵活性，在条目 17中讨论过。两种方法都是可以接受的。</p><p>这个建议可能有些争议，因为许多程序员已经习惯于继承普通的具体类来增加功能，例如通知和同步等功能，或限制原有类的功能。 如果一个类实现了捕获其本质的一些接口，比如Set，List或Map，那么不应该为了禁止子类化而感到愧疚。 在条目 18中描述的包装类模式为增强功能提供了继承的优越选择。</p><p>如果一个具体的类没有实现一个标准的接口，那么你可能会通过禁止继承来给一些程序员带来不便。 如果你觉得你必须允许从这样的类继承，一个合理的方法是确保类从不调用任何可重写的方法，并文档说明这个事实。 换句话说，完全消除类的自用（self-use）的可重写的方法。 这样做，你将创建一个合理安全的子类。 重写一个方法不会影响任何其他方法的行为。</p><p>你可以机械地消除类的自我使用的重写方法，而不会改变其行为。 将每个可重写的方法的主体移动到一个私有的“帮助器方法”，并让每个可重写的方法调用其私有的帮助器方法。 然后用直接调用可重写方法的专用帮助器方法来替换每个自用的可重写方法。</p><p>你可以机械地消除类的自用的重写方法，而不会改变其行为。 将每个可重写的方法的主体移到一个私有的“辅助方法（helper method）”，并让每个可重写的方法调用其私有的辅助方法。 然后用直接调用可重写方法的专用辅助方法来替换每个自用的可重写方法。</p><p>总之，设计一个继承类是一件很辛苦的事情。 你必须文档说明所有的自用模式，一旦你文档说明了它们，必须承诺为他们的整个生命周期。 如果你不这样做，子类可能会依赖于父类的实现细节，并且如果父类的实现发生改变，子类可能会损坏。 为了允许其他人编写高效的子类，可能还需要导出一个或多个受保护的方法。 除非你知道有一个真正的子类需要，否则你可能最好是通过声明你的类为final禁止继承，或者确保没有可访问的构造方法。</p><h2 id="20-接口优于抽象类"><a href="#20-接口优于抽象类" class="headerlink" title="20. 接口优于抽象类"></a>20. 接口优于抽象类</h2><p>Java有两种机制来定义允许多个实现的类型：接口和抽象类。 由于在Java 8 [JLS 9.4.3]中引入了接口的默认方法（default methods ），因此这两种机制都允许为某些实例方法提供实现。 一个主要的区别是要实现由抽象类定义的类型，类必须是抽象类的子类。 因为Java只允许单一继承，所以对抽象类的这种限制严格限制了它们作为类型定义的使用。 任何定义所有必需方法并服从通用约定的类都可以实现一个接口，而不管类在类层次结构中的位置。</p><p><strong>现有的类可以很容易地进行改进来实现一个新的接口</strong>。 你只需添加所需的方法（如果尚不存在的话），并向类声明中添加一个<code>implements</code>子句。 例如，当<code>Comparable</code>, <code>Iterable</code>， 和<code>Autocloseable</code>接口添加到Java平台时，很多现有类需要实现它们来加以改进。 一般来说，现有的类不能改进以继承一个新的抽象类。 如果你想让两个类继承相同的抽象类，你必须把它放在类型层级结构中的上面位置，它是两个类的祖先。 不幸的是，这会对类型层级结构造成很大的附带损害，迫使新的抽象类的所有后代对它进行子类化，无论这些后代类是否合适。</p><p><strong>接口是定义混合类型（mixin）的理想选择</strong>。 一般来说，mixin是一个类，除了它的“主类型”之外，还可以声明它提供了一些可选的行为。 例如，<code>Comparable</code>是一个类型接口，它允许一个类声明它的实例相对于其他可相互比较的对象是有序的。 这样的接口被称为类型，因为它允许可选功能被“混合”到类型的主要功能。 抽象类不能用于定义混合类，这是因为它们不能被加载到现有的类中：一个类不能有多个父类，并且在类层次结构中没有合理的位置来插入一个类型。</p><p><strong>接口允许构建非层级类型的框架</strong>。 类型层级对于组织某些事物来说是很好的，但是其他的事物并不是整齐地落入严格的层级结构中。 例如，假设我们有一个代表歌手的接口，另一个代表作曲家的接口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface Singer &#123;</span><br><span class="line">    AudioClip sing(Song s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface Songwriter &#123;</span><br><span class="line">    Song compose(int chartPosition);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在现实生活中，一些歌手也是作曲家。 因为我们使用接口而不是抽象类来定义这些类型，所以单个类实现歌手和作曲家两个接口是完全允许的。 事实上，我们可以定义一个继承歌手和作曲家的第三个接口，并添加适合于这个组合的新方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface SingerSongwriter extends Singer, Songwriter &#123;</span><br><span class="line">    AudioClip strum();</span><br><span class="line"></span><br><span class="line">    void actSensitive();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你并不总是需要这种灵活性，但是当你这样做的时候，接口是一个救星。 另一种方法是对于每个受支持的属性组合，包含一个单独的类的臃肿类层级结构。 如果类型系统中有n个属性，则可能需要支持2n种可能的组合。 这就是所谓的组合爆炸（combinatorial explosion）。 臃肿的类层级结构可能会导致具有许多方法的臃肿类，这些方法仅在参数类型上有所不同，因为类层级结构中没有类型来捕获通用行为。</p><p><strong>接口通过包装类模式确保安全的，强大的功能增强成为可能（条目 18）</strong>。 如果使用抽象类来定义类型，那么就让程序员想要添加功能，只能继承。 生成的类比包装类更弱，更脆弱。</p><p>当其他接口方法有明显的接口方法实现时，可以考虑向程序员提供默认形式的方法实现帮助。 有关此技术的示例，请参阅第104页的<code>removeIf</code>方法。如果提供默认方法，请确保使用<code>@implSpec</code> Javadoc标记（条目19）将它们文档说明为继承。</p><p>使用默认方法可以提供实现帮助多多少少是有些限制的。 尽管许多接口指定了<code>Object</code>类中方法（如<code>equals</code>和<code>hashCode</code>）的行为，但不允许为它们提供默认方法。 此外，接口不允许包含实例属性或非公共静态成员（私有静态方法除外）。 最后，不能将默认方法添加到不受控制的接口中。</p><p>但是，你可以通过提供一个抽象的骨架实现类（abstract skeletal implementation class）来与接口一起使用，将接口和抽象类的优点结合起来。 接口定义了类型，可能提供了一些默认的方法，而骨架实现类在原始接口方法的顶层实现了剩余的非原始接口方法。 继承骨架实现需要大部分的工作来实现一个接口。 这就是模板方法设计模式[Gamma95]。</p><p>按照惯例，骨架实现类被称为AbstractInterface，其中Interface是它们实现的接口的名称。 例如，集合框架（ Collections Framework）提供了一个框架实现以配合每个主要集合接口：<code>AbstractCollection</code>，<code>AbstractSet</code>，<code>AbstractList</code>和<code>AbstractMap</code>。 可以说，将它们称为<code>SkeletalCollection</code>，<code>SkeletalSet</code>，<code>SkeletalList</code>和<code>SkeletalMap</code>是有道理的，但是现在已经确立了抽象约定。 如果设计得当，骨架实现（无论是单独的抽象类还是仅由接口上的默认方法组成）可以使程序员非常容易地提供他们自己的接口实现。 例如，下面是一个静态工厂方法，在<code>AbstractList</code>的顶层包含一个完整的功能齐全的List实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// Concrete implementation built atop skeletal implementation</span><br><span class="line"></span><br><span class="line">static List&lt;Integer&gt; intArrayAsList(int[] a) &#123;</span><br><span class="line"></span><br><span class="line">    Objects.requireNonNull(a);</span><br><span class="line"></span><br><span class="line">    // The diamond operator is only legal here in Java 9 and later</span><br><span class="line"></span><br><span class="line">    // If you&apos;re using an earlier release, specify &lt;Integer&gt;</span><br><span class="line"></span><br><span class="line">    return new AbstractList&lt;&gt;() &#123;</span><br><span class="line"></span><br><span class="line">        @Override public Integer get(int i) &#123;</span><br><span class="line"></span><br><span class="line">            return a[i];  // Autoboxing ([Item 6](https://www.safaribooksonline.com/library/view/effective-java-third/9780134686097/ch2.xhtml#lev6))</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override public Integer set(int i, Integer val) &#123;</span><br><span class="line"></span><br><span class="line">            int oldVal = a[I];</span><br><span class="line"></span><br><span class="line">            a[i] = val;     // Auto-unboxing</span><br><span class="line"></span><br><span class="line">            return oldVal;  // Autoboxing</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override public int size() &#123;</span><br><span class="line"></span><br><span class="line">            return a.length;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当你考虑一个List实现为你做的所有事情时，这个例子是一个骨架实现的强大的演示。 顺便说一句，这个例子是一个适配器（Adapter ）[Gamma95]，它允许一个int数组被看作<code>Integer</code>实例列表。 由于int值和整数实例（装箱和拆箱）之间的来回转换，其性能并不是非常好。 请注意，实现采用匿名类的形式（条目 24）。</p><p>骨架实现类的优点在于，它们提供抽象类的所有实现的帮助，而不会强加抽象类作为类型定义时的严格约束。对于具有骨架实现类的接口的大多数实现者来说，继承这个类是显而易见的选择，但它不是必需的。如果一个类不能继承骨架的实现，这个类可以直接实现接口。该类仍然受益于接口本身的任何默认方法。此外，骨架实现类仍然可以协助接口的实现。实现接口的类可以将接口方法的调用转发给继承骨架实现的私有内部类的包含实例。这种被称为模拟多重继承的技术与条目 18讨论的包装类模式密切相关。它提供了多重继承的许多好处，同时避免了缺陷。</p><p>编写一个骨架的实现是一个相对简单的过程，虽然有些乏味。 首先，研究接口，并确定哪些方法是基本的，其他方法可以根据它们来实现。 这些基本方法是你的骨架实现类中的抽象方法。 接下来，为所有可以直接在基本方法之上实现的方法提供接口中的默认方法，回想一下，你可能不会为诸如<code>Object</code>类中<code>equals</code>和<code>hashCode</code>等方法提供默认方法。 如果基本方法和默认方法涵盖了接口，那么就完成了，并且不需要骨架实现类。 否则，编写一个声明实现接口的类，并实现所有剩下的接口方法。 为了适合于该任务，此类可能包含任何的非公共属性和方法。</p><p>作为一个简单的例子，考虑一下<code>Map.Entry接口。 显而易见的基本方法是</code>getKey<code>，getValue</code>和（可选的）<code>setValue</code>。 接口指定了<code>equals</code>和<code>hashCode</code>的行为，并且在基本方面方面有一个<code>toString</code>的明显的实现。 由于不允许为Object类方法提供默认实现，因此所有实现均放置在骨架实现类中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">// Skeletal implementation class</span><br><span class="line"></span><br><span class="line">public abstract class AbstractMapEntry&lt;K,V&gt;</span><br><span class="line"></span><br><span class="line">        implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    // Entries in a modifiable map must override this method</span><br><span class="line"></span><br><span class="line">    @Override public V setValue(V value) &#123;</span><br><span class="line"></span><br><span class="line">        throw new UnsupportedOperationException();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Implements the general contract of Map.Entry.equals</span><br><span class="line"></span><br><span class="line">    @Override public boolean equals(Object o) &#123;</span><br><span class="line"></span><br><span class="line">        if (o == this)</span><br><span class="line"></span><br><span class="line">            return true;</span><br><span class="line"></span><br><span class="line">        if (!(o instanceof Map.Entry))</span><br><span class="line"></span><br><span class="line">            return false;</span><br><span class="line"></span><br><span class="line">        Map.Entry&lt;?,?&gt; e = (Map.Entry) o;</span><br><span class="line"></span><br><span class="line">        return Objects.equals(e.getKey(),  getKey())</span><br><span class="line"></span><br><span class="line">            &amp;&amp; Objects.equals(e.getValue(), getValue());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Implements the general contract of Map.Entry.hashCode</span><br><span class="line"></span><br><span class="line">    @Override public int hashCode() &#123;</span><br><span class="line"></span><br><span class="line">        return Objects.hashCode(getKey())</span><br><span class="line"></span><br><span class="line">             ^ Objects.hashCode(getValue());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override public String toString() &#123;</span><br><span class="line"></span><br><span class="line">        return getKey() + &quot;=&quot; + getValue();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，这个骨架实现不能在<code>Map.Entry</code>接口中实现，也不能作为子接口实现，因为默认方法不允许重写诸如<code>equals</code>，<code>hashCode</code>和<code>toString</code>等<code>Object</code>类方法。</p><p>由于骨架实现类是为了继承而设计的，所以你应该遵循条目 19中的所有设计和文档说明。为了简洁起见，前面的例子中省略了文档注释，但是<strong>好的文档在骨架实现中是绝对必要的</strong>，无论它是否包含 一个接口或一个单独的抽象类的默认方法。</p><p>与骨架实现有稍许不同的是简单实现，以<code>AbstractMap.SimpleEntry</code>为例。 一个简单的实现就像一个骨架实现，它实现了一个接口，并且是为了继承而设计的，但是它的不同之处在于它不是抽象的：它是最简单的工作实现。 你可以按照情况使用它，也可以根据情况进行子类化。</p><p>总而言之，一个接口通常是定义允许多个实现的类型的最佳方式。 如果你导出一个重要的接口，应该强烈考虑提供一个骨架的实现类。 在可能的情况下，应该通过接口上的默认方法提供骨架实现，以便接口的所有实现者都可以使用它。 也就是说，对接口的限制通常要求骨架实现类采用抽象类的形式。</p><h2 id="21-为后代设计接口"><a href="#21-为后代设计接口" class="headerlink" title="21. 为后代设计接口"></a>21. 为后代设计接口</h2><p>在Java 8之前，不可能在不破坏现有实现的情况下为接口添加方法。 如果向接口添加了一个新方法，现有的实现通常会缺少该方法，从而导致编译时错误。 在Java 8中，添加了默认方法（ default method）构造[JLS 9.4]，目的是允许将方法添加到现有的接口。 但是增加新的方法到现有的接口是充满风险的。</p><p>默认方法的声明包含一个默认实现，该方法允许实现接口的类直接使用，而不必实现默认方法。 虽然在Java中添加默认方法可以将方法添加到现有接口，但不能保证这些方法可以在所有已有的实现中使用。 默认的方法被“注入（injected）”到现有的实现中，没有经过实现类的知道或同意。 在Java 8之前，这些实现是用默认的接口编写的，它们的接口永远不会获得任何新的方法。</p><p>许多新的默认方法被添加到Java 8的核心集合接口中，主要是为了方便使用lambda表达式（第6章）。 Java类库的默认方法是高质量的通用实现，在大多数情况下，它们工作正常。 但是，<strong>编写一个默认方法并不总是可能的，它保留了每个可能的实现的所有不变量</strong>。</p><p>例如，考虑在Java 8中添加到Collection接口的<code>removeIf</code>方法。例如，考虑在Java 8中添加到Collection接口的<code>removeIf</code>方法。此方法删除给定布尔方法（或<code>Predicate</code>函数式接口）返回true的所有元素。默认实现被指定为使用迭代器遍历集合，调用每个元素的谓词，并使用迭代器的<code>remove</code>方法删除谓词返回true的元素。 据推测，这个声明看起来像这样：默认实现被指定为使用迭代器遍历集合，调用每个元素的<code>Predicate</code>函数式接口，并使用迭代器的<code>remove</code>方法删除Predicate函数式接口返回true的元素。 根据推测，这个声明看起来像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// Default method added to the Collection interface in Java 8</span><br><span class="line"></span><br><span class="line">default boolean removeIf(Predicate&lt;? super E&gt; filter) &#123;</span><br><span class="line"></span><br><span class="line">    Objects.requireNonNull(filter);</span><br><span class="line"></span><br><span class="line">    boolean result = false;</span><br><span class="line"></span><br><span class="line">    for (Iterator&lt;E&gt; it = iterator(); it.hasNext(); ) &#123;</span><br><span class="line"></span><br><span class="line">        if (filter.test(it.next())) &#123;</span><br><span class="line"></span><br><span class="line">            it.remove();</span><br><span class="line"></span><br><span class="line">            result = true;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是可能为<code>removeIf</code>方法编写的最好的通用实现，但遗憾的是，它在一些实际的Collection实现中失败了。 例如，考虑<code>org.apache.commons.collections4.collection.SynchronizedCollection</code>方法。 这个类出自Apache Commons类库中，与java.util包中的静态工厂<code>Collections.synchronizedCollection</code>方法返回的类相似。 Apache版本还提供了使用客户端提供的对象进行锁定的能力，以代替集合。 换句话说，它是一个包装类（条目 18），它们的所有方法在委托给包装集合类之前在一个锁定对象上进行同步。</p><p>Apache的<code>SynchronizedCollection</code>类仍然在积极维护，但在撰写本文时，并未重写<code>removeIf</code>方法。 如果这个类与Java 8一起使用，它将继承<code>removeIf</code>的默认实现，但实际上不能保持类的基本承诺：自动同步每个方法调用。 默认实现对同步一无所知，并且不能访问包含锁定对象的属性。 如果客户端在另一个线程同时修改集合的情况下调用<code>SynchronizedCollection</code>实例上的<code>removeIf</code>方法，则可能会导致<code>ConcurrentModificationException</code>异常或其他未指定的行为。</p><p>为了防止在类似的Java平台类库实现中发生这种情况，比如<code>Collections.synchronizedCollection</code>返回的包级私有的类，JDK维护者必须重写默认的<code>removeIf</code>实现和其他类似的方法来在调用默认实现之前执行必要的同步。 原来不属于Java平台的集合实现没有机会与接口更改进行类似的改变，有些还没有这样做。</p><p><strong>在默认方法的情况下，接口的现有实现类可以在没有错误或警告的情况下编译，但在运行时会失败</strong>。 虽然不是非常普遍，但这个问题也不是一个孤立的事件。 在Java 8中添加到集合接口的一些方法已知是易受影响的，并且已知一些现有的实现会受到影响。</p><p>应该避免使用默认方法向现有的接口添加新的方法，除非这个需要是关键的，在这种情况下，你应该仔细考虑，以确定现有的接口实现是否会被默认的方法实现所破坏。然而，默认方法对于在创建接口时提供标准的方法实现非常有用，以减轻实现接口的任务（条目 20）。</p><p>还值得注意的是，默认方法不是被用来设计，来支持从接口中移除方法或者改变现有方法的签名的目的。在不破坏现有客户端的情况下，这些接口都不可能发生更改。</p><p>准则是清楚的。 尽管默认方法现在是Java平台的一部分，<strong>但是非常悉心地设计接口仍然是非常重要的</strong>。 虽然默认方法可以将方法添加到现有的接口，但这样做有很大的风险。 如果一个接口包含一个小缺陷，可能会永远惹怒用户。 如果一个接口严重缺陷，可能会破坏包含它的API。</p><p>因此，在发布之前测试每个新接口是非常重要的。 多个程序员应该以不同的方式实现每个接口。 至少，你应该准备三种不同的实现。 编写多个使用每个新接口的实例来执行各种任务的客户端程序同样重要。 这将大大确保每个接口都能满足其所有的预期用途。 这些步骤将允许你在发布之前发现接口中的缺陷，但仍然可以轻松地修正它们。 <strong>虽然在接口被发布后可能会修正一些存在的缺陷，但不要太指望这一点</strong>。</p><h2 id="22-接口仅用来定义类型"><a href="#22-接口仅用来定义类型" class="headerlink" title="22. 接口仅用来定义类型"></a>22. 接口仅用来定义类型</h2><p>当类实现接口时，该接口作为一种类型（type），可以用来引用类的实例。因此，一个类实现了一个接口，因此表明客户端可以如何处理类的实例。为其他目的定义接口是不合适的。</p><p>一种失败的接口就是所谓的常量接口（constant interface）。 这样的接口不包含任何方法; 它只包含静态final属性，每个输出一个常量。 使用这些常量的类实现接口，以避免需要用类名限定常量名。 这里是一个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// Constant interface antipattern - do not use!</span><br><span class="line">public interface PhysicalConstants &#123;</span><br><span class="line">    // Avogadro&apos;s number (1/mol)</span><br><span class="line">    static final double AVOGADROS_NUMBER   = 6.022_140_857e23;</span><br><span class="line"></span><br><span class="line">    // Boltzmann constant (J/K)</span><br><span class="line">    static final double BOLTZMANN_CONSTANT = 1.380_648_52e-23;</span><br><span class="line"></span><br><span class="line">    // Mass of the electron (kg)</span><br><span class="line">    static final double ELECTRON_MASS      = 9.109_383_56e-31;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>常量接口模式是对接口的糟糕使用</strong>。类在内部使用一些常量，完全属于实现细节。实现一个常量接口会导致这个实现细节泄漏到类的导出API中。对类的用户来说，类实现一个常量接口是没有意义的。事实上，它甚至可能使他们感到困惑。更糟糕的是，它代表了一个承诺：如果在将来的版本中修改了类，不再需要使用常量，那么它仍然必须实现接口，以确保二进制兼容性。如果一个非final类实现了常量接口，那么它的所有子类的命名空间都会被接口中的常量所污染。</p><p>Java平台类库中有多个常量接口，如<code>java.io.ObjectStreamConstants</code>。 这些接口应该被视为不规范的，不应该被效仿。</p><p>如果你想导出常量，有几个合理的选择方案。 如果常量与现有的类或接口紧密相关，则应将其添加到该类或接口中。 例如，所有数字基本类型的包装类，如<code>Integer</code>和<code>Double</code>，都会导出<code>MIN_VALUE</code>和<code>MAX_VALUE</code>常量。 如果常量最好被看作枚举类型的成员，则应该使用枚举类型（条目 34）导出它们。 否则，你应该用一个不可实例化的工具类来导出常量（条目 4）。 下是前面所示的<code>PhysicalConstants</code>示例的工具类的版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// Constant utility class</span><br><span class="line">package com.effectivejava.science;</span><br><span class="line"></span><br><span class="line">public class PhysicalConstants &#123;</span><br><span class="line">  private PhysicalConstants() &#123; &#125;  // Prevents instantiation</span><br><span class="line"></span><br><span class="line">  public static final double AVOGADROS_NUMBER = 6.022_140_857e23;</span><br><span class="line">  public static final double BOLTZMANN_CONST  = 1.380_648_52e-23;</span><br><span class="line">  public static final double ELECTRON_MASS    = 9.109_383_56e-31;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顺便提一下，请注意在数字文字中使用下划线字符（_）。 从Java 7开始，合法的下划线对数字字面量的值没有影响，但是如果使用得当的话可以使它们更容易阅读。 无论是固定的浮点数，如果他们包含五个或更多的连续数字，考虑将下划线添加到数字字面量中。 对于底数为10的数字，无论是整型还是浮点型的，都应该用下划线将数字分成三个数字组，表示一千的正负幂。</p><p>通常，实用工具类要求客户端使用类名来限定常量名，例如<code>PhysicalConstants.AVOGADROS_NUMBER</code>。 <strong>如果大量使用实用工具类导出的常量，则通过使用静态导入来限定具有类名的常量</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// Use of static import to avoid qualifying constants</span><br><span class="line">import static com.effectivejava.science.PhysicalConstants.*;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line">    double  atoms(double mols) &#123;</span><br><span class="line">        return AVOGADROS_NUMBER * mols;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    // Many more uses of PhysicalConstants justify static import</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总之，接口只能用于定义类型。 它们不应该仅用于导出常量。</p><h2 id="23-优先使用类层次而不是标签类"><a href="#23-优先使用类层次而不是标签类" class="headerlink" title="23. 优先使用类层次而不是标签类"></a>23. 优先使用类层次而不是标签类</h2><p>有时你可能会碰到一个类，它的实例有两个或更多的风格，并且包含一个标签属性（tag field），表示实例的风格。 例如，考虑这个类，它可以表示一个圆形或矩形：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">// Tagged class - vastly inferior to a class hierarchy!</span><br><span class="line">class Figure &#123;</span><br><span class="line">    enum Shape &#123; RECTANGLE, CIRCLE &#125;;</span><br><span class="line"></span><br><span class="line">    // Tag field - the shape of this figure</span><br><span class="line">    final Shape shape;</span><br><span class="line"></span><br><span class="line">    // These fields are used only if shape is RECTANGLE</span><br><span class="line">    double length;</span><br><span class="line">    double width;</span><br><span class="line"></span><br><span class="line">    // This field is used only if shape is CIRCLE</span><br><span class="line">    double radius;</span><br><span class="line"></span><br><span class="line">    // Constructor for circle</span><br><span class="line">    Figure(double radius) &#123;</span><br><span class="line">        shape = Shape.CIRCLE;</span><br><span class="line">        this.radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Constructor for rectangle</span><br><span class="line">    Figure(double length, double width) &#123;</span><br><span class="line">        shape = Shape.RECTANGLE;</span><br><span class="line">        this.length = length;</span><br><span class="line">        this.width = width;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    double area() &#123;</span><br><span class="line">        switch(shape) &#123;</span><br><span class="line">          case RECTANGLE:</span><br><span class="line">            return length * width;</span><br><span class="line">          case CIRCLE:</span><br><span class="line">            return Math.PI * (radius * radius);</span><br><span class="line">          default:</span><br><span class="line">            throw new AssertionError(shape);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的标签类具有许多缺点。 他们杂乱无章的样板代码，包括枚举声明，标签属性和switch语句。 可读性更差，因为多个实现在一个类中混杂在一起。 内存使用增加，因为实例负担属于其他风格不相关的领域。 属性不能成为final，除非构造方法初始化不相关的属性，导致更多的样板代码。 构造方法在编译器的帮助下，必须设置标签属性并初始化正确的数据属性：如果初始化错误的属性，程序将在运行时失败。 除非可以修改其源文件，否则不能将其添加到标记的类中。 如果你添加一个风格，你必须记得给每个switch语句添加一个case，否则这个类将在运行时失败。 最后，一个实例的数据类型没有提供任何关于风格的线索。 总之，<strong>标签类是冗长的，容易出错的，而且效率低下</strong>。</p><p>幸运的是，像Java这样的面向对象的语言为定义一个能够表示多种风格对象的单一数据类型提供了更好的选择：子类型化（subtyping）。标签类仅仅是一个类层次的简单的模仿。</p><p>要将标签类转换为类层次，首先定义一个包含抽象方法的抽象类，该标签类的行为取决于标签值。 在<code>Figure</code>类中，只有一个这样的方法，就是<code>area</code>方法。 这个抽象类是类层次的根。 如果有任何方法的行为不依赖于标签的值，把它们放在这个类中。 同样，如果有所有的方法使用的数据属性，把它们放在这个类。<code>Figure</code>类中不存在这种与类型无关的方法或属性。</p><p>接下来，为原始标签类的每种类型定义一个根类的具体子类。 在我们的例子中，有两个类型：圆形和矩形。 在每个子类中包含特定于改类型的数据字段。 在我们的例子中，半径属性是属于圆的，长度和宽度属性都是矩形的。 还要在每个子类中包含根类中每个抽象方法的适当实现。 这里是对应于Figure类的类层次：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// Class hierarchy replacement for a tagged class</span><br><span class="line">abstract class Figure &#123;</span><br><span class="line">    abstract double area();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Circle extends Figure &#123;</span><br><span class="line">    final double radius;</span><br><span class="line"></span><br><span class="line">    Circle(double radius) &#123; this.radius = radius; &#125;</span><br><span class="line"></span><br><span class="line">    @Override double area() &#123; return Math.PI * (radius * radius); &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Rectangle extends Figure &#123;</span><br><span class="line">    final double length;</span><br><span class="line">    final double width;</span><br><span class="line"></span><br><span class="line">    Rectangle(double length, double width) &#123;</span><br><span class="line">        this.length = length;</span><br><span class="line">        this.width  = width;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override double area() &#123; return length * width; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类层次纠正了之前提到的标签类的每个缺点。 代码简单明了，不包含原文中的样板文件。 每种类型的实现都是由自己的类来分配的，而这些类都没有被无关的数据属性所占用。 所有的属性是final的。 编译器确保每个类的构造方法初始化其数据属性，并且每个类都有一个针对在根类中声明的每个抽象方法的实现。 这消除了由于缺少switch-case语句而导致的运行时失败的可能性。 多个程序员可以独立地继承类层次，并且可以相互操作，而无需访问根类的源代码。 每种类型都有一个独立的数据类型与之相关联，允许程序员指出变量的类型，并将变量和输入参数限制为特定的类型。</p><p>类层次的另一个优点是可以使它们反映类型之间的自然层次关系，从而提高了灵活性，并提高了编译时类型检查的效率。 假设原始示例中的标签类也允许使用正方形。 类层次可以用来反映一个正方形是一种特殊的矩形（假设它们是不可变的）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lass Square extends Rectangle &#123;</span><br><span class="line">    Square(double side) &#123;</span><br><span class="line">        super(side, side);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，上述层中的属性是直接访问的，而不是访问方法。 这里是为了简洁起见，如果类层次是公开的（条目16），这将是一个糟糕的设计。</p><p>总之，标签类很少有适用的情况。 如果你想写一个带有明显标签属性的类，请考虑标签属性是否可以被删除，而类是否被类层次替换。 当遇到一个带有标签属性的现有类时，可以考虑将其重构为一个类层次中。</p><h2 id="24-优先考虑静态成员类"><a href="#24-优先考虑静态成员类" class="headerlink" title="24.优先考虑静态成员类"></a>24.优先考虑静态成员类</h2><p>嵌套类（nested class）是在另一个类中定义的类。 嵌套类应该只存在于其宿主类（enclosing class）中。 如果一个嵌套类在其他一些情况下是有用的，那么它应该是一个顶级类。 有四种嵌套类：静态成员类，非静态成员类，匿名类和局部类。 除了第一种以外，剩下的三种都被称为内部类（inner class）。 这个条目告诉你什么时候使用哪种类型的嵌套类以及为什么使用。</p><p>静态成员类是最简单的嵌套类。 最好把它看作是一个普通的类，恰好在另一个类中声明，并且可以访问所有宿主类的成员，甚至是那些被声明为私有类的成员。 静态成员类是其宿主类的静态成员，并遵循与其他静态成员相同的可访问性规则。 如果它被声明为private，则只能在宿主类中访问，等等。</p><p>静态成员类的一个常见用途是作为公共帮助类，仅在与其外部类一起使用时才有用。 例如，考虑一个描述计算器支持的操作的枚举类型（条目 34）。 <code>Operation</code>枚举应该是<code>Calculator</code>类的公共静态成员类。 <code>Calculator</code>客户端可以使用<code>Calculator.Operation.PLUS</code>和<code>Calculator.Operation.MINUS</code>等名称来引用操作。</p><p>在语法上，静态成员类和非静态成员类之间的唯一区别是静态成员类在其声明中具有static修饰符。 尽管句法相似，但这两种嵌套类是非常不同的。 非静态成员类的每个实例都隐含地与其包含的类的宿主实例相关联。 在非静态成员类的实例方法中，可以调用宿主实例上的方法，或者使用限定的构造[JLS，15.8.4]获得对宿主实例的引用。 如果嵌套类的实例可以与其宿主类的实例隔离存在，那么嵌套类必须是静态成员类：不可能在没有宿主实例的情况下创建非静态成员类的实例。</p><p>非静态成员类实例和其宿主实例之间的关联是在创建成员类实例时建立的，并且之后不能被修改。 通常情况下，通过在宿主类的实例方法中调用非静态成员类构造方法来自动建立关联。 尽管很少有可能使用表达式<code>enclosingInstance.new MemberClass(args)</code>手动建立关联。 正如你所预料的那样，该关联在非静态成员类实例中占用了空间，并为其构建添加了时间开销。</p><p>非静态成员类的一个常见用法是定义一个Adapter [Gamma95]，它允许将外部类的实例视为某个不相关类的实例。 例如，Map接口的实现通常使用非静态成员类来实现它们的集合视图，这些视图由Map的<code>keySet</code>，<code>entrySet</code>和<code>values</code>方法返回。 同样，集合接口（如Set和List）的实现通常使用非静态成员类来实现它们的迭代器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// Typical use of a nonstatic member class</span><br><span class="line">public class MySet&lt;E&gt; extends AbstractSet&lt;E&gt; &#123;</span><br><span class="line">    ... // Bulk of the class omitted</span><br><span class="line"></span><br><span class="line">    @Override public Iterator&lt;E&gt; iterator() &#123;</span><br><span class="line">        return new MyIterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private class MyIterator implements Iterator&lt;E&gt; &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如果你声明了一个不需要访问宿主实例的成员类，总是把static修饰符放在它的声明中，使它成为一个静态成员类，而不是非静态的成员类</strong>。 如果你忽略了这个修饰符，每个实例都会有一个隐藏的外部引用给它的宿主实例。 如前所述，存储这个引用需要占用时间和空间。 更严重的是，并且会导致即使宿主类在满足垃圾回收的条件时却仍然驻留在内存中（条目 7）。 由此产生的内存泄漏可能是灾难性的。 由于引用是不可见的，所以通常难以检测到。</p><p>私有静态成员类的常见用法是表示由它们的宿主类表示的对象的组件。 例如，考虑将键与值相关联的Map实例。 许多Map实现对于映射中的每个键值对都有一个内部的<code>Entr</code>y对象。 当每个<code>entry</code>都与Map关联时，<code>entry</code>上的方法(<code>getKey</code>，<code>getValue</code>和<code>setValue</code>)不需要访问Map。 因此，使用非静态成员类来表示entry将是浪费的：私有静态成员类是最好的。 如果意外地忽略了<code>entry</code>声明中的static修饰符，Map仍然可以工作，但是每个entry都会包含对Map的引用，浪费空间和时间。</p><p>如果所讨论的类是导出类的公共或受保护成员，则在静态和非静态成员类之间正确选择是非常重要的。 在这种情况下，成员类是导出的API元素，如果不违反向后兼容性，就不能在后续版本中从非静态变为静态成员类。</p><p>正如你所期望的，一个匿名类没有名字。 它不是其宿主类的成员。 它不是与其他成员一起声明，而是在使用时同时声明和实例化。 在表达式合法的代码中，匿名类是允许的。 当且仅当它们出现在非静态上下文中时，匿名类才会封装实例。 但是，即使它们出现在静态上下文中，它们也不能有除常量型变量之外的任何静态成员，这些常量型变量包括final的基本类型，或者初始化常量表达式的字符串属性[JLS，4.12.4]。</p><p>匿名类的适用性有很多限制。 除了在声明的时候之外，不能实例化它们。 你不能执行<code>instanceof</code>方法测试或者做任何其他需要你命名的类。 不能声明一个匿名类来实现多个接口，或者继承一个类并同时实现一个接口。 匿名类的客户端不能调用除父类型继承的成员以外的任何成员。 因为匿名类在表达式中出现，所以它们必须保持短——约十行或更少——否则可读性将受损。</p><p>在将lambda表达式添加到Java（第6章）之前，匿名类是创建小方法对象和处理对象的首选方法，但lambda表达式现在是首选（条目 42）。 匿名类的另一个常见用途是实现静态工厂方法（请参阅条目 20中的intArrayAsList）。</p><p>局部类是四种嵌套类中使用最少的。 一个局部类可以在任何可以声明局部变量的地方声明，并遵守相同的作用域规则。 局部类与其他类型的嵌套类具有共同的属性。 像成员类一样，他们有名字，可以重复使用。 就像匿名类一样，只有在非静态上下文中定义它们时，它们才会包含实例，并且它们不能包含静态成员。 像匿名类一样，应该保持简短，以免损害可读性。</p><p>回顾一下，有四种不同的嵌套类，每个都有它的用途。 如果一个嵌套的类需要在一个方法之外可见，或者太长而不能很好地适应一个方法，使用一个成员类。 如果一个成员类的每个实例都需要一个对其宿主实例的引用，使其成为非静态的; 否则，使其静态。 假设这个类属于一个方法内部，如果你只需要从一个地方创建实例，并且存在一个预置类型来说明这个类的特征，那么把它作为一个匿名类; 否则，把它变成局部类。</p><h2 id="25-将源文件限制为单个顶级类"><a href="#25-将源文件限制为单个顶级类" class="headerlink" title="25. 将源文件限制为单个顶级类"></a>25. 将源文件限制为单个顶级类</h2><p>虽然Java编译器允许在单个源文件中定义多个顶级类，但这样做没有任何好处，并且存在重大风险。 风险源于在源文件中定义多个顶级类使得为类提供多个定义成为可能。 使用哪个定义会受到源文件传递给编译器的顺序的影响。</p><p>为了具体说明，请考虑下面源文件，其中只包含一个引用其他两个顶级类（<code>Utensil</code>和<code>Dessert</code>类）的成员的<code>Main</code>类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(Utensil.NAME + [Dessert.NAME](http://Dessert.NAME));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在假设在<code>Utensil.java</code>的源文件中同时定义了<code>Utensil</code>和<code>Dessert</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// Two classes defined in one file. Don&apos;t ever do this!</span><br><span class="line"></span><br><span class="line">class Utensil &#123;</span><br><span class="line"></span><br><span class="line">    static final String NAME = &quot;pan&quot;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dessert &#123;</span><br><span class="line"></span><br><span class="line">    static final String NAME = &quot;cake&quot;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，main方法会打印<code>pancake</code>。</p><p>现在假设你不小心创建了另一个名为<code>Dessert.java</code>的源文件，它定义了相同的两个类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// Two classes defined in one file. Don&apos;t ever do this!</span><br><span class="line"></span><br><span class="line">class Utensil &#123;</span><br><span class="line"></span><br><span class="line">    static final String NAME = &quot;pot&quot;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dessert &#123;</span><br><span class="line"></span><br><span class="line">    static final String NAME = &quot;pie&quot;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你足够幸运，使用命令<code>javac Main.java Dessert.java</code>编译程序，编译将失败，编译器会告诉你，你已经多次定义了类<code>Utensil</code>和<code>Dessert</code>。 这是因为编译器首先编译<code>Main.java</code>，当它看到对<code>Utensil</code>的引用（它在<code>Dessert</code>的引用之前）时，它将在<code>Utensil.java</code>中查找这个类并找到<code>Utensil</code>和<code>Dessert</code>。 当编译器在命令行上遇到<code>Dessert.java</code>时，它也将拉入该文件，导致它遇到<code>Utensil</code>和<code>Dessert</code>的定义。</p><p>如果使用命令<code>javac Main.java</code>或<code>javac Main.java Utensil.java</code>编译程序，它的行为与在编写<code>Dessert.java</code>文件（即打印<code>pancake</code>）之前的行为相同。 但是，如果使用命令<code>javac Dessert.java Main.java</code>编译程序，它将打印<code>potpie</code>。 程序的行为因此受到源文件传递给编译器的顺序的影响，这显然是不可接受的。</p><p>解决这个问题很简单，将顶层类（如我们的例子中的<code>Utensil</code>和<code>Dessert</code>）分割成单独的源文件。 如果试图将多个顶级类放入单个源文件中，请考虑使用静态成员类（条目 24）作为将类拆分为单独的源文件的替代方法。 如果这些类从属于另一个类，那么将它们变成静态成员类通常是更好的选择，因为它提高了可读性，并且可以通过声明它们为私有（条目 15）来减少类的可访问性。下面是我们的例子看起来如何使用静态成员类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// Static member classes instead of multiple top-level classes</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(Utensil.NAME + [Dessert.NAME](http://Dessert.NAME));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class Utensil &#123;</span><br><span class="line"></span><br><span class="line">        static final String NAME = &quot;pan&quot;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class Dessert &#123;</span><br><span class="line"></span><br><span class="line">        static final String NAME = &quot;cake&quot;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个教训很清楚：<strong>永远不要将多个顶级类或接口放在一个源文件中</strong>。 遵循这个规则保证在编译时不能有多个定义。 这又保证了编译生成的类文件以及生成的程序的行为与源文件传递给编译器的顺序无关。</p><p>自Java 5以来，泛型已经成为该语言的一部分。 在泛型之前，你必须转换从集合中读取的每个对象。 如果有人不小心插入了错误类型的对象，则在运行时可能会失败。 使用泛型，你告诉编译器在每个集合中允许哪些类型的对象。 编译器会自动插入强制转换，并在编译时告诉你是否尝试插入错误类型的对象。 这样做的结果是既安全又清晰的程序，但这些益处，不限于集合，是有代价的。 本章告诉你如何最大限度地提高益处，并将并发症降至最低。</p><h2 id="26-不要使用原始类型"><a href="#26-不要使用原始类型" class="headerlink" title="26. 不要使用原始类型"></a>26. 不要使用原始类型</h2><p>首先，有几个术语。一个类或接口，它的声明有一个或多个类型参数（ type parameters ），被称之为泛型类或泛型接口[JLS，8.1.2,9.1.2]。 例如，List接口具有单个类型参数E，表示其元素类型。 接口的全名是<code>List&lt;E&gt;</code>（读作“E”的列表），但是人们经常称它为List。 泛型类和接口统称为泛型类型（generic types）。</p><p>每个泛型定义了一组参数化类型（parameterized types），它们由类或接口名称组成，后跟一个与泛型类型的形式类型参数[JLS，4.4,4.5]相对应的实际类型参数的尖括号“&lt;&gt;”列表。 例如，<code>List&lt;String&gt;</code>（读作“字符串列表”）是一个参数化类型，表示其元素类型为String的列表。 （String是与形式类型参数E相对应的实际类型参数）。</p><p>最后，每个泛型定义了一个原始类型（ raw type），它是没有任何类型参数的泛型类型的名称[JLS，4.8]。 例如，对应于<code>List&lt;E&gt;</code>的原始类型是List。 原始类型的行为就像所有的泛型类型信息都从类型声明中被清除一样。 它们的存在主要是为了与没有泛型之前的代码相兼容。</p><p>在泛型被添加到Java之前，这是一个典型的集合声明。 从Java 9开始，它仍然是合法的，但并不是典型的声明方式了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Raw collection type - don&apos;t do this!</span><br><span class="line"></span><br><span class="line">// My stamp collection. Contains only Stamp instances.</span><br><span class="line">private final Collection stamps = ... ;</span><br></pre></td></tr></table></figure><p>如果你今天使用这个声明，然后不小心把coin实例放入你的stamp集合中，错误的插入编译和运行没有错误（尽管编译器发出一个模糊的警告）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// Erroneous insertion of coin into stamp collection</span><br><span class="line">stamps.add(new Coin( ... )); // Emits &quot;unchecked call&quot; warning</span><br></pre></td></tr></table></figure><p>直到您尝试从stamp集合中检索coin实例时才会发生错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Raw iterator type - don&apos;t do this!</span><br><span class="line">for (Iterator i = stamps.iterator(); i.hasNext(); )</span><br><span class="line">    Stamp stamp = (Stamp) i.next(); // Throws ClassCastException</span><br><span class="line">        stamp.cancel();</span><br></pre></td></tr></table></figure><p>正如本书所提到的，在编译完成之后尽快发现错误是值得的，理想情况是在编译时。 在这种情况下，直到运行时才发现错误，在错误发生后的很长一段时间，以及可能远离包含错误的代码的代码中。 一旦看到ClassCastException，就必须搜索代码类库，查找将coin实例放入stamp集合的方法调用。 编译器不能帮助你，因为它不能理解那个说“仅包含stamp实例”的注释。</p><p>对于泛型，类型声明包含的信息，而不是注释：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// Parameterized collection type - typesafe</span><br><span class="line">private final Collection&lt;Stamp&gt; stamps = ... ;</span><br></pre></td></tr></table></figure><p>从这个声明中，编译器知道stamps集合应该只包含Stamp实例，并保证它是true，假设你的整个代码类库编译时不发出（或者抑制;参见条目27）任何警告。 当使用参数化类型声明声明stamps时，错误的插入会生成一个编译时错误消息，告诉你到底发生了什么错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Test.java:9: error: incompatible types: Coin cannot be converted</span><br><span class="line">to Stamp</span><br><span class="line">    c.add(new Coin());</span><br><span class="line">              ^</span><br></pre></td></tr></table></figure><p>当从集合中检索元素时，编译器会为你插入不可见的强制转换，并保证它们不会失败（再假设你的所有代码都不会生成或禁止任何编译器警告）。 虽然意外地将coin实例插入stamp集合的预期可能看起来很牵强，但这个问题是真实的。 例如，很容易想象将<code>BigInteger</code>放入一个只包含<code>BigDecimal</code>实例的集合中。</p><p>如前所述，使用原始类型（没有类型参数的泛型）是合法的，但是你不应该这样做。 <strong>如果你使用原始类型，则会丧失泛型的所有安全性和表达上的优势</strong>。 鉴于你不应该使用它们，为什么语言设计者首先允许原始类型呢？ 答案是为了兼容性。 泛型被添加时，Java即将进入第二个十年，并且有大量的代码没有使用泛型。 所有这些代码都是合法的，并且与使用泛型的新代码进行交互操作被认为是至关重要的。 将参数化类型的实例传递给为原始类型设计的方法必须是合法的，反之亦然。 这个需求，被称为迁移兼容性，驱使决策支持原始类型，并使用擦除来实现泛型（条目 28）。</p><p>虽然不应使用诸如List之类的原始类型，但可以使用参数化类型来允许插入任意对象（如<code>List&lt;Object&gt;</code>）。 原始类型List和参数化类型<code>List&lt;Object&gt;</code>之间有什么区别？ 松散地说，前者已经选择了泛型类型系统，而后者明确地告诉编译器，它能够保存任何类型的对象。 虽然可以将<code>List&lt;String&gt;</code>传递给List类型的参数，但不能将其传递给<code>List&lt;Object&gt;</code>类型的参数。 泛型有子类型的规则，<code>List&lt;String&gt;</code>是原始类型List的子类型，但不是参数化类型<code>List&lt;Object&gt;</code>的子类型（条目 28）。 因此，如果使用诸如List之类的原始类型，则会丢失类型安全性，但是如果使用参数化类型（例如<code>List &lt;Object&gt;</code>）则不会。</p><p>为了具体说明，请考虑以下程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// Fails at runtime - unsafeAdd method uses a raw type (List)!</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;String&gt; strings = new ArrayList&lt;&gt;();</span><br><span class="line">    unsafeAdd(strings, Integer.valueOf(42));</span><br><span class="line">    String s = strings.get(0); // Has compiler-generated cast</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void unsafeAdd(List list, Object o) &#123;</span><br><span class="line">    list.add(o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此程序可以编译，它使用原始类型列表，但会收到警告：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Test.java:10: warning: [unchecked] unchecked call to add(E) as a</span><br><span class="line">member of the raw type List</span><br><span class="line">    list.add(o);</span><br><span class="line">            ^</span><br></pre></td></tr></table></figure><p>实际上，如果运行该程序，则当程序尝试调用<code>strings.get(0)</code>的结果（一个Integer）转换为一个String时，会得到ClassCastException异常。 这是一个编译器生成的强制转换，因此通常会保证成功，但在这种情况下，我们忽略了编译器警告并付出了代价。</p><p>如果用unsafeAdd声明中的参数化类型<code>List &lt;Object&gt;</code>替换原始类型List，并尝试重新编译该程序，则会发现它不再编译，而是发出错误消息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Test.java:5: error: incompatible types: List&lt;String&gt; cannot be</span><br><span class="line">converted to List&lt;Object&gt;</span><br><span class="line">    unsafeAdd(strings, Integer.valueOf(42));</span><br></pre></td></tr></table></figure><p>你可能会试图使用原始类型来处理元素类型未知且无关紧要的集合。 例如，假设你想编写一个方法，它需要两个集合并返回它们共同拥有的元素的数量。 如果是泛型新手，那么您可以这样写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// Use of raw type for unknown element type - don&apos;t do this!</span><br><span class="line">static int numElementsInCommon(Set s1, Set s2) &#123;</span><br><span class="line">    int result = 0;</span><br><span class="line">    for (Object o1 : s1)</span><br><span class="line">        if (s2.contains(o1))</span><br><span class="line">            result++;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法可以工作，但它使用原始类型，这是危险的。 安全替代方式是使用无限制通配符类型（unbounded wildcard types）。 如果要使用泛型类型，但不知道或关心实际类型参数是什么，则可以使用问号来代替。 例如，泛型类型<code>Set&lt;E&gt;</code>的无限制通配符类型是<code>Set &lt;?&gt;</code>（读取“某种类型的集合”）。 它是最通用的参数化的Set类型，能够保持任何集合。 下面是<code>numElementsInCommon</code>方法使用无限制通配符类型声明的情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// Uses unbounded wildcard type - typesafe and flexible</span><br><span class="line">static int numElementsInCommon(Set&lt;?&gt; s1, Set&lt;?&gt; s2) &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>无限制通配符<code>Set &lt;?&gt;</code>与原始类型Set之间有什么区别？ 问号真的给你放任何东西吗？ 这不是要点，但通配符类型是安全的，原始类型不是。 你可以将任何元素放入具有原始类型的集合中，轻易破坏集合的类型不变性（如第119页上的unsafeAdd方法所示）; 你不能把任何元素（除null之外）放入一个<code>Collection &lt;?&gt;</code>中。 试图这样做会产生一个像这样的编译时错误消息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">WildCard.java:13: error: incompatible types: String cannot be</span><br><span class="line">converted to CAP#1</span><br><span class="line">    c.add(&quot;verboten&quot;);</span><br><span class="line">          ^</span><br><span class="line">  where CAP#1 is a fresh type-variable:</span><br><span class="line">    CAP#1 extends Object from capture of ?</span><br></pre></td></tr></table></figure><p>不可否认的是，这个错误信息留下了一些需要的东西，但是编译器已经完成了它的工作，不管它的元素类型是什么，都不会破坏集合的类型不变性。 你不仅可以将任何元素（除null以外）放入一个<code>Collection &lt;?&gt;</code>中，但是不能保证你所得到的对象的类型。 如果这些限制是不可接受的，可以使用泛型方法（条目 30）或有限制配符类型（条目 31）。</p><p>对于不应该使用原始类型的规则，有一些小例外。 <strong>你必须在类字面值（class literals）中使用原始类型</strong>。 规范中不允许使用参数化类型（尽管它允许数组类型和基本类型）[JLS，15.8.2]。 换句话说，<code>List.class</code>，<code>String [] .class</code>和<code>int.class</code>都是合法的，但<code>List &lt;String&gt; .class</code>和<code>List &lt;?&gt;.class</code>不是合法的。</p><p>规则的第二个例外涉及<code>instanceof</code>操作符。 因为泛型类型信息在运行时被删除，所以在无限制通配符类型以外的参数化类型上使用instanceof运算符是非法的。 使用无限制通配符类型代替原始类型不会以任何方式影响instanceof运算符的行为。 在这种情况下，尖括号和问号就显得多余。 以下是使用泛型类型的instanceof运算符的首选方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Legitimate use of raw type - instanceof operator</span><br><span class="line">if (o instanceof Set) &#123;       // Raw type</span><br><span class="line">    Set&lt;?&gt; s = (Set&lt;?&gt;) o;    // Wildcard type</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，一旦确定<code>o</code>对象是一个Set，则必须将其转换为通配符<code>Set &lt;?&gt;</code>，而不是原始类型Set。 这是一个强制转换，所以不会导致编译器警告。</p><p>总之，使用原始类型可能导致运行时异常，所以不要使用它们。 它们仅用于与泛型引入之前的传统代码的兼容性和互操作性。 作为一个快速回顾，<code>Set&lt;Object&gt;</code>是一个参数化类型，表示一个可以包含任何类型对象的集合，<code>Set&lt;?&gt;</code>是一个通配符类型，表示一个只能包含某些未知类型对象的集合，Set是一个原始类型，它不在泛型类型系统之列。 前两个类型是安全的，最后一个不是。</p><p>为了快速参考，下表中总结了本条目（以及本章稍后介绍的一些）中介绍的术语：</p><table><thead><tr><th>术语</th><th>中文含义</th><th>举例</th><th>所在条目</th></tr></thead><tbody><tr><td>Parameterized type</td><td>参数化类型</td><td><code>List&lt;String&gt;</code></td><td>条目 26</td></tr><tr><td>Actual type parameter</td><td>实际类型参数</td><td><code>String</code></td><td>条目 26</td></tr><tr><td>Generic type</td><td>泛型类型</td><td><code>List&lt;E&gt;</code></td><td>条目 26</td></tr><tr><td>Formal type parameter</td><td>形式类型参数</td><td><code>E</code></td><td>条目 26</td></tr><tr><td>Unbounded wildcard type</td><td>无限制通配符类型</td><td><code>List&lt;?&gt;</code></td><td>条目 26</td></tr><tr><td>Raw type</td><td>原始类型</td><td><code>List</code></td><td>条目 26</td></tr><tr><td>Bounded type parameter</td><td>限制类型参数</td><td><code>&lt;E extends Number&gt;</code></td><td>条目 29</td></tr><tr><td>Recursive type bound</td><td>递归类型限制</td><td><code>&lt;T extends Comparable&lt;T&gt;&gt;</code></td><td>条目 30</td></tr><tr><td>Bounded wildcard type</td><td>限制通配符类型</td><td><code>List&lt;? extends Number&gt;</code></td><td>条目 31</td></tr><tr><td>Generic method</td><td>泛型方法</td><td><code>static &lt;E&gt; List&lt;E&gt; asList(E[] a)</code></td><td>条目 30</td></tr><tr><td>Type token</td><td>类型令牌</td><td><code>String.class</code></td><td>条目 33</td></tr></tbody></table><h2 id="27-消除非检查警告"><a href="#27-消除非检查警告" class="headerlink" title="27. 消除非检查警告"></a>27. 消除非检查警告</h2><p>使用泛型编程时，会看到许多编译器警告：未经检查的强制转换警告，未经检查的方法调用警告，未经检查的参数化可变长度类型警告以及未经检查的转换警告。 你使用泛型获得的经验越多，获得的警告越少，但不要期望新编写的代码能够干净地编译。</p><p>许多未经检查的警告很容易消除。 例如，假设你不小心写了以下声明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Lark&gt; exaltation = new HashSet();</span><br></pre></td></tr></table></figure><p>编译器会提醒你你做错了什么：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Venery.java:4: warning: [unchecked] unchecked conversion</span><br><span class="line">        Set&lt;Lark&gt; exaltation = new HashSet();</span><br><span class="line">                               ^</span><br><span class="line">  required: Set&lt;Lark&gt;</span><br><span class="line">  found:    HashSet</span><br></pre></td></tr></table></figure><p>然后可以进行指示修正，让警告消失。 请注意，实际上并不需要指定类型参数，只是为了表明它与Java 7中引入的钻石运算符（”&lt;&gt;”）一同出现。然后编译器会推断出正确的实际类型参数（在本例中为Lark）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Lark&gt; exaltation = new HashSet&lt;&gt;();</span><br></pre></td></tr></table></figure><p>但一些警告更难以消除。 本章充满了这种警告的例子。 当你收到需要进一步思考的警告时，坚持不懈！ <strong>尽可能地消除每一个未经检查的警告</strong>。 如果你消除所有的警告，你可以放心，你的代码是类型安全的，这是一件非常好的事情。 这意味着在运行时你将不会得到一个ClassCastException异常，并且增加了你的程序将按照你的意图行事的信心。</p><p><strong>如果你不能消除警告，但你可以证明引发警告的代码是类型安全的，那么（并且只能这样）用@SuppressWarnings(“unchecked”)注解来抑制警告</strong>。 如果你在没有首先证明代码是类型安全的情况下压制警告，那么你给自己一个错误的安全感。 代码可能会在不发出任何警告的情况下进行编译，但是它仍然可以在运行时抛出ClassCastException异常。 但是，如果你忽略了你认为是安全的未经检查的警告（而不是抑制它们），那么当一个新的警告出现时，你将不会注意到这是一个真正的问题。 新出现的警告就会淹没在所有的错误警告当中。</p><p><code>SuppressWarnings</code>注解可用于任何声明，从单个局部变量声明到整个类。 <strong>始终在尽可能最小的范围内使用SuppressWarnings注解</strong>。 通常这是一个变量声明或一个非常短的方法或构造方法。 切勿在整个类上使用<code>SuppressWarnings</code>注解。 这样做可能会掩盖重要的警告。</p><p>如果你发现自己在长度超过一行的方法或构造方法上使用<code>SuppressWarnings</code>注解，则可以将其移到局部变量声明上。 你可能需要声明一个新的局部变量，但这是值得的。 例如，考虑这个来自ArrayList的toArray方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">    if (a.length &lt; size)</span><br><span class="line">       return (T[]) Arrays.copyOf(elements, size, a.getClass());</span><br><span class="line">    System.arraycopy(elements, 0, a, 0, size);</span><br><span class="line">    if (a.length &gt; size)</span><br><span class="line">       a[size] = null;</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">如果编译ArrayList类，则该方法会生成此警告：</span><br><span class="line">ArrayList.java:305: warning: [unchecked] unchecked cast</span><br><span class="line">       return (T[]) Arrays.copyOf(elements, size, a.getClass());</span><br><span class="line">                                 ^</span><br><span class="line">  required: T[]</span><br><span class="line">  found:    Object[]</span><br></pre></td></tr></table></figure><p>在返回语句中设置<code>SuppressWarnings</code>注解是非法的，因为它不是一个声明[JLS，9.7]。 你可能会试图把注释放在整个方法上，但是不要这要做。 相反，声明一个局部变量来保存返回值并标注它的声明，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// Adding local variable to reduce scope of @SuppressWarnings</span><br><span class="line">public &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">    if (a.length &lt; size) &#123;</span><br><span class="line">        // This cast is correct because the array we&apos;re creating</span><br><span class="line">        // is of the same type as the one passed in, which is T[].</span><br><span class="line">        @SuppressWarnings(&quot;unchecked&quot;) T[] result =</span><br><span class="line">            (T[]) Arrays.copyOf(elements, size, a.getClass());</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    System.arraycopy(elements, 0, a, 0, size);</span><br><span class="line">    if (a.length &gt; size)</span><br><span class="line">        a[size] = null;</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所产生的方法干净地编译，并最小化未经检查的警告被抑制的范围。</p><p><strong>每当使用@SuppressWarnings(“unchecked”)注解时，请添加注释，说明为什么是安全的</strong>。 这将有助于他人理解代码，更重要的是，这将减少有人修改代码的可能性，从而使计算不安全。 如果你觉得很难写这样的注释，请继续思考。 毕竟，你最终可能会发现未经检查的操作是不安全的。</p><p>总之，未经检查的警告是重要的。 不要忽视他们。 每个未经检查的警告代表在运行时出现ClassCastException异常的可能性。 尽你所能消除这些警告。 如果无法消除未经检查的警告，并且可以证明引发该警告的代码是安全类型的，则可以在尽可能小的范围内使用 <code>@SuppressWarnings(“unchecked”)</code>注解来禁止警告。 记录你决定在注释中抑制此警告的理由。</p><h2 id="28-列表优于数组"><a href="#28-列表优于数组" class="headerlink" title="28.列表优于数组"></a>28.列表优于数组</h2><p>数组在两个重要方面与泛型不同。 首先，数组是协变的（covariant）。 这个吓人的单词意味着如果<code>Sub</code>是<code>Super</code>的子类型，则数组类型<code>Sub []</code>是数组类型<code>Super []</code>的子类型。 相比之下，泛型是不变的（invariant）：对于任何两种不同的类型<code>Type1</code>和<code>Type2</code>，<code>List&lt;Type1&gt;</code>既不是<code>List &lt;Type2&gt;</code>的子类型也不是父类型。[JLS，4.10; Naftalin07,2.5]。 你可能认为这意味着泛型是不足的，但可以说是数组缺陷。 这段代码是合法的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// Fails at runtime!</span><br><span class="line">Object[] objectArray = new Long[1];</span><br><span class="line">objectArray[0] = &quot;I don&apos;t fit in&quot;; // Throws ArrayStoreException</span><br></pre></td></tr></table></figure><p>但这个不是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// Won&apos;t compile!</span><br><span class="line">List&lt;Object&gt; ol = new ArrayList&lt;Long&gt;(); // Incompatible types</span><br><span class="line">ol.add(&quot;I don&apos;t fit in&quot;);</span><br></pre></td></tr></table></figure><p>无论哪种方式，你不能把一个String类型放到一个Long类型容器中，但是用一个数组，你会发现在运行时产生了一个错误；对于列表，可以在编译时就能发现错误。 当然，你宁愿在编译时找出错误。</p><p>数组和泛型之间的第二个主要区别是数组被具体化了（reified）[JLS，4.7]。 这意味着数组在运行时知道并强制执行它们的元素类型。 如前所述，如果尝试将一个String放入Long数组中，得到一个ArrayStoreException异常。 相反，泛型通过擦除（erasure）来实现[JLS，4.6]。 这意味着它们只在编译时执行类型约束，并在运行时丢弃（或擦除）它们的元素类型信息。 擦除是允许泛型类型与不使用泛型的遗留代码自由互操作（条目 26），从而确保在Java 5中平滑过渡到泛型。</p><p>由于这些基本差异，数组和泛型不能很好地在一起混合使用。 例如，创建泛型类型的数组，参数化类型的数组，以及类型参数的数组都是非法的。 因此，这些数组创建表达式都不合法：<code>new List &lt;E&gt; []</code>，<code>new List &lt;String&gt; []</code>，<code>new E []</code>。 所有将在编译时导致泛型数组创建错误。</p><p>为什么创建一个泛型数组是非法的？ 因为它不是类型安全的。 如果这是合法的，编译器生成的强制转换程序在运行时可能会因为ClassCastException异常而失败。 这将违反泛型类型系统提供的基本保证。</p><p>为了具体说明，请考虑下面的代码片段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Why generic array creation is illegal - won&apos;t compile!</span><br><span class="line">List&lt;String&gt;[] stringLists = new List&lt;String&gt;[1];  // (1)</span><br><span class="line">List&lt;Integer&gt; intList = List.of(42);               // (2)</span><br><span class="line">Object[] objects = stringLists;                    // (3)</span><br><span class="line">objects[0] = intList;                              // (4)</span><br><span class="line">String s = stringLists[0].get(0);                  // (5)</span><br></pre></td></tr></table></figure><p>让我们假设第1行创建一个泛型数组是合法的。第2行创建并初始化包含单个元素的<code>List&lt;Integer&gt;</code>。第3行将<code>List&lt;String&gt;</code>数组存储到Object数组变量中，这是合法的，因为数组是协变的。第4行将<code>List &lt;Integer&gt;</code>存储在Object数组的唯一元素中，这是因为泛型是通过擦除来实现的：<code>List&lt;Integer&gt;</code>实例的运行时类型仅仅是List，而<code>List&lt;String&gt; []</code>实例是<code>List []</code>，所以这个赋值不会产生ArrayStoreException异常。现在我们遇到了麻烦。将一个<code>List&lt;Integer&gt;</code>实例存储到一个声明为仅保存<code>List&lt;String&gt;</code>实例的数组中。在第5行中，我们从这个数组的唯一列表中检索唯一的元素。编译器自动将检索到的元素转换为String，但它是一个Integer，所以我们在运行时得到一个ClassCastException异常。为了防止发生这种情况，第1行（创建一个泛型数组）必须产生一个编译时错误。</p><p>类型<code>E</code>，<code>List&lt;E&gt;</code>和<code>List&lt;String&gt;</code>等在技术上被称为不可具体化的类型（nonreifiable types）[JLS，4.7]。 直观地说，不可具体化的类型是其运行时表示包含的信息少于其编译时表示的类型。 由于擦除，可唯一确定的参数化类型是无限定通配符类型，如<code>List &lt;?&gt;</code>和<code>Map &lt;?, ?&gt;</code>（条目 26）。 尽管很少有用，创建无限定通配符类型的数组是合法的。</p><p>禁止泛型数组的创建可能会很恼人的。 这意味着，例如，泛型集合通常不可能返回其元素类型的数组（但是参见条目 33中的部分解决方案）。 这也意味着，当使用可变参数方法（条目 53）和泛型时，会产生令人困惑的警告。 这是因为每次调用可变参数方法时，都会创建一个数组来保存可变参数。 如果此数组的元素类型不可确定，则会收到警告。 <code>SafeVarargs</code>注解可以用来解决这个问题（条目 32）。</p><p>当你在强制转换为数组类型时，得到泛型数组创建错误，或是未经检查的强制转换警告时，最佳解决方案通常是使用集合类型<code>List &lt;E&gt;</code>而不是数组类型<code>E []</code>。 这样可能会牺牲一些简洁性或性能，但作为交换，你会获得更好的类型安全性和互操作性。</p><p>例如，假设你想用带有集合的构造方法来编写一个<code>Chooser</code>类，并且有个方法返回随机选择的集合的一个元素。 根据传递给构造方法的集合，可以使用选择器作为游戏模具，魔术8球或数据源进行蒙特卡罗模拟。 这是一个没有泛型的简单实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// Chooser - a class badly in need of generics!</span><br><span class="line">public class Chooser &#123;</span><br><span class="line">    private final Object[] choiceArray;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public Chooser(Collection choices) &#123;</span><br><span class="line">        choiceArray = choices.toArray();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public Object choose() &#123;</span><br><span class="line">        Random rnd = ThreadLocalRandom.current();</span><br><span class="line">        return choiceArray[rnd.nextInt(choiceArray.length)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要使用这个类，每次调用方法时，都必须将Object的<code>choose</code>方法的返回值转换为所需的类型，如果类型错误，则转换在运行时失败。 我们先根据条目 29的建议，试图修改Chooser类，使其成为泛型的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// A first cut at making Chooser generic - won&apos;t compile</span><br><span class="line">public class Chooser&lt;T&gt; &#123;</span><br><span class="line">    private final T[] choiceArray;</span><br><span class="line"></span><br><span class="line">    public Chooser(Collection&lt;T&gt; choices) &#123;</span><br><span class="line">        choiceArray = choices.toArray();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // choose method unchanged</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你尝试编译这个类，会得到这个错误信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Chooser.java:9: error: incompatible types: Object[] cannot be</span><br><span class="line">converted to T[]</span><br><span class="line">        choiceArray = choices.toArray();</span><br><span class="line">                                     ^</span><br><span class="line">  where T is a type-variable:</span><br><span class="line">    T extends Object declared in class Chooser</span><br></pre></td></tr></table></figure><p>没什么大不了的，将Object数组转换为T数组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">choiceArray = (T[]) choices.toArray();</span><br></pre></td></tr></table></figure><p>这没有了错误，而是得到一个警告：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Chooser.java:9: warning: [unchecked] unchecked cast</span><br><span class="line">        choiceArray = (T[]) choices.toArray();</span><br><span class="line">                                           ^</span><br><span class="line">  required: T[], found: Object[]</span><br><span class="line">  where T is a type-variable:</span><br><span class="line">T extends Object declared in class Chooser</span><br></pre></td></tr></table></figure><p>编译器告诉你在运行时不能保证强制转换的安全性，因为程序不会知道T代表什么类型——记住，元素类型信息在运行时会被泛型删除。 该程序可以正常工作吗？ 是的，但编译器不能证明这一点。 你可以证明这一点，在注释中提出证据，并用注解来抑制警告，但最好是消除警告的原因（条目 27）。</p><p>要消除未经检查的强制转换警告，请使用列表而不是数组。 下面是另一个版本的Chooser类，编译时没有错误或警告：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// List-based Chooser - typesafe</span><br><span class="line">public class Chooser&lt;T&gt; &#123;</span><br><span class="line">    private final List&lt;T&gt; choiceList;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public Chooser(Collection&lt;T&gt; choices) &#123;</span><br><span class="line">        choiceList = new ArrayList&lt;&gt;(choices);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public T choose() &#123;</span><br><span class="line">        Random rnd = ThreadLocalRandom.current();</span><br><span class="line">        return choiceList.get(rnd.nextInt(choiceList.size()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个版本有些冗长，也许运行比较慢，但是值得一提的是，在运行时不会得到<code>ClassCastException</code>异常。</p><p>总之，数组和泛型具有非常不同的类型规则。 数组是协变和具体化的; 泛型是不变的，类型擦除的。 因此，数组提供运行时类型的安全性，但不提供编译时类型的安全性，反之亦然。 一般来说，数组和泛型不能很好地混合工作。 如果你发现把它们混合在一起，得到编译时错误或者警告，你的第一个冲动应该是用列表来替换数组。</p><h2 id="29-优先考虑泛型"><a href="#29-优先考虑泛型" class="headerlink" title="29. 优先考虑泛型"></a>29. 优先考虑泛型</h2><p>参数化声明并使用JDK提供的泛型类型和方法通常不会太困难。 但编写自己的泛型类型有点困难，但值得努力学习。</p><p>考虑条目 7中的简单堆栈实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// Object-based collection - a prime candidate for generics</span><br><span class="line">public class Stack &#123;</span><br><span class="line">    private Object[] elements;</span><br><span class="line">    private int size = 0;</span><br><span class="line">    private static final int DEFAULT_INITIAL_CAPACITY = 16;</span><br><span class="line"></span><br><span class="line">    public Stack() &#123;</span><br><span class="line">        elements = new Object[DEFAULT_INITIAL_CAPACITY];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void push(Object e) &#123;</span><br><span class="line">        ensureCapacity();</span><br><span class="line">        elements[size++] = e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object pop() &#123;</span><br><span class="line">        if (size == 0)</span><br><span class="line">            throw new EmptyStackException();</span><br><span class="line">        Object result = elements[--size];</span><br><span class="line">        elements[size] = null; // Eliminate obsolete reference</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isEmpty() &#123;</span><br><span class="line">        return size == 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void ensureCapacity() &#123;</span><br><span class="line">        if (elements.length == size)</span><br><span class="line">            elements = Arrays.copyOf(elements, 2 * size + 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类应该已经被参数化了，但是由于事实并非如此，我们可以对它进行泛型化。 换句话说，我们可以参数化它，而不会损害原始非参数化版本的客户端。 就目前而言，客户端必须强制转换从堆栈中弹出的对象，而这些强制转换可能会在运行时失败。 泛型化类的第一步是在其声明中添加一个或多个类型参数。 在这种情况下，有一个类型参数，表示堆栈的元素类型，这个类型参数的常规名称是<code>E</code>（条目 68）。</p><p>下一步是用相应的类型参数替换所有使用的Object类型，然后尝试编译生成的程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// Initial attempt to generify Stack - won&apos;t compile!</span><br><span class="line">public class Stack&lt;E&gt; &#123;</span><br><span class="line">    private E[] elements;</span><br><span class="line">    private int size = 0;</span><br><span class="line">    private static final int DEFAULT_INITIAL_CAPACITY = 16;</span><br><span class="line"></span><br><span class="line">    public Stack() &#123;</span><br><span class="line">        elements = new E[DEFAULT_INITIAL_CAPACITY];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void push(E e) &#123;</span><br><span class="line">        ensureCapacity();</span><br><span class="line">        elements[size++] = e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public E pop() &#123;</span><br><span class="line">        if (size == 0)</span><br><span class="line">            throw new EmptyStackException();</span><br><span class="line">        E result = elements[--size];</span><br><span class="line">        elements[size] = null; // Eliminate obsolete reference</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    ... // no changes in isEmpty or ensureCapacity</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你通常会得到至少一个错误或警告，这个类也不例外。 幸运的是，这个类只产生一个错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stack.java:8: generic array creation</span><br><span class="line">        elements = new E[DEFAULT_INITIAL_CAPACITY];</span><br><span class="line">                   ^</span><br></pre></td></tr></table></figure><p>如条目 28所述，你不能创建一个不可具体化类型的数组，例如类型<code>E</code>。每当编写一个由数组支持的泛型时，就会出现此问题。 有两种合理的方法来解决它。 第一种解决方案直接规避了对泛型数组创建的禁用：创建一个Object数组并将其转换为泛型数组类型。 现在没有了错误，编译器会发出警告。 这种用法是合法的，但不是（一般）类型安全的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Stack.java:8: warning: [unchecked] unchecked cast</span><br><span class="line">found: Object[], required: E[]</span><br><span class="line">        elements = (E[]) new Object[DEFAULT_INITIAL_CAPACITY];</span><br><span class="line">                       ^</span><br></pre></td></tr></table></figure><p>编译器可能无法证明你的程序是类型安全的，但你可以。 你必须说服自己，不加限制的类型强制转换不会损害程序的类型安全。 有问题的数组（元素）保存在一个私有属性中，永远不会返回给客户端或传递给任何其他方法。 保存在数组中的唯一元素是那些传递给<code>push</code>方法的元素，它们是<code>E</code>类型的，所以未经检查的强制转换不会造成任何伤害。</p><p>一旦证明未经检查的强制转换是安全的，请尽可能缩小范围（条目 27）。 在这种情况下，构造方法只包含未经检查的数组创建，所以在整个构造方法中抑制警告是合适的。 通过添加一个注解来执行此操作，Stack可以干净地编译，并且可以在没有显式强制转换或担心ClassCastException异常的情况下使用它：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// The elements array will contain only E instances from push(E).</span><br><span class="line">// This is sufficient to ensure type safety, but the runtime</span><br><span class="line">// type of the array won&apos;t be E[]; it will always be Object[]!</span><br><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">public Stack() &#123;</span><br><span class="line">    elements = (E[]) new Object[DEFAULT_INITIAL_CAPACITY];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消除Stack中的泛型数组创建错误的第二种方法是将属性元素的类型从<code>E []</code>更改为<code>Object []</code>。 如果这样做，会得到一个不同的错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Stack.java:19: incompatible types</span><br><span class="line">found: Object, required: E</span><br><span class="line">        E result = elements[--size];</span><br><span class="line">                           ^</span><br></pre></td></tr></table></figure><p>可以通过将从数组中检索到的元素转换为<code>E</code>来将此错误更改为警告：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Stack.java:19: warning: [unchecked] unchecked cast</span><br><span class="line">found: Object, required: E</span><br><span class="line">        E result = (E) elements[--size];</span><br><span class="line">                               ^</span><br></pre></td></tr></table></figure><p>因为E是不可具体化的类型，编译器无法在运行时检查强制转换。 再一次，你可以很容易地向自己证明，不加限制的转换是安全的，所以可以适当地抑制警告。 根据条目 27的建议，我们只在包含未经检查的强制转换的分配上抑制警告，而不是在整个<code>pop</code>方法上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// Appropriate suppression of unchecked warning</span><br><span class="line">public E pop() &#123;</span><br><span class="line">    if (size == 0)</span><br><span class="line">        throw new EmptyStackException();</span><br><span class="line"></span><br><span class="line">    // push requires elements to be of type E, so cast is correct</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;) E result =</span><br><span class="line">        (E) elements[--size];</span><br><span class="line"></span><br><span class="line">    elements[size] = null; // Eliminate obsolete reference</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两种消除泛型数组创建的技术都有其追随者。 第一个更可读：数组被声明为<code>E []</code>类型，清楚地表明它只包含E实例。 它也更简洁：在一个典型的泛型类中，你从代码中的许多点读取数组; 第一种技术只需要一次转换（创建数组的地方），而第二种技术每次读取数组元素都需要单独转换。 因此，第一种技术是优选的并且在实践中更常用。 但是，它确实会造成堆污染（heap pollution）（条目 32）：数组的运行时类型与编译时类型不匹配（除非E碰巧是Object）。 这使得一些程序员非常不安，他们选择了第二种技术，尽管在这种情况下堆的污染是无害的。</p><p>下面的程序演示了泛型Stack类的使用。 该程序以相反的顺序打印其命令行参数，并将其转换为大写。 对从堆栈弹出的元素调用String的<code>toUpperCase</code>方法不需要显式强制转换，而自动生成的强制转换将保证成功：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// Little program to exercise our generic Stack</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Stack&lt;String&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">    for (String arg : args)</span><br><span class="line">        stack.push(arg);</span><br><span class="line">    while (!stack.isEmpty())</span><br><span class="line">        System.out.println(stack.pop().toUpperCase());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子似乎与条目 28相矛盾，条目 28中鼓励使用列表优先于数组。 在泛型类型中使用列表并不总是可行或可取的。 Java本身生来并不支持列表，所以一些泛型类型（如ArrayList）必须在数组上实现。 其他的泛型类型，比如HashMap，是为了提高性能而实现的。</p><p>绝大多数泛型类型就像我们的Stack示例一样，它们的类型参数没有限制：可以创建一个<code>Stack &lt;Object&gt;</code>，<code>Stack &lt;int []&gt;</code>，<code>Stack &lt;List &lt;String &gt;&gt;</code>或者其他任何对象的Stack引用类型。 请注意，不能创建基本类型的堆栈：尝试创建<code>Stack&lt;int&gt;</code>或<code>Stack&lt;double&gt;</code>将导致编译时错误。 这是Java泛型类型系统的一个基本限制。 可以使用基本类型的包装类（条目 61）来解决这个限制。</p><p>有一些泛型类型限制了它们类型参数的允许值。 例如，考虑<code>java.util.concurrent.DelayQueue</code>，它的声明如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class DelayQueue&lt;E extends Delayed&gt; implements BlockingQueue&lt;E&gt;</span><br></pre></td></tr></table></figure><p>类型参数列表（<code>&lt;E extends Delayed&gt;</code>）要求实际的类型参数<code>E</code>是<code>java.util.concurrent.Delayed</code>的子类型。 这使得<code>DelayQueue</code>实现及其客户端可以利用<code>DelayQueue</code>元素上的<code>Delayed</code>方法，而不需要显式的转换或ClassCastException异常的风险。 类型参数E被称为限定类型参数。 请注意，子类型关系被定义为每个类型都是自己的子类型[JLS，4.10]，因此创建<code>DelayQueue &lt;Delayed&gt;</code>是合法的。</p><p>总之，泛型类型比需要在客户端代码中强制转换的类型更安全，更易于使用。 当你设计新的类型时，确保它们可以在没有这种强制转换的情况下使用。 这通常意味着使类型泛型化。 如果你有任何现有的类型，应该是泛型的但实际上却不是，那么把它们泛型化。 这使这些类型的新用户的使用更容易，而不会破坏现有的客户端（条目 26）。</p><h2 id="30-优先使用泛型方法"><a href="#30-优先使用泛型方法" class="headerlink" title="30. 优先使用泛型方法"></a>30. 优先使用泛型方法</h2><p>正如类可以是泛型的，方法也可以是泛型的。 对参数化类型进行操作的静态工具方法通常都是泛型的。 集合中的所有“算法”方法（如<code>binarySearc</code>h和<code>sort</code>）都是泛型的。</p><p>编写泛型方法类似于编写泛型类型。 考虑这个方法，它返回两个集合的并集：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// Uses raw types - unacceptable! [Item 26]</span><br><span class="line"></span><br><span class="line">public static Set union(Set s1, Set s2) &#123;</span><br><span class="line"></span><br><span class="line">    Set result = new HashSet(s1);</span><br><span class="line"></span><br><span class="line">    result.addAll(s2);</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此方法可以编译但有两个警告：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Union.java:5: warning: [unchecked] unchecked call to</span><br><span class="line"></span><br><span class="line">HashSet(Collection&lt;? extends E&gt;) as a member of raw type HashSet</span><br><span class="line"></span><br><span class="line">        Set result = new HashSet(s1);</span><br><span class="line"></span><br><span class="line">                     ^</span><br><span class="line"></span><br><span class="line">Union.java:6: warning: [unchecked] unchecked call to</span><br><span class="line"></span><br><span class="line">addAll(Collection&lt;? extends E&gt;) as a member of raw type Set</span><br><span class="line"></span><br><span class="line">        result.addAll(s2);</span><br><span class="line"></span><br><span class="line">                     ^</span><br></pre></td></tr></table></figure><p>要修复这些警告并使方法类型安全，请修改其声明以声明表示三个集合（两个参数和返回值）的元素类型的类型参数，并在整个方法中使用此类型参数。 声明类型参数的类型参数列表位于方法的修饰符和返回类型之间。 在这个例子中，类型参数列表是<code>&lt;E&gt;</code>，返回类型是<code>Set&lt;E&gt;</code>。 类型参数的命名约定对于泛型方法和泛型类型是相同的（条目 29和68）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// Generic method</span><br><span class="line"></span><br><span class="line">public static &lt;E&gt; Set&lt;E&gt; union(Set&lt;E&gt; s1, Set&lt;E&gt; s2) &#123;</span><br><span class="line"></span><br><span class="line">    Set&lt;E&gt; result = new HashSet&lt;&gt;(s1);</span><br><span class="line"></span><br><span class="line">    result.addAll(s2);</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至少对于简单的泛型方法来说，就是这样。 此方法编译时不会生成任何警告，并提供类型安全性和易用性。 这是一个简单的程序来运行该方法。 这个程序不包含强制转换和编译时没有错误或警告：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// Simple program to exercise generic method</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">    Set&lt;String&gt; guys = Set.of(&quot;Tom&quot;, &quot;Dick&quot;, &quot;Harry&quot;);</span><br><span class="line"></span><br><span class="line">    Set&lt;String&gt; stooges = Set.of(&quot;Larry&quot;, &quot;Moe&quot;, &quot;Curly&quot;);</span><br><span class="line"></span><br><span class="line">    Set&lt;String&gt; aflCio = union(guys, stooges);</span><br><span class="line"></span><br><span class="line">    System.out.println(aflCio);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当运行这个程序时，它会打印<code>[Moe, Tom, Harry, Larry, Curly, Dick]</code>（输出中元素的顺序依赖于具体实现。）</p><p><code>union</code>方法的一个限制是所有三个集合（输入参数和返回值）的类型必须完全相同。 通过使用限定通配符类型（ bounded wildcard types）（条目 31），可以使该方法更加灵活。</p><p>有时，需要创建一个不可改变但适用于许多不同类型的对象。 因为泛型是通过擦除来实现的（条目 28），所以可以使用单个对象进行所有必需的类型参数化，但是需要编写一个静态工厂方法来重复地为每个请求的类型参数化分配对象。 这种称为泛型单例工厂（generic singleton factory）的模式用于方法对象（ function objects）（条目 42），比如<code>Collections.reverseOrder</code>方法，偶尔也用于<code>Collections.emptySet</code>之类的集合。</p><p>假设你想写一个恒等方法分配器（ identity function dispenser）。 类库提供了<code>Function.identity</code>方法，所以没有理由编写你自己的实现（条目 59），但它是有启发性的。 如果每次要求的时候都去创建一个新的恒等方法对象是浪费的，因为它是无状态的。 如果Java的泛型被具体化，那么每个类型都需要一个恒等方法，但是由于它们被擦除以后，所以泛型的单例就足够了。 以下是它的实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// Generic singleton factory pattern</span><br><span class="line"></span><br><span class="line">private static UnaryOperator&lt;Object&gt; IDENTITY_FN = (t) -&gt; t;</span><br><span class="line"></span><br><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line"></span><br><span class="line">public static &lt;T&gt; UnaryOperator&lt;T&gt; identityFunction() &#123;</span><br><span class="line"></span><br><span class="line">    return (UnaryOperator&lt;T&gt;) IDENTITY_FN;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将<code>IDENTITY_FN</code>转换为<code>(UnaryFunction &lt;T&gt;)</code>会生成一个未经检查的强制转换警告，因为<code>UnaryOperator &lt;Object&gt;</code>对于每个<code>T</code>都不是一个<code>UnaryOperator &lt;T&gt;</code>。但是恒等方法是特殊的：它返回未修改的参数，所以我们知道，使用它作为一个<code>UnaryFunction &lt;T&gt;</code>是类型安全的，无论<code>T</code>的值是多少。因此，我们可以放心地抑制由这个强制生成的未经检查的强制转换警告。 一旦我们完成了这些，代码编译没有错误或警告。</p><p>下面是一个示例程序，它使用我们的泛型单例作为<code>UnaryOperator &lt;String&gt;</code>和<code>UnaryOperator &lt;Number&gt;</code>。 像往常一样，它不包含强制转化，编译时也没有错误和警告：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// Sample program to exercise generic singleton</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">    String[] strings = &#123; &quot;jute&quot;, &quot;hemp&quot;, &quot;nylon&quot; &#125;;</span><br><span class="line"></span><br><span class="line">    UnaryOperator&lt;String&gt; sameString = identityFunction();</span><br><span class="line"></span><br><span class="line">    for (String s : strings)</span><br><span class="line"></span><br><span class="line">        System.out.println(sameString.apply(s));</span><br><span class="line"></span><br><span class="line">    Number[] numbers = &#123; 1, 2.0, 3L &#125;;</span><br><span class="line"></span><br><span class="line">    UnaryOperator&lt;Number&gt; sameNumber = identityFunction();</span><br><span class="line"></span><br><span class="line">    for (Number n : numbers)</span><br><span class="line"></span><br><span class="line">        System.out.println(sameNumber.apply(n));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然相对较少，类型参数受涉及该类型参数本身的某种表达式限制是允许的。 这就是所谓的递归类型限制（recursive type bound）。 递归类型限制的常见用法与<code>Comparable</code>接口有关，它定义了一个类型的自然顺序（条目 14）。 这个接口如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface Comparable&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    int compareTo(T o);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类型参数<code>T</code>定义了实现<code>Comparable &lt;T&gt;</code>的类型的元素可以比较的类型。 在实际中，几乎所有类型都只能与自己类型的元素进行比较。 所以，例如，<code>String</code>类实现了<code>Comparable &lt;String&gt;</code>，<code>Integer</code>类实现了<code>Comparable &lt;Integer&gt;</code>等等。</p><p>许多方法采用实现<code>Comparable</code>的元素的集合来对其进行排序，在其中进行搜索，计算其最小值或最大值等。 要做到这一点，要求集合中的每一个元素都可以与其中的每一个元素相比，换言之，这个元素是可以相互比较的。 以下是如何表达这一约束：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// Using a recursive type bound to express mutual comparability</span><br><span class="line"></span><br><span class="line">public static &lt;E extends Comparable&lt;E&gt;&gt; E max(Collection&lt;E&gt; c);</span><br></pre></td></tr></table></figure><p>限定的类型<code>&lt;E extends Comparable &lt;E &gt;&gt;</code>可以理解为“任何可以与自己比较的类型<code>E</code>”，这或多或少精确地对应于相互可比性的概念。</p><p>这里有一个与前面的声明相匹配的方法。它根据其元素的自然顺序来计算集合中的最大值，并编译没有错误或警告：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// Returns max value in a collection - uses recursive type bound</span><br><span class="line"></span><br><span class="line">public static &lt;E extends Comparable&lt;E&gt;&gt; E max(Collection&lt;E&gt; c) &#123;</span><br><span class="line"></span><br><span class="line">    if (c.isEmpty())</span><br><span class="line"></span><br><span class="line">        throw new IllegalArgumentException(&quot;Empty collection&quot;);</span><br><span class="line"></span><br><span class="line">    E result = null;</span><br><span class="line"></span><br><span class="line">    for (E e : c)</span><br><span class="line"></span><br><span class="line">        if (result == null || [e.compareTo(result](http://e.compareTo(result)) &gt; 0)</span><br><span class="line"></span><br><span class="line">            result = Objects.requireNonNull(e);</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，如果列表为空，则此方法将引发<code>IllegalArgumentException</code>异常。 更好的选择是返回一个<code>Optional&lt;E&gt;</code>（条目 55）。</p><p>递归类型限制可能变得复杂得多，但幸运的是他们很少这样做。 如果你理解了这个习惯用法，它的通配符变体（条目 31）和模拟的自我类型用法（条目 2），你将能够处理在实践中遇到的大多数递归类型限制。</p><p>总之，像泛型类型一样，泛型方法比需要客户端对输入参数和返回值进行显式强制转换的方法更安全，更易于使用。 像类型一样，你应该确保你的方法可以不用强制转换，这通常意味着它们是泛型的。 应该泛型化现有的方法，其使用需要强制转换。 这使得新用户的使用更容易，而不会破坏现有的客户端（条目 26）。</p><h2 id="31-使用限定通配符来增加API的灵活性"><a href="#31-使用限定通配符来增加API的灵活性" class="headerlink" title="31. 使用限定通配符来增加API的灵活性"></a>31. 使用限定通配符来增加API的灵活性</h2><p>如条目 28所述，参数化类型是不变的。换句话说，对于任何两个不同类型的<code>Type1</code>和<code>Type</code>，<code>List &lt;Type1&gt;</code>既不是<code>List &lt;Type2&gt;</code>子类型也不是其父类型。尽管<code>List &lt;String&gt;</code>不是<code>List &lt;Object&gt;</code>的子类型是违反直觉的，但它确实是有道理的。 可以将任何对象放入<code>List &lt;Object&gt;</code>中，但是只能将字符串放入<code>List &lt;String&gt;</code>中。 由于<code>List &lt;String&gt;</code>不能做<code>List &lt;Object&gt;</code>所能做的所有事情，所以它不是一个子类型（条目 10 中的里氏替代原则）。</p><p>相对于提供的不可变的类型，有时你需要比此更多的灵活性。 考虑条目 29中的<code>Stack</code>类。下面是它的公共API：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Stack&lt;E&gt; &#123;</span><br><span class="line"></span><br><span class="line">    public Stack();</span><br><span class="line"></span><br><span class="line">    public void push(E e);</span><br><span class="line"></span><br><span class="line">    public E pop();</span><br><span class="line"></span><br><span class="line">    public boolean isEmpty();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设我们想要添加一个方法来获取一系列元素，并将它们全部推送到栈上。 以下是第一种尝试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// pushAll method without wildcard type - deficient!</span><br><span class="line"></span><br><span class="line">public void pushAll(Iterable&lt;E&gt; src) &#123;</span><br><span class="line">    for (E e : src)</span><br><span class="line">        push(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法可以干净地编译，但不完全令人满意。 如果可遍历的<code>src</code>元素类型与栈的元素类型完全匹配，那么它工作正常。 但是，假设有一个<code>Stack &lt;Number&gt;</code>，并调用<code>push(intVal)</code>，其中<code>intVal</code>的类型是<code>Integer</code>。 这是因为<code>Integer</code>是<code>Number</code>的子类型。 从逻辑上看，这似乎也应该起作用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;Number&gt; numberStack = new Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">Iterable&lt;Integer&gt; integers = ... ;</span><br><span class="line"></span><br><span class="line">numberStack.pushAll(integers);</span><br></pre></td></tr></table></figure><p>但是，如果你尝试了，会得到这个错误消息，因为参数化类型是不变的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">StackTest.java:7: error: incompatible types: Iterable&lt;Integer&gt;</span><br><span class="line"></span><br><span class="line">cannot be converted to Iterable&lt;Number&gt;</span><br><span class="line"></span><br><span class="line">        numberStack.pushAll(integers);</span><br><span class="line"></span><br><span class="line">                            ^</span><br></pre></td></tr></table></figure><p>幸运的是，有对应的解决方法。 该语言提供了一种特殊的参数化类型来调用一个限定通配符类型来处理这种情况。 <code>pushAll</code>的输入参数的类型不应该是“E的Iterable接口”，而应该是“E的某个子类型的Iterable接口”，并且有一个通配符类型，这意味着：<code>Iterable &lt;？ extends E&gt;</code>。 （关键字<code>extends</code>的使用有点误导：回忆条目 29中，子类型被定义为每个类型都是它自己的子类型，即使它本身没有继承。）让我们修改<code>pushAll</code>来使用这个类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Wildcard type for a parameter that serves as an E producer</span><br><span class="line"></span><br><span class="line">public void pushAll(Iterable&lt;? extends E&gt; src) &#123;</span><br><span class="line">    for (E e : src)</span><br><span class="line">        push(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了这个改变，<code>Stack</code>类不仅可以干净地编译，而且客户端代码也不会用原始的<code>pushAll</code>声明编译。 因为<code>Stack</code>和它的客户端干净地编译，你知道一切都是类型安全的。</p><p>现在假设你想写一个<code>popAll</code>方法，与<code>pushAll</code>方法相对应。 <code>popAll</code>方法从栈中弹出每个元素并将元素添加到给定的集合中。 以下是第一次尝试编写<code>popAll</code>方法的过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// popAll method without wildcard type - deficient!</span><br><span class="line"></span><br><span class="line">public void popAll(Collection&lt;E&gt; dst) &#123;</span><br><span class="line"></span><br><span class="line">    while (!isEmpty())</span><br><span class="line"></span><br><span class="line">        dst.add(pop());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样，如果目标集合的元素类型与栈的元素类型完全匹配，则干净编译并且工作正常。 但是，这又不完全令人满意。 假设你有一个<code>Stack &lt;Number&gt;</code>和<code>Object</code>类型的变量。 如果从栈中弹出一个元素并将其存储在该变量中，它将编译并运行而不会出错。 所以你也不能这样做吗？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;Number&gt; numberStack = new Stack&lt;Number&gt;();</span><br><span class="line"></span><br><span class="line">Collection&lt;Object&gt; objects = ... ;</span><br><span class="line"></span><br><span class="line">numberStack.popAll(objects);</span><br></pre></td></tr></table></figure><p>如果尝试将此客户端代码与之前显示的<code>popAll</code>版本进行编译，则会得到与我们的第一版<code>pushAll</code>非常类似的错误：<code>Collection &lt;Object&gt;</code>不是<code>Collection &lt;Number&gt;</code>的子类型。 通配符类型再一次提供了一条出路。 <code>popAll</code>的输入参数的类型不应该是“E的集合”，而应该是“E的某个父类型的集合”（其中父类型被定义为E是它自己的父类型[JLS，4.10]）。 再次，有一个通配符类型，正是这个意思：<code>Collection &lt;？ super E&gt;</code>。 让我们修改<code>popAll</code>来使用它：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// Wildcard type for parameter that serves as an E consumer</span><br><span class="line"></span><br><span class="line">public void popAll(Collection&lt;? super E&gt; dst) &#123;</span><br><span class="line"></span><br><span class="line">    while (!isEmpty())</span><br><span class="line"></span><br><span class="line">        dst.add(pop());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这个改动，Stack类和客户端代码都可以干净地编译。</p><p>这个结论很清楚。 <strong>为了获得最大的灵活性，对代表生产者或消费者的输入参数使用通配符类型</strong>。 如果一个输入参数既是一个生产者又是一个消费者，那么通配符类型对你没有好处：你需要一个精确的类型匹配，这就是没有任何通配符的情况。</p><p>这里有一个助记符来帮助你记住使用哪种通配符类型：<br><strong>PECS代表： producer-extends，consumer-super。</strong></p><p>换句话说，如果一个参数化类型代表一个<code>T</code>生产者，使用<code>&lt;? extends T&gt;</code>；如果它代表<code>T</code>消费者，则使用<code>&lt;? super T&gt;</code>。 在我们的<code>Stack</code>示例中，<code>pushAll</code>方法的<code>src</code>参数生成栈使用的<code>E</code>实例，因此<code>src</code>的合适类型为<code>Iterable&lt;? extends E&gt;</code>；<code>popAll</code>方法的<code>dst</code>参数消费<code>Stack</code>中的<code>E</code>实例，因此<code>ds</code>t的合适类型是<code>Collection &lt;？ super E&gt;</code>。 PECS助记符抓住了使用通配符类型的基本原则。 Naftalin和Wadler称之为获取和放置原则（ Get and Put Principle ）[Naftalin07,2.4]。</p><p>记住这个助记符之后，让我们来看看本章中以前项目的一些方法和构造方法声明。 条目 28中的<code>Chooser</code>类构造方法有这样的声明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public Chooser(Collection&lt;T&gt; choices)</span><br></pre></td></tr></table></figure><p>这个构造方法只使用集合选择来生产类型<code>T</code>的值（并将它们存储起来以备后用），所以它的声明应该使用一个<code>extends T</code>的通配符类型。下面是得到的构造方法声明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// Wildcard type for parameter that serves as an T producer</span><br><span class="line"></span><br><span class="line">public Chooser(Collection&lt;? extends T&gt; choices)</span><br></pre></td></tr></table></figure><p>这种改变在实践中会有什么不同吗？ 是的，会有不同。 假你有一个<code>List &lt;Integer&gt;</code>，并且想把它传递给<code>Chooser&lt;Number&gt;</code>的构造方法。 这不会与原始声明一起编译，但是它只会将限定通配符类型添加到声明中。</p><p>现在看看条目 30中的<code>union</code>方法。下是声明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;E&gt; Set&lt;E&gt; union(Set&lt;E&gt; s1, Set&lt;E&gt; s2)</span><br></pre></td></tr></table></figure><p>两个参数<code>s1</code>和<code>s2</code>都是<code>E</code>的生产者，所以PECS助记符告诉我们该声明应该如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;E&gt; Set&lt;E&gt; union(Set&lt;? extends E&gt; s1,  Set&lt;? extends E&gt; s2)</span><br></pre></td></tr></table></figure><p>请注意，返回类型仍然是<code>Set &lt;E&gt;</code>。 不要使用限定通配符类型作为返回类型。除了会为用户提供额外的灵活性，还强制他们在客户端代码中使用通配符类型。 通过修改后的声明，此代码将清晰地编译：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Integer&gt;  integers =  Set.of(1, 3, 5);</span><br><span class="line"></span><br><span class="line">Set&lt;Double&gt;   doubles  =  Set.of(2.0, 4.0, 6.0);</span><br><span class="line"></span><br><span class="line">Set&lt;Number&gt;   numbers  =  union(integers, doubles);</span><br></pre></td></tr></table></figure><p>如果使用得当，类的用户几乎不会看到通配符类型。 他们使方法接受他们应该接受的参数，拒绝他们应该拒绝的参数。 <strong>如果一个类的用户必须考虑通配符类型，那么它的API可能有问题。</strong></p><p>在Java 8之前，类型推断规则不够聪明，无法处理先前的代码片段，这要求编译器使用上下文指定的返回类型（或目标类型）来推断<code>E</code>的类型。<code>union</code>方法调用的目标类型如前所示是<code>Set &lt;Number&gt;</code>。 如果尝试在早期版本的Java中编译片段（以及适合的<code>Set.of</code>工厂替代版本），将会看到如此长的错综复杂的错误消息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Union.java:14: error: incompatible types</span><br><span class="line"></span><br><span class="line">        Set&lt;Number&gt; numbers = union(integers, doubles);</span><br><span class="line"></span><br><span class="line">                                   ^</span><br><span class="line"></span><br><span class="line">  required: Set&lt;Number&gt;</span><br><span class="line"></span><br><span class="line">  found:    Set&lt;INT#1&gt;</span><br><span class="line"></span><br><span class="line">  where INT#1,INT#2 are intersection types:</span><br><span class="line"></span><br><span class="line">    INT#1 extends Number,Comparable&lt;? extends INT#2&gt;</span><br><span class="line"></span><br><span class="line">    INT#2 extends Number,Comparable&lt;?&gt;</span><br></pre></td></tr></table></figure><p>幸运的是有办法来处理这种错误。 如果编译器不能推断出正确的类型，你可以随时告诉它使用什么类型的显式类型参数[JLS，15.12]。 甚至在Java 8中引入目标类型之前，这不是你必须经常做的事情，这很好，因为显式类型参数不是很漂亮。 通过添加显式类型参数，如下所示，代码片段在Java 8之前的版本中进行了干净编译：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// Explicit type parameter - required prior to Java 8</span><br><span class="line"></span><br><span class="line">Set&lt;Number&gt; numbers = Union.&lt;Number&gt;union(integers, doubles);</span><br></pre></td></tr></table></figure><p>接下来让我们把注意力转向条目 30中的<code>max</code>方法。这里是原始声明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T extends Comparable&lt;T&gt;&gt; T max(List&lt;T&gt; list)</span><br></pre></td></tr></table></figure><p>以下是使用通配符类型的修改后的声明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T extends Comparable&lt;? super T&gt;&gt; T max(List&lt;? extends T&gt; list)</span><br></pre></td></tr></table></figure><p>为了从原来到修改后的声明，我们两次应用了PECS。首先直接的应用是参数列表。 它生成<code>T</code>实例，所以将类型从<code>List &lt;T&gt;</code>更改为<code>List&lt;? extends T&gt;</code>。 棘手的应用是类型参数<code>T</code>。这是我们第一次看到通配符应用于类型参数。 最初，<code>T</code>被指定为继承<code>Comparable &lt;T&gt;</code>，但<code>Comparable</code>的<code>T</code>消费<code>T</code>实例（并生成指示顺序关系的整数）。 因此，参数化类型<code>Comparable &lt;T&gt;</code>被替换为限定通配符类型<code>Comparable&lt;? super T&gt;</code>。 <code>Comparable</code>实例总是消费者，所以通常应该<strong>使用Comparable&lt;? super T&gt;优于Comparable <t></t></strong>。 <code>Comparator</code>也是如此。因此，通常应该<strong>使用Comparator&lt;? super T&gt;优于Comparator<t></t></strong>。</p><p>修改后的<code>max</code>声明可能是本书中最复杂的方法声明。 增加的复杂性是否真的起作用了吗？ 同样，它的确如此。 这是一个列表的简单例子，它被原始声明排除，但在被修改后的版本里是允许的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;ScheduledFuture&lt;?&gt;&gt; scheduledFutures = ... ;</span><br></pre></td></tr></table></figure><p>无法将原始方法声明应用于此列表的原因是<code>ScheduledFuture</code>不实现<code>Comparable &lt;ScheduledFuture&gt;</code>。 相反，它是<code>Delayed</code>的子接口，它继承了<code>Comparable &lt;Delayed&gt;</code>。 换句话说，一个<code>ScheduledFuture</code>实例不仅仅和其他的<code>ScheduledFuture</code>实例相比较： 它可以与任何<code>Delayed</code>实例比较，并且足以导致原始的声明拒绝它。 更普遍地说，通配符要求来支持没有直接实现<code>Comparable</code>（或<code>Comparator</code>）的类型，但继承了一个类型。</p><p>还有一个关于通配符相关的话题。 类型参数和通配符之间具有双重性，许多方法可以用一个或另一个声明。 例如，下面是两个可能的声明，用于交换列表中两个索引项目的静态方法。 第一个使用无限制类型参数（条目 30），第二个使用无限制通配符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Two possible declarations for the swap method</span><br><span class="line"></span><br><span class="line">public static &lt;E&gt; void swap(List&lt;E&gt; list, int i, int j);</span><br><span class="line"></span><br><span class="line">public static void swap(List&lt;?&gt; list, int i, int j);</span><br></pre></td></tr></table></figure><p>这两个声明中的哪一个更可取，为什么？ 在公共API中，第二个更好，因为它更简单。 你传入一个列表（任何列表），该方法交换索引的元素。 没有类型参数需要担心。 通常，<strong>如果类型参数在方法声明中只出现一次，请将其替换为通配符</strong>。 如果它是一个无限制的类型参数，请将其替换为无限制的通配符; 如果它是一个限定类型参数，则用限定通配符替换它。</p><p>第二个<code>swap</code>方法声明有一个问题。 这个简单的实现不会编译：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static void swap(List&lt;?&gt; list, int i, int j) &#123;</span><br><span class="line">    list.set(i, list.set(j, list.get(i)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>试图编译它会产生这个不太有用的错误信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Swap.java:5: error: incompatible types: Object cannot be</span><br><span class="line"></span><br><span class="line">converted to CAP#1</span><br><span class="line"></span><br><span class="line">        list.set(i, list.set(j, list.get(i)));</span><br><span class="line"></span><br><span class="line">                                        ^</span><br><span class="line"></span><br><span class="line">  where CAP#1 is a fresh type-variable:</span><br><span class="line"></span><br><span class="line">    CAP#1 extends Object from capture of ?</span><br></pre></td></tr></table></figure><p>看起来我们不能把一个元素放回到我们刚刚拿出来的列表中。 问题是列表的类型是<code>List &lt;？&gt;</code>，并且不能将除null外的任何值放入<code>List &lt;？&gt;</code>中。 幸运的是，有一种方法可以在不使用不安全的转换或原始类型的情况下实现此方法。 这个想法是写一个私有辅助方法来捕捉通配符类型。 辅助方法必须是泛型方法才能捕获类型。 以下是它的定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static void swap(List&lt;?&gt; list, int i, int j) &#123;</span><br><span class="line"></span><br><span class="line">    swapHelper(list, i, j);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Private helper method for wildcard capture</span><br><span class="line"></span><br><span class="line">private static &lt;E&gt; void swapHelper(List&lt;E&gt; list, int i, int j) &#123;</span><br><span class="line"></span><br><span class="line">    list.set(i, list.set(j, list.get(i)));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>swapHelper</code>方法知道该列表是一个<code>List &lt;E&gt;</code>。 因此，它知道从这个列表中获得的任何值都是E类型，并且可以安全地将任何类型的<code>E</code>值放入列表中。 这个稍微复杂的<code>swap</code>的实现可以干净地编译。 它允许我们导出基于通配符的漂亮声明，同时利用内部更复杂的泛型方法。 <code>swap</code>方法的客户端不需要面对更复杂的<code>swapHelper</code>声明，但他们从中受益。 辅助方法具有我们认为对公共方法来说过于复杂的签名。</p><p>总之，在你的API中使用通配符类型，虽然棘手，但使得API更加灵活。 如果编写一个将被广泛使用的类库，正确使用通配符类型应该被认为是强制性的。 记住基本规则： producer-extends, consumer-super（PECS）。 还要记住，所有<code>Comparable</code>和<code>Comparator</code>都是消费者。</p><h2 id="32-合理地结合泛型和可变参数"><a href="#32-合理地结合泛型和可变参数" class="headerlink" title="32. 合理地结合泛型和可变参数"></a>32. 合理地结合泛型和可变参数</h2><p>在Java 5中，可变参数方法（条目 53）和泛型都被添加到平台中，所以你可能希望它们能够正常交互; 可悲的是，他们并没有。 可变参数的目的是允许客户端将一个可变数量的参数传递给一个方法，但这是一个脆弱的抽象（ leaky abstraction）：当你调用一个可变参数方法时，会创建一个数组来保存可变参数；那个应该是实现细节的数组是可见的。 因此，当可变参数具有泛型或参数化类型时，会导致编译器警告混淆。</p><p>回顾条目 28，非具体化（ non-reifiable）的类型是其运行时表示比其编译时表示具有更少信息的类型，并且几乎所有泛型和参数化类型都是不可具体化的。 如果某个方法声明其可变参数为非具体化的类型，则编译器将在该声明上生成警告。 如果在推断类型不可确定的可变参数参数上调用该方法，那么编译器也会在调用中生成警告。 警告看起来像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">warning: [unchecked] Possible heap pollution from</span><br><span class="line">    parameterized vararg type List&lt;String&gt;</span><br></pre></td></tr></table></figure><p>当参数化类型的变量引用不属于该类型的对象时会发生堆污染（Heap pollution）[JLS，4.12.2]。 它会导致编译器的自动生成的强制转换失败，违反了泛型类型系统的基本保证。</p><p>例如，请考虑以下方法，该方法是第127页上的代码片段的一个不太明显的变体：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// Mixing generics and varargs can violate type safety!</span><br><span class="line">static void dangerous(List&lt;String&gt;... stringLists) &#123;</span><br><span class="line">    List&lt;Integer&gt; intList = List.of(42);</span><br><span class="line">    Object[] objects = stringLists;</span><br><span class="line">    objects[0] = intList;             // Heap pollution</span><br><span class="line">    String s = stringLists[0].get(0); // ClassCastException</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此方法没有可见的强制转换，但在调用一个或多个参数时抛出ClassCastException异常。 它的最后一行有一个由编译器生成的隐形转换。 这种转换失败，表明类型安全性已经被破坏，并且<strong>将值保存在泛型可变参数数组参数中是不安全的</strong>。</p><p>这个例子引发了一个有趣的问题：为什么声明一个带有泛型可变参数的方法是合法的，当明确创建一个泛型数组是非法的时候呢？ 换句话说，为什么前面显示的方法只生成一个警告，而127页上的代码片段会生成一个错误？ 答案是，具有泛型或参数化类型的可变参数参数的方法在实践中可能非常有用，因此语言设计人员选择忍受这种不一致。 事实上，Java类库导出了几个这样的方法，包括<code>Arrays.asList(T... a)</code>，<code>Collections.addAll(Collection&lt;? super T&gt; c, T... elements)</code>，<code>EnumSet.of(E first, E... rest)</code>。 与前面显示的危险方法不同，这些类库方法是类型安全的。</p><p>在Java 7中，<code>SafeVarargs</code>注解已添加到平台，以允许具有泛型可变参数的方法的作者自动禁止客户端警告。 实质上，<strong>SafeVarargs注解构成了作者对类型安全的方法的承诺</strong>。 为了交换这个承诺，编译器同意不要警告用户调用可能不安全的方法。</p><p>除非它实际上是安全的，否则注意不要使用<code>@SafeVarargs</code>注解标注一个方法。 那么需要做些什么来确保这一点呢？ 回想一下，调用方法时会创建一个泛型数组，以容纳可变参数。 如果方法没有在数组中存储任何东西（它会覆盖参数）并且不允许对数组的引用进行转义（这会使不受信任的代码访问数组），那么它是安全的。 换句话说，如果可变参数数组仅用于从调用者向方法传递可变数量的参数——毕竟这是可变参数的目的——那么该方法是安全的。</p><p>值得注意的是，你可以违反类型安全性，即使不会在可变参数数组中存储任何内容。 考虑下面的泛型可变参数方法，它返回一个包含参数的数组。 乍一看，它可能看起来像一个方便的小工具：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// UNSAFE - Exposes a reference to its generic parameter array!</span><br><span class="line">static &lt;T&gt; T[] toArray(T... args) &#123;</span><br><span class="line">    return args;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法只是返回它的可变参数数组。 该方法可能看起来并不危险，但它是！ 该数组的类型由传递给方法的参数的编译时类型决定，编译器可能没有足够的信息来做出正确的判断。 由于此方法返回其可变参数数组，它可以将堆污染传播到调用栈上。</p><p>为了具体说明，请考虑下面的泛型方法，它接受三个类型<code>T</code>的参数，并返回一个包含两个参数的数组，随机选择：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static &lt;T&gt; T[] pickTwo(T a, T b, T c) &#123;</span><br><span class="line">    switch(ThreadLocalRandom.current().nextInt(3)) &#123;</span><br><span class="line">      case 0: return toArray(a, b);</span><br><span class="line">      case 1: return toArray(a, c);</span><br><span class="line">      case 2: return toArray(b, c);</span><br><span class="line">    &#125;</span><br><span class="line">    throw new AssertionError(); // Can&apos;t get here</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法本身不是危险的，除了调用具有泛型可变参数的<code>toArray</code>方法之外，不会产生警告。</p><p>编译此方法时，编译器会生成代码以创建一个将两个<code>T</code>实例传递给<code>toArray</code>的可变参数数组。 这段代码分配了一个<code>Object []</code>类型的数组，它是保证保存这些实例的最具体的类型，而不管在调用位置传递给<code>pickTwo</code>的对象是什么类型。 <code>toArray</code>方法只是简单地将这个数组返回给<code>pickTwo</code>，然后<code>pickTwo</code>将它返回给调用者，所以<code>pickTwo</code>总是返回一个<code>Object []</code>类型的数组。</p><p>现在考虑这个测试<code>pickTw</code>的<code>main</code>方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    String[] attributes = pickTwo(&quot;Good&quot;, &quot;Fast&quot;, &quot;Cheap&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法没有任何问题，因此它编译时不会产生任何警告。 但是当运行它时，抛出一个ClassCastException异常，尽管不包含可见的转换。 你没有看到的是，编译器已经生成了一个隐藏的强制转换为由<code>pickTwo</code>返回的值的<code>String []</code>类型，以便它可以存储在属性中。 转换失败，因为<code>Object []</code>不是<code>String []</code>的子类型。 这种故障相当令人不安，因为它从实际导致堆污染（<code>toArray</code>）的方法中移除了两个级别，并且在实际参数存储在其中之后，可变参数数组未被修改。</p><p>这个例子是为了让人们认识到<strong>给另一个方法访问一个泛型的可变参数数组是不安全的</strong>，除了两个例外：将数组传递给另一个可变参数方法是安全的，这个方法是用<code>@SafeVarargs</code>正确标注的， 将数组传递给一个非可变参数的方法是安全的，该方法仅计算数组内容的一些方法。</p><p>这里是安全使用泛型可变参数的典型示例。 此方法将任意数量的列表作为参数，并按顺序返回包含所有输入列表元素的单个列表。 由于该方法使用<code>@SafeVarargs</code>进行标注，因此在声明或其调用站位置上不会生成任何警告：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// Safe method with a generic varargs parameter</span><br><span class="line">@SafeVarargs</span><br><span class="line">static &lt;T&gt; List&lt;T&gt; flatten(List&lt;? extends T&gt;... lists) &#123;</span><br><span class="line">    List&lt;T&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line">    for (List&lt;? extends T&gt; list : lists)</span><br><span class="line">        result.addAll(list);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>决定何时使用<code>SafeVarargs</code>注解的规则很简单：在每种方法上使用<code>@SafeVarargs</code>，并使用泛型或参数化类型的可变参数，这样用户就不会因不必要的和令人困惑的编译器警告而担忧。 这意味着你不应该写危险或者<code>toArray</code>等不安全的可变参数方法。 每次编译器警告你可能会受到来自你控制的方法中泛型可变参数的堆污染时，请检查该方法是否安全。 提醒一下，在下列情况下，泛型可变参数方法是安全的：<br>1.它不会在可变参数数组中存储任何东西</p><p>2.它不会使数组（或克隆）对不可信代码可见。 如果违反这些禁令中的任何一项，请修复。</p><p>请注意，<code>SafeVarargs</code>注解只对不能被重写的方法是合法的，因为不可能保证每个可能的重写方法都是安全的。 在Java 8中，注解仅在静态方法和final实例方法上合法; 在Java 9中，它在私有实例方法中也变为合法。</p><p>使用<code>SafeVarargs</code>注解的替代方法是采用条目 28的建议，并用<code>List</code>参数替换可变参数（这是一个变相的数组）。 下面是应用于我们的<code>flatten</code>方法时，这种方法的样子。 请注意，只有参数声明被更改了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// List as a typesafe alternative to a generic varargs parameter</span><br><span class="line">static &lt;T&gt; List&lt;T&gt; flatten(List&lt;List&lt;? extends T&gt;&gt; lists) &#123;</span><br><span class="line">    List&lt;T&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line">    for (List&lt;? extends T&gt; list : lists)</span><br><span class="line">        result.addAll(list);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后可以将此方法与静态工厂方法<code>List.of</code>结合使用，以允许可变数量的参数。 请注意，这种方法依赖于<code>List.of</code>声明使用<code>@SafeVarargs</code>注解：<br>audience = flatten(List.of(friends, romans, countrymen));</p><p>这种方法的优点是编译器可以证明这种方法是类型安全的。 不必使用<code>SafeVarargs</code>注解来证明其安全性，也不用担心在确定安全性时可能会犯错。 主要缺点是客户端代码有点冗长，运行可能会慢一些。</p><p>这个技巧也可以用在不可能写一个安全的可变参数方法的情况下，就像第147页的<code>toArray</code>方法那样。它的列表模拟是<code>List.of</code>方法，所以我们甚至不必编写它; Java类库作者已经为我们完成了这项工作。 <code>pickTwo</code>方法然后变成这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static &lt;T&gt; List&lt;T&gt; pickTwo(T a, T b, T c) &#123;</span><br><span class="line">    switch(rnd.nextInt(3)) &#123;</span><br><span class="line">      case 0: return List.of(a, b);</span><br><span class="line">      case 1: return List.of(a, c);</span><br><span class="line">      case 2: return List.of(b, c);</span><br><span class="line">    &#125;</span><br><span class="line">    throw new AssertionError();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>main</code>方变成这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;String&gt; attributes = pickTwo(&quot;Good&quot;, &quot;Fast&quot;, &quot;Cheap&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成的代码是类型安全的，因为它只使用泛型，不是数组。</p><p>总而言之，可变参数和泛型不能很好地交互，因为可变参数机制是在数组上面构建的脆弱的抽象，并且数组具有与泛型不同的类型规则。 虽然泛型可变参数不是类型安全的，但它们是合法的。 如果选择使用泛型（或参数化）可变参数编写方法，请首先确保该方法是类型安全的，然后使用<code>@SafeVarargs</code>注解对其进行标注，以免造成使用不愉快。</p><h2 id="33-优先考虑类型安全的异构容器"><a href="#33-优先考虑类型安全的异构容器" class="headerlink" title="33. 优先考虑类型安全的异构容器"></a>33. 优先考虑类型安全的异构容器</h2><p>泛型的常见用法包括集合，如<code>Set &lt;E&gt;</code>和<code>Map &lt;K，V&gt;</code>和单个元素容器，如<code>ThreadLocal &lt;T&gt;</code>和<code>AtomicReference &lt;T&gt;</code>。 在所有这些用途中，它都是参数化的容器。 这限制了每个容器只能有固定数量的类型参数。 通常这正是你想要的。 一个<code>Set</code>有单一的类型参数，表示它的元素类型; 一个<code>Map</code>有两个，代表它的键和值的类型；等等。</p><p>然而有时候，你需要更多的灵活性。 例如，数据库一行记录可以具有任意多列，并且能够以类型安全的方式访问它们是很好的。 幸运的是，有一个简单的方法可以达到这个效果。 这个想法是参数化键（key）而不是容器。 然后将参数化的键提交给容器以插入或检索值。 泛型类型系统用于保证值的类型与其键一致。</p><p>作为这种方法的一个简单示例，请考虑一个Favorites类，它允许其客户端保存和检索任意多种类型的<code>favorite</code>实例。 该类型的Class对象将扮演参数化键的一部分。其原因是这<code>Class</code>类是泛型的。 类的类型从字面上来说不是简单的<code>Class</code>，而是<code>Class &lt;T&gt;</code>。 例如，<code>String.class</code>的类型为<code>Class &lt;String&gt;</code>，<code>Integer.class的</code>类型为<code>Class &lt;Integer&gt;</code>。 当在方法中传递字面类传递编译时和运行时类型信息时，它被称为类型令牌（type token）[Bracha04]。</p><p><code>Favorites</code>类的API很简单。 它看起来就像一个简单Map类，除了该键是参数化的以外。 客户端在设置和获取<code>favorites</code>实例时呈现一个Class对象。 这里是API：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Typesafe heterogeneous container pattern - API</span><br><span class="line">public class Favorites &#123;</span><br><span class="line">    public &lt;T&gt; void putFavorite(Class&lt;T&gt; type, T instance);</span><br><span class="line">    public &lt;T&gt; T getFavorite(Class&lt;T&gt; type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是一个演示<code>Favorites</code>类，保存，检索和打印喜欢的<code>String</code>，<code>Integer</code>和<code>Class</code>实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// Typesafe heterogeneous container pattern - client</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">    Favorites f = new Favorites();</span><br><span class="line"></span><br><span class="line">    f.putFavorite(String.class, &quot;Java&quot;);</span><br><span class="line"></span><br><span class="line">    f.putFavorite(Integer.class, 0xcafebabe);</span><br><span class="line"></span><br><span class="line">    f.putFavorite(Class.class, Favorites.class);</span><br><span class="line"></span><br><span class="line">     String favoriteString = f.getFavorite(String.class);</span><br><span class="line"></span><br><span class="line">    int favoriteInteger = f.getFavorite(Integer.class);</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; favoriteClass = f.getFavorite(Class.class);</span><br><span class="line"></span><br><span class="line">    System.out.printf(&quot;%s %x %s%n&quot;, favoriteString,</span><br><span class="line"></span><br><span class="line">        favoriteInteger, favoriteClass.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如你所期望的，这个程序打印<code>Java cafebabe Favorites</code>。 请注意，顺便说一下，Java的<code>printf</code>方法与C语言的不同之处在于，应该使用<code>％n</code>，而在C中使用<code>\n</code>。<code>％n</code>生成适用的特定于平台的行分隔符，该分隔符在很多但不是所有平台上都是<code>\n</code>。</p><p><code>Favorites</code>实例是类型安全的：当你请求一个字符串时它永远不会返回一个整数。 它也是异构的：与普通Map不同，所有的键都是不同的类型。 因此，我们将<code>Favorites</code>称为类型安全异构容器（typesafe heterogeneous container.）。</p><p><code>Favorites</code>的实现非常小巧。 这是完整的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// Typesafe heterogeneous container pattern - implementation</span><br><span class="line">public class Favorites &#123;</span><br><span class="line">    private Map&lt;Class&lt;?&gt;, Object&gt; favorites = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public &lt;T&gt; void putFavorite(Class&lt;T&gt; type, T instance) &#123;</span><br><span class="line">        favorites.put(Objects.requireNonNull(type), instance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public &lt;T&gt; T getFavorite(Class&lt;T&gt; type) &#123;</span><br><span class="line">        return type.cast(favorites.get(type));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有一些微妙的事情发生。 每个<code>Favorites</code>实例都由一个名为<code>favorites</code>私有的<code>Map&lt;Class&lt;?&gt;, Object&gt;</code>来支持。 你可能认为无法将任何内容放入此Map中，因为这是无限定的通配符类型，但事实恰恰相反。 需要注意的是通配符类型是嵌套的：它不是通配符类型的Map类型，而是键的类型。 这意味着每个键都可以有不同的参数化类型：一个可以是<code>Class &lt;String&gt;</code>，下一个<code>Class &lt;Integer&gt;</code>等等。 这就是异构的由来。</p><p>接下来要注意的是，favorites的Map的值类型只是Object。 换句话说，Map不保证键和值之间的类型关系，即每个值都是由其键表示的类型。 事实上，Java的类型系统并不足以表达这一点。 但是我们知道这是真的，并在检索一个favorite时利用了这点。</p><p><code>putFavorite</code>实现很简单：只需将给定的Class对象映射到给定的favorites的实例即可。 如上所述，这丢弃了键和值之间的“类型联系（type linkage）”；无法知道这个值是不是键的一个实例。 但没关系，因为<code>getFavorites</code>方法可以并且确实重新建立这种关联。</p><p><code>getFavorite</code>的实现比<code>putFavorite</code>更复杂。 首先，它从favorites Map中获取与给定Class对象相对应的值。 这是返回的正确对象引用，但它具有错误的编译时类型：它是Object（favorites map的值类型），我们需要返回类型<code>T</code>。因此，<code>getFavorite</code>实现动态地将对象引用转换为Class对象表示的类型，使用Class的<code>cast</code>方法。</p><p><code>cast</code>方法是Java的cast操作符的动态模拟。它只是检查它的参数是否由Class对象表示的类型的实例。如果是，它返回参数；否则会抛出<code>ClassCastException</code>异常。我们知道，假设客户端代码能够干净地编译，<code>getFavorite</code>中的强制转换不会抛出<code>ClassCastException</code>异常。 也就是说，favorites map中的值始终与其键的类型相匹配。</p><p>那么这个<code>cast</code>方法为我们做了什么，因为它只是返回它的参数？ <code>cast</code>的签名充分利用了Class类是泛型的事实。 它的返回类型是Class对象的类型参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class Class&lt;T&gt; &#123;</span><br><span class="line">    T cast(Object obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这正是<code>getFavorite</code>方法所需要的。 这正是确保Favorites类型安全，而不用求助一个未经检查的强制转换的<code>T</code>类型。</p><p>Favorites类有两个限制值得注意。 首先，恶意客户可以通过使用原始形式的Class对象，轻松破坏Favorites实例的类型安全。 但生成的客户端代码在编译时会生成未经检查的警告。 这与正常的集合实现（如HashSet和HashMap）没有什么不同。 通过使用原始类型HashSet（条目 26），可以轻松地将字符串放入<code>HashSet &lt;Integer&gt;</code>中。 也就是说，如果你愿意为此付出一点代价，就可以拥有运行时类型安全性。 确保Favorites永远不违反类型不变的方法是，使<code>putFavorite</code>方法检查该实例是否由type表示类型的实例，并且我们已经知道如何执行此操作。只需使用动态转换：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Achieving runtime type safety with a dynamic cast</span><br><span class="line">public &lt;T&gt; void putFavorite(Class&lt;T&gt; type, T instance) &#123;</span><br><span class="line">    favorites.put(type, type.cast(instance));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>java.util.Collections</code>中有一些集合包装类，可以发挥相同的诀窍。 它们被称为<code>checkedSet</code>，<code>checkedList</code>，<code>checkedMap</code>等等。 他们的静态工厂除了一个集合（或Map）之外还有一个Class对象（或两个）。 静态工厂是泛型方法，确保Class对象和集合的编译时类型匹配。 包装类为它们包装的集合添加了具体化。 例如，如果有人试图将<code>Coin</code>放入你的<code>Collection &lt;Stamp&gt;</code>中，则包装类在运行时会抛出<code>ClassCastException</code>。 这些包装类对于追踪在混合了泛型和原始类型的应用程序中添加不正确类型的元素到集合的客户端代码很有用。</p><p>Favorites类的第二个限制是它不能用于不可具体化的（non-reifiable）类型（条目 28）。 换句话说，你可以保存你最喜欢的<code>String</code>或<code>String []</code>，但不能保存<code>List &lt;String&gt;</code>。 如果你尝试保存你最喜欢的<code>List &lt;String&gt;</code>，程序将不能编译。 原因是无法获取<code>List &lt;String&gt;</code>的Class对象。 <code>List &lt;String&gt; .class</code>是语法错误，也是一件好事。 <code>List &lt;String&gt;</code>和<code>List &lt;Integer&gt;</code>共享一个Class对象，即<code>List.class</code>。 如果“字面类型（type literals）”<code>List &lt;String&gt; .class</code>和<code>List &lt;Integer&gt; .class</code>合法并返回相同的对象引用，那么它会对Favorites对象的内部造成严重破坏。 对于这种限制，没有完全令人满意的解决方法。</p><p>Favorites使用的类型令牌( type tokens)是无限制的：<code>getFavorite</code>和<code>putFavorite</code>接受任何Class对象。 有时你可能需要限制可传递给方法的类型。 这可以通过一个有限定的类型令牌来实现，该令牌只是一个类型令牌，它使用限定的类型参数（条目 30）或限定的通配符（条目 31）来放置可以表示的类型的边界。</p><p>注解API（条目 39）广泛使用限定类型的令牌。 例如，以下是在运行时读取注解的方法。 此方法来自<code>AnnotatedElement</code>接口，该接口由表示类，方法，属性和其他程序元素的反射类型实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T extends Annotation&gt;</span><br><span class="line">    T getAnnotation(Class&lt;T&gt; annotationType);</span><br></pre></td></tr></table></figure><p>参数<code>annotationType</code>是表示注解类型的限定类型令牌。 该方法返回该类型的元素的注解（如果它有一个）；如果没有，则返回null。 本质上，注解元素是一个类型安全的异构容器，其键是注解类型。</p><p>假设有一个<code>Class &lt;?&gt;</code>类型的对象，并且想要将它传递给需要限定类型令牌（如<code>getAnnotation</code>）的方法。 可以将对象转换为<code>Class&lt;? extends Annotation&gt;</code>，但是这个转换没有被检查，所以它会产生一个编译时警告（条目 27）。 幸运的是，Class类提供了一种安全（动态）执行这种类型转换的实例方法。 该方法被称为<code>asSubclass</code>，并且它转换所调用的Class对象来表示由其参数表示的类的子类。 如果转换成功，该方法返回它的参数；如果失败，则抛出<code>ClassCastException</code>异常。</p><p>以下是如何使用<code>asSubclass</code>方法在编译时读取类型未知的注解。 此方法编译时没有错误或警告：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// Use of asSubclass to safely cast to a bounded type token</span><br><span class="line">static Annotation getAnnotation(AnnotatedElement element,</span><br><span class="line">                                String annotationTypeName) &#123;</span><br><span class="line">    Class&lt;?&gt; annotationType = null; // Unbounded type token</span><br><span class="line">    try &#123;</span><br><span class="line">        annotationType = Class.forName(annotationTypeName);</span><br><span class="line">    &#125; catch (Exception ex) &#123;</span><br><span class="line">        throw new IllegalArgumentException(ex);</span><br><span class="line">    &#125;</span><br><span class="line">    return element.getAnnotation(</span><br><span class="line">        annotationType.asSubclass(Annotation.class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总之，泛型API的通常用法（以集合API为例）限制了每个容器的固定数量的类型参数。 你可以通过将类型参数放在键上而不是容器上来解决此限制。 可以使用Class对象作为此类型安全异构容器的键。 以这种方式使用的Class对象称为类型令牌。 也可以使用自定义键类型。 例如，可以有一个表示数据库行（容器）的<code>DatabaseRow</code>类型和一个泛型类型<code>Column &lt;T&gt;</code>作为其键。</p><h2 id="34-使用枚举类型替代整型常量"><a href="#34-使用枚举类型替代整型常量" class="headerlink" title="34. 使用枚举类型替代整型常量"></a>34. 使用枚举类型替代整型常量</h2><p>枚举是其合法值由一组固定的常量组成的一种类型，例如一年中的季节，太阳系中的行星或一副扑克牌中的套装。 在将枚举类型添加到该语言之前，表示枚举类型的常见模式是声明一组名为int的常量，每个类型的成员都有一个常量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// The int enum pattern - severely deficient!</span><br><span class="line">public static final int APPLE_FUJI         = 0;</span><br><span class="line">public static final int APPLE_PIPPIN       = 1;</span><br><span class="line">public static final int APPLE_GRANNY_SMITH = 2;</span><br><span class="line">public static final int ORANGE_NAVEL  = 0;</span><br><span class="line">public static final int ORANGE_TEMPLE = 1;</span><br><span class="line">public static final int ORANGE_BLOOD  = 2;</span><br></pre></td></tr></table></figure><p>这种被称为int枚举模式的技术有许多缺点。 它没有提供类型安全的方式，也没有提供任何表达力。 如果你将一个Apple传递给一个需要Orange的方法，那么编译器不会出现警告，还会用<code>==</code>运算符比较Apple与Orange，或者更糟糕的是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// Tasty citrus flavored applesauce!</span><br><span class="line">int i = (APPLE_FUJI - ORANGE_TEMPLE) / APPLE_PIPPIN;</span><br></pre></td></tr></table></figure><p>请注意，每个Apple常量的名称前缀为<code>APPLE_</code>，每个<code>Orange</code>常量的名称前缀为<code>ORANGE_</code>。 这是因为Java不为int枚举组提供名称空间。 当两个int枚举组具有相同的命名常量时，前缀可以防止名称冲突，例如在<code>ELEMENT_MERCURY</code>和<code>PLANET_MERCURY</code>之间。</p><p>使用int枚举的程序很脆弱。 因为int枚举是编译时常量[JLS，4.12.4]，所以它们的int值被编译到使用它们的客户端中[JLS，13.1]。 如果与int枚举关联的值发生更改，则必须重新编译其客户端。 如果没有，客户仍然会运行，但他们的行为将是不正确的。</p><p>没有简单的方法将int枚举常量转换为可打印的字符串。 如果你打印这样一个常量或者从调试器中显示出来，你看到的只是一个数字，这不是很有用。 没有可靠的方法来迭代组中的所有int枚举常量，甚至无法获得int枚举组的大小。</p><p>你可能会遇到这种模式的变体，其中使用了字符串常量来代替int常量。 这种称为字符串枚举模式的变体更不理想。 尽管它为常量提供了可打印的字符串，但它可以导致初级用户将字符串常量硬编码为客户端代码，而不是使用属性名称。 如果这种硬编码的字符串常量包含书写错误，它将在编译时逃脱检测并导致运行时出现错误。 此外，它可能会导致性能问题，因为它依赖于字符串比较。</p><p>幸运的是，Java提供了一种避免int和String枚举模式的所有缺点的替代方法，并提供了许多额外的好处。 它是枚举类型[JLS，8.9]。 以下是它最简单的形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public enum Apple  &#123; FUJI, PIPPIN, GRANNY_SMITH &#125;</span><br><span class="line">public enum Orange &#123; NAVEL, TEMPLE, BLOOD &#125;</span><br></pre></td></tr></table></figure><p>从表面上看，这些枚举类型可能看起来与其他语言类似，比如C，C ++和C＃，但事实并非如此。 Java的枚举类型是完整的类，比其他语言中的其他语言更强大，其枚举本质本上是int值。</p><p>Java枚举类型背后的基本思想很简单：它们是通过公共静态final属性为每个枚举常量导出一个实例的类。 由于没有可访问的构造方法，枚举类型实际上是final的。 由于客户既不能创建枚举类型的实例也不能继承它，除了声明的枚举常量外，不能有任何实例。 换句话说，枚举类型是实例控制的（第6页）。 它们是单例（条目 3）的泛型化，基本上是单元素的枚举。</p><p>枚举提供了编译时类型的安全性。 如果声明一个参数为Apple类型，则可以保证传递给该参数的任何非空对象引用是三个有效Apple值中的一个。 尝试传递错误类型的值将导致编译时错误，因为会尝试将一个枚举类型的表达式分配给另一个类型的变量，或者使用<code>==</code>运算符来比较不同枚举类型的值。</p><p>具有相同名称常量的枚举类型可以和平共存，因为每种类型都有其自己的名称空间。 可以在枚举类型中添加或重新排序常量，而无需重新编译其客户端，因为导出常量的属性在枚举类型与其客户端之间提供了一层隔离：常量值不会编译到客户端，因为它们位于int枚举模式中。 最后，可以通过调用其<code>toString</code>方法将枚举转换为可打印的字符串。</p><p>除了纠正int枚举的缺陷之外，枚举类型还允许添加任意方法和属性并实现任意接口。 它们提供了所有Object方法的高质量实现（第3章），它们实现了<code>Comparable</code>（条目 14）和<code>Serializable</code>（第12章），并针对枚举类型的可任意改变性设计了序列化方式。</p><p>那么，为什么你要添加方法或属性到一个枚举类型？ 对于初学者，可能想要将数据与其常量关联起来。 例如，我们的Apple和Orange类型可能会从返回水果颜色的方法或返回水果图像的方法中受益。 还可以使用任何看起来合适的方法来增强枚举类型。 枚举类型可以作为枚举常量的简单集合，并随着时间的推移而演变为全功能抽象。</p><p>对于丰富的枚举类型的一个很好的例子，考虑我们太阳系的八颗行星。 每个行星都有质量和半径，从这两个属性可以计算出它的表面重力。 从而在给定物体的质量下，计算出一个物体在行星表面上的重量。 下面是这个枚举类型。 每个枚举常量之后的括号中的数字是传递给其构造方法的参数。 在这种情况下，它们是地球的质量和半径：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// Enum type with data and behavior</span><br><span class="line">public enum Planet &#123;</span><br><span class="line">    MERCURY(3.302e+23, 2.439e6),</span><br><span class="line">    VENUS  (4.869e+24, 6.052e6),</span><br><span class="line">    EARTH  (5.975e+24, 6.378e6),</span><br><span class="line">    MARS   (6.419e+23, 3.393e6),</span><br><span class="line">    JUPITER(1.899e+27, 7.149e7),</span><br><span class="line">    SATURN (5.685e+26, 6.027e7),</span><br><span class="line">    URANUS (8.683e+25, 2.556e7),</span><br><span class="line">    NEPTUNE(1.024e+26, 2.477e7);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private final double mass;           // In kilograms</span><br><span class="line">    private final double radius;         // In meters</span><br><span class="line">    private final double surfaceGravity; // In m / s^2</span><br><span class="line">    // Universal gravitational constant in m^3 / kg s^2</span><br><span class="line">    private static final double G = 6.67300E-11;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // Constructor</span><br><span class="line">    Planet(double mass, double radius) &#123;</span><br><span class="line">        this.mass = mass;</span><br><span class="line">        this.radius = radius;</span><br><span class="line">        surfaceGravity = G * mass / (radius * radius);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public double mass()           &#123; return mass; &#125;</span><br><span class="line">    public double radius()         &#123; return radius; &#125;</span><br><span class="line">    public double surfaceGravity() &#123; return surfaceGravity; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public double surfaceWeight(double mass) &#123;</span><br><span class="line">        return mass * surfaceGravity;  // F = ma</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写一个丰富的枚举类型比如<code>Planet</code>很容易。 <strong>要将数据与枚举常量相关联，请声明实例属性并编写一个构造方法，构造方法带有数据并将数据保存在属性中</strong>。 枚举本质上是不变的，所以所有的属性都应该是final的（条目 17）。 属性可以是公开的，但最好将它们设置为私有并提供公共访问方法（条目16）。 在<code>Planet</code>的情况下，构造方法还计算和存储表面重力，但这只是一种优化。 每当重力被<code>SurfaceWeight</code>方法使用时，它可以从质量和半径重新计算出来，该方法返回它在由常数表示的行星上的重量。</p><p>虽然<code>Planet</code>枚举很简单，但它的功能非常强大。 这是一个简短的程序，它将一个物体在地球上的重量（任何单位），打印一个漂亮的表格，显示该物体在所有八个行星上的重量（以相同单位）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class WeightTable &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      double earthWeight = Double.parseDouble(args[0]);</span><br><span class="line">      double mass = earthWeight / Planet.EARTH.surfaceGravity();</span><br><span class="line">      for (Planet p : Planet.values())</span><br><span class="line">          System.out.printf(&quot;Weight on %s is %f%n&quot;,</span><br><span class="line">                            p, p.surfaceWeight(mass));</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，<code>Planet</code>和所有枚举一样，都有一个静态<code>values</code>方法，该方法以声明的顺序返回其值的数组。 另请注意，<code>toString</code>方法返回每个枚举值的声明名称，使<code>println</code>和<code>printf</code>可以轻松打印。 如果你对此字符串表示形式不满意，可以通过重写<code>toString</code>方法来更改它。 这是使用命令行参数185运行<code>WeightTable</code>程序（不重写toString）的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Weight on MERCURY is 69.912739</span><br><span class="line">Weight on VENUS is 167.434436</span><br><span class="line">Weight on EARTH is 185.000000</span><br><span class="line">Weight on MARS is 70.226739</span><br><span class="line">Weight on JUPITER is 467.990696</span><br><span class="line">Weight on SATURN is 197.120111</span><br><span class="line">Weight on URANUS is 167.398264</span><br><span class="line">Weight on NEPTUNE is 210.208751</span><br></pre></td></tr></table></figure><p>直到2006年，在Java中加入枚举两年之后，冥王星不再是一颗行星。 这引发了一个问题：“当你从枚举类型中移除一个元素时会发生什么？”答案是，任何不引用移除元素的客户端程序都将继续正常工作。 所以，举例来说，我们的<code>WeightTable</code>程序只需要打印一行少一行的表格。 什么是客户端程序引用删除的元素（在这种情况下，<code>Planet.Pluto</code>）？ 如果重新编译客户端程序，编译将会失败并在引用前一个星球的行处提供有用的错误消息; 如果无法重新编译客户端，它将在运行时从此行中引发有用的异常。 这是你所希望的最好的行为，远远好于你用int枚举模式得到的结果。</p><p>一些与枚举常量相关的行为只需要在定义枚举的类或包中使用。 这些行为最好以私有或包级私有方式实现。 然后每个常量携带一个隐藏的行为集合，允许包含枚举的类或包在与常量一起呈现时作出适当的反应。 与其他类一样，除非你有一个令人信服的理由将枚举方法暴露给它的客户端，否则将其声明为私有的，如果需要的话将其声明为包级私有（条目 15）。</p><p>如果一个枚举是广泛使用的，它应该是一个顶级类; 如果它的使用与特定的顶级类绑定，它应该是该顶级类的成员类（条目 24）。 例如，<code>java.math.RoundingMode</code>枚举表示小数部分的舍入模式。 <code>BigDecimal</code>类使用了这些舍入模式，但它们提供了一种有用的抽象，它并不与<code>BigDecimal</code>有根本的联系。 通过将<code>RoundingMode</code>设置为顶层枚举，类库设计人员鼓励任何需要舍入模式的程序员重用此枚举，从而提高跨API的一致性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// Enum type that switches on its own value - questionable</span><br><span class="line">public enum Operation &#123;</span><br><span class="line">    PLUS, MINUS, TIMES, DIVIDE;</span><br><span class="line"></span><br><span class="line">    // Do the arithmetic operation represented by this constant</span><br><span class="line">    public double apply(double x, double y) &#123;</span><br><span class="line">        switch(this) &#123;</span><br><span class="line">            case PLUS:   return x + y;</span><br><span class="line">            case MINUS:  return x - y;</span><br><span class="line">            case TIMES:  return x * y;</span><br><span class="line">            case DIVIDE: return x / y;</span><br><span class="line">        &#125;</span><br><span class="line">        throw new AssertionError(&quot;Unknown op: &quot; + this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此代码有效，但不是很漂亮。 如果没有<code>throw</code>语句，就不能编译，因为该方法的结束在技术上是可达到的，尽管它永远不会被达到[JLS，14.21]。 更糟的是，代码很脆弱。 如果添加新的枚举常量，但忘记向switch语句添加相应的条件，枚举仍然会编译，但在尝试应用新操作时，它将在运行时失败。</p><p>幸运的是，有一种更好的方法可以将不同的行为与每个枚举常量关联起来：在枚举类型中声明一个抽象的<code>apply</code>方法，并用常量特定的类主体中的每个常量的具体方法重写它。 这种方法被称为特定于常量（constant-specific）的方法实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// Enum type with constant-specific method implementations</span><br><span class="line">public enum Operation &#123;</span><br><span class="line">  PLUS  &#123;public double apply(double x, double y)&#123;return x + y;&#125;&#125;,</span><br><span class="line">  MINUS &#123;public double apply(double x, double y)&#123;return x - y;&#125;&#125;,</span><br><span class="line">  TIMES &#123;public double apply(double x, double y)&#123;return x * y;&#125;&#125;,</span><br><span class="line">  DIVIDE&#123;public double apply(double x, double y)&#123;return x / y;&#125;&#125;;</span><br><span class="line"></span><br><span class="line">  public abstract double apply(double x, double y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果向第二个版本的操作添加新的常量，则不太可能会忘记提供<code>apply</code>方法，因为该方法紧跟在每个常量声明之后。 万一忘记了，编译器会提醒你，因为枚举类型中的抽象方法必须被所有常量中的具体方法重写。</p><p>特定于常量的方法实现可以与特定于常量的数据结合使用。 例如，以下是<code>Operation</code>的一个版本，它重写<code>toString</code>方法以返回通常与该操作关联的符号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// Enum type with constant-specific class bodies and data</span><br><span class="line">public enum Operation &#123;</span><br><span class="line">    PLUS(&quot;+&quot;) &#123;</span><br><span class="line">        public double apply(double x, double y) &#123; return x + y; &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    MINUS(&quot;-&quot;) &#123;</span><br><span class="line">        public double apply(double x, double y) &#123; return x - y; &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    TIMES(&quot;*&quot;) &#123;</span><br><span class="line">        public double apply(double x, double y) &#123; return x * y; &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    DIVIDE(&quot;/&quot;) &#123;</span><br><span class="line">        public double apply(double x, double y) &#123; return x / y; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private final String symbol;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Operation(String symbol) &#123; this.symbol = symbol; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override public String toString() &#123; return symbol; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public abstract double apply(double x, double y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显示的<code>toString</code>实现可以很容易地打印算术表达式，正如这个小程序所展示的那样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    double x = Double.parseDouble(args[0]);</span><br><span class="line">    double y = Double.parseDouble(args[1]);</span><br><span class="line">    for (Operation op : Operation.values())</span><br><span class="line">        System.out.printf(&quot;%f %s %f = %f%n&quot;,</span><br><span class="line">                          x, op, y, op.apply(x, y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以2和4作为命令行参数运行此程序会生成以下输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2.000000 + 4.000000 = 6.000000</span><br><span class="line">2.000000 - 4.000000 = -2.000000</span><br><span class="line">2.000000 * 4.000000 = 8.000000</span><br><span class="line">2.000000 / 4.000000 = 0.500000</span><br></pre></td></tr></table></figure><p>枚举类型具有自动生成的<code>valueOf(String)</code>方法，该方法将常量名称转换为常量本身。 如果在枚举类型中重写<code>toString</code>方法，请考虑编写<code>fromString</code>方法将自定义字符串表示法转换回相应的枚举类型。 下面的代码（类型名称被适当地改变）将对任何枚举都有效，只要每个常量具有唯一的字符串表示形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// Implementing a fromString method on an enum type</span><br><span class="line">private static final Map&lt;String, Operation&gt; stringToEnum =</span><br><span class="line">        Stream.of(values()).collect(</span><br><span class="line">            toMap(Object::toString, e -&gt; e));</span><br><span class="line"></span><br><span class="line">// Returns Operation for string, if any</span><br><span class="line">public static Optional&lt;Operation&gt; fromString(String symbol) &#123;</span><br><span class="line">    return Optional.ofNullable(stringToEnum.get(symbol));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，<code>Operation</code>枚举常量被放在<code>stringToEnum</code>的map中，它来自于创建枚举常量后运行的静态属性初始化。前面的代码在<code>values()</code>方法返回的数组上使用流（第7章）；在Java 8之前，我们创建一个空的<code>hashMap</code>并遍历值数组，将字符串到枚举映射插入到map中，如果愿意，仍然可以这样做。但请注意，尝试让每个常量都将自己放入来自其构造方法的map中不起作用。这会导致编译错误，这是好事，因为如果它是合法的，它会在运行时导致<code>NullPointerException</code>。除了编译时常量属性（条目 34）之外，枚举构造方法不允许访问枚举的静态属性。此限制是必需的，因为静态属性在枚举构造方法运行时尚未初始化。这种限制的一个特例是枚举常量不能从构造方法中相互访问。</p><p>另请注意，<code>fromString</code>方法返回一个<code>Optional&lt;String&gt;</code>。 这允许该方法指示传入的字符串不代表有效的操作，并且强制客户端面对这种可能性（条目 55）。</p><p>特定于常量的方法实现的一个缺点是它们使得难以在枚举常量之间共享代码。 例如，考虑一个代表工资包中的工作天数的枚举。 该枚举有一个方法，根据工人的基本工资（每小时）和当天工作的分钟数计算当天工人的工资。 在五个工作日内，任何超过正常工作时间的工作都会产生加班费; 在两个周末的日子里，所有工作都会产生加班费。 使用switch语句，通过将多个<code>case</code>标签应用于两个代码片段中的每一个，可以轻松完成此计算：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// Enum that switches on its value to share code - questionable</span><br><span class="line">enum PayrollDay &#123;</span><br><span class="line">    MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY,</span><br><span class="line">    SATURDAY, SUNDAY;</span><br><span class="line"></span><br><span class="line">    private static final int MINS_PER_SHIFT = 8 * 60;</span><br><span class="line"></span><br><span class="line">    int pay(int minutesWorked, int payRate) &#123;</span><br><span class="line">        int basePay = minutesWorked * payRate;</span><br><span class="line"></span><br><span class="line">        int overtimePay;</span><br><span class="line">        switch(this) &#123;</span><br><span class="line">          case SATURDAY: case SUNDAY: // Weekend</span><br><span class="line">            overtimePay = basePay / 2;</span><br><span class="line">            break;</span><br><span class="line">          default: // Weekday</span><br><span class="line">            overtimePay = minutesWorked &lt;= MINS_PER_SHIFT ?</span><br><span class="line">              0 : (minutesWorked - MINS_PER_SHIFT) * payRate / 2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return basePay + overtimePay;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码无可否认是简洁的，但从维护的角度来看是危险的。 假设你给枚举添加了一个元素，可能是一个特殊的值来表示一个假期，但忘记在switch语句中添加一个相应的case条件。 该程序仍然会编译，但付费方法会默默地为工作日支付相同数量的休假日，与普通工作日相同。</p><p>要使用特定于常量的方法实现安全地执行工资计算，必须为每个常量重复加班工资计算，或将计算移至两个辅助方法，一个用于工作日，另一个用于周末，并调用适当的辅助方法来自每个常量。 这两种方法都会产生相当数量的样板代码，大大降低了可读性并增加了出错机会。</p><p>通过使用执行加班计算的具体方法替换<code>PayrollDay</code>上的抽象<code>overtimePa</code>y方法，可以减少样板。 那么只有周末的日子必须重写该方法。 但是，这与switch语句具有相同的缺点：如果在不重写<code>overtimePay</code>方法的情况下添加另一天，则会默默继承周日计算方式。</p><p>你真正想要的是每次添加枚举常量时被迫选择加班费策略。 幸运的是，有一个很好的方法来实现这一点。 这个想法是将加班费计算移入私有嵌套枚举中，并将此策略枚举的实例传递给<code>PayrollDay</code>枚举的构造方法。 然后，<code>PayrollDay</code>枚举将加班工资计算委托给策略枚举，从而无需在<code>PayrollDay</code>中实现switch语句或特定于常量的方法实现。 虽然这种模式不如switch语句简洁，但它更安全，更灵活：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">// The strategy enum pattern</span><br><span class="line">enum PayrollDay &#123;</span><br><span class="line">    MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY,</span><br><span class="line">    SATURDAY(PayType.WEEKEND), SUNDAY(PayType.WEEKEND);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private final PayType payType;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    PayrollDay(PayType payType) &#123; this.payType = payType; &#125;</span><br><span class="line">    PayrollDay() &#123; this(PayType.WEEKDAY); &#125;  // Default</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    int pay(int minutesWorked, int payRate) &#123;</span><br><span class="line">        return payType.pay(minutesWorked, payRate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // The strategy enum type</span><br><span class="line">    private enum PayType &#123;</span><br><span class="line">        WEEKDAY &#123;</span><br><span class="line">            int overtimePay(int minsWorked, int payRate) &#123;</span><br><span class="line">                return minsWorked &lt;= MINS_PER_SHIFT ? 0 :</span><br><span class="line">                  (minsWorked - MINS_PER_SHIFT) * payRate / 2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        WEEKEND &#123;</span><br><span class="line">            int overtimePay(int minsWorked, int payRate) &#123;</span><br><span class="line">                return minsWorked * payRate / 2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        abstract int overtimePay(int mins, int payRate);</span><br><span class="line">        private static final int MINS_PER_SHIFT = 8 * 60;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        int pay(int minsWorked, int payRate) &#123;</span><br><span class="line">            int basePay = minsWorked * payRate;</span><br><span class="line">            return basePay + overtimePay(minsWorked, payRate);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果对枚举的switch语句不是实现常量特定行为的好选择，那么它们有什么好处呢?枚举类型的switch有利于用常量特定的行为增加枚举类型。例如，假设<code>Operation</code>枚举不在你的控制之下，你希望它有一个实例方法来返回每个相反的操作。你可以用以下静态方法模拟效果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// Switch on an enum to simulate a missing method</span><br><span class="line">public static Operation inverse(Operation op) &#123;</span><br><span class="line">    switch(op) &#123;</span><br><span class="line">        case PLUS:   return Operation.MINUS;</span><br><span class="line">        case MINUS:  return Operation.PLUS;</span><br><span class="line">        case TIMES:  return Operation.DIVIDE;</span><br><span class="line">        case DIVIDE: return Operation.TIMES;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        default:  throw new AssertionError(&quot;Unknown op: &quot; + op);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果某个方法不属于枚举类型，则还应该在你控制的枚举类型上使用此技术。 该方法可能需要用于某些用途，但通常不足以用于列入枚举类型。</p><p>一般而言，枚举通常在性能上与int常数相当。 枚举的一个小小的性能缺点是加载和初始化枚举类型存在空间和时间成本，但在实践中不太可能引人注意。</p><p>那么你应该什么时候使用枚举呢？ 任何时候使用枚举都需要一组常量，这些常量的成员在编译时已知。 当然，这包括“天然枚举类型”，如行星，星期几和棋子。 但是它也包含了其它你已经知道编译时所有可能值的集合，例如菜单上的选项，操作代码和命令行标志。<strong> 一个枚举类型中的常量集不需要一直保持不变</strong>。 枚举功能是专门设计用于允许二进制兼容的枚举类型的演变。</p><p>总之，枚举类型优于int常量的优点是令人信服的。 枚举更具可读性，更安全，更强大。 许多枚举不需要显式构造方法或成员，但其他人则可以通过将数据与每个常量关联并提供行为受此数据影响的方法而受益。 使用单一方法关联多个行为可以减少枚举。 在这种相对罕见的情况下，更喜欢使用常量特定的方法来枚举自己的值。 如果一些（但不是全部）枚举常量共享共同行为，请考虑策略枚举模式。</p><h2 id="35-使用实例属性替代序数"><a href="#35-使用实例属性替代序数" class="headerlink" title="35. 使用实例属性替代序数"></a>35. 使用实例属性替代序数</h2><p>许多枚举通常与单个int值关联。所有枚举都有一个<code>ordinal</code>方法，它返回每个枚举常量类型的数值位置。你可能想从序数中派生一个关联的int值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// Abuse of ordinal to derive an associated value - DON&apos;T DO THIS</span><br><span class="line"></span><br><span class="line">public enum Ensemble &#123;</span><br><span class="line"></span><br><span class="line">    SOLO,   DUET,   TRIO, QUARTET, QUINTET,</span><br><span class="line"></span><br><span class="line">    SEXTET, SEPTET, OCTET, NONET,  DECTET;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public int numberOfMusicians() &#123; return ordinal() + 1; &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然这个枚举能正常工作，但对于维护来说则是一场噩梦。如果常量被重新排序，<code>numberOfMusicians</code>方法将会中断。 如果你想添加一个与你已经使用的int值相关的第二个枚举常量，则没有那么好运了。 例如，为双四重奏（double quartet）添加一个常量可能会很好，它就像八重奏一样，由8位演奏家组成，但是没有办法做到这一点。</p><p>此外，如果没有给所有这些int值添加常量，也不能为某个int值添加一个常量。例如，假设你想要添加一个常量，表示一个由12位演奏家组成的三重四重奏（triple quartet）。对于由11个演奏家组成的合奏曲，并没有标准的术语，因此你不得不为未使用的int值（11）添加一个虚拟常量（dummy constant）。最多看起来就是有些不好看。如果许多int值是未使用的，则是不切实际的。</p><p>幸运的是，这些问题有一个简单的解决方案。 <strong>永远不要从枚举的序号中得出与它相关的值; 请将其保存在实例属性中</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public enum Ensemble &#123;</span><br><span class="line"></span><br><span class="line">    SOLO(1), DUET(2), TRIO(3), QUARTET(4), QUINTET(5),</span><br><span class="line"></span><br><span class="line">    SEXTET(6), SEPTET(7), OCTET(8), DOUBLE_QUARTET(8),</span><br><span class="line"></span><br><span class="line">    NONET(9), DECTET(10), TRIPLE_QUARTET(12);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private final int numberOfMusicians;</span><br><span class="line"></span><br><span class="line">    Ensemble(int size) &#123; this.numberOfMusicians = size; &#125;</span><br><span class="line"></span><br><span class="line">    public int numberOfMusicians() &#123; return numberOfMusicians; &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>枚举规范对此<code>ordinal</code>方法说道：“大多数程序员对这种方法没有用处。 它被设计用于基于枚举的通用数据结构，如<code>EnumSet</code>和<code>EnumMap</code>。“除非你在编写这样数据结构的代码，否则最好避免使用<code>ordinal</code>方法。</p><h2 id="36-使用EnumSet替代位属性"><a href="#36-使用EnumSet替代位属性" class="headerlink" title="36. 使用EnumSet替代位属性"></a>36. 使用EnumSet替代位属性</h2><p>如果枚举类型的元素主要用于集合中，一般来说使用int枚举模式（条目 34），下面将2的不同倍数赋值给每个常量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// Bit field enumeration constants - OBSOLETE!</span><br><span class="line">public class Text &#123;</span><br><span class="line">    public static final int STYLE_BOLD          = 1 &lt;&lt; 0;  // 1</span><br><span class="line">    public static final int STYLE_ITALIC        = 1 &lt;&lt; 1;  // 2</span><br><span class="line">    public static final int STYLE_UNDERLINE     = 1 &lt;&lt; 2;  // 4</span><br><span class="line">    public static final int STYLE_STRIKETHROUGH = 1 &lt;&lt; 3;  // 8</span><br><span class="line"></span><br><span class="line">    // Parameter is bitwise OR of zero or more STYLE_ constants</span><br><span class="line">    public void applyStyles(int styles) &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种表示方式允许你使用按位或（or）运算将几个常量合并到一个称为位属性（bit field）的集合中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">text.applyStyles(STYLE_BOLD | STYLE_ITALIC);</span><br></pre></td></tr></table></figure><p>位属性表示还允许你使用按位算术有效地执行集合运算，如并集和交集。 但是位属性具有int枚举常量等的所有缺点。 当打印为数字时，解释位属性比简单的int枚举常量更难理解。 没有简单的方法遍历所有由位属性表示的元素。 最后，必须预测在编写API时需要的最大位数，并相应地为位属性（通常为int或long）选择一种类型。 一旦你选择了一个类型，你就不能超过它的宽度（32或64位）而不改变API。</p><p>一些程序员使用枚举优于int常量，当他们需要传递常量集合时仍然使用位属性。 没有理由这样做，因为存在更好的选择。 java.util包提供了<code>EnumSet</code>类来有效地表示从单个枚举类型中提取的值集合。 这个类实现了Set接口，提供了所有其他Set实现的丰富性，类型安全性和互操作性。 但是在内部，每个EnumSet都表示为一个位矢量（bit vector）。 如果底层的枚举类型有64个或更少的元素，并且大多数情况下，整个<code>EnumSet</code>用单个long表示，所以它的性能与位属性的性能相当。 批量操作（如removeAll和retainAll）是使用按位算术实现的，就像你为位属性手动操作一样。 但是完全避免了手动位混乱的丑陋和错误倾向：<code>EnumSet</code>为你做了很大的努力。</p><p>下面是前一个使用枚举和枚举集合替代位属性的示例。 它更短，更清晰，更安全：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// EnumSet - a modern replacement for bit fields</span><br><span class="line">public class Text &#123;</span><br><span class="line">    public enum Style &#123; BOLD, ITALIC, UNDERLINE, STRIKETHROUGH &#125;</span><br><span class="line"></span><br><span class="line">    // Any Set could be passed in, but EnumSet is clearly best</span><br><span class="line">    public void applyStyles(Set&lt;Style&gt; styles) &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是将<code>EnumSet</code>实例传递给applyStyles方法的客户端代码。 <code>EnumSet</code>类提供了一组丰富的静态工厂，可以轻松创建集合，其中一个代码如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">text.applyStyles(EnumSet.of(Style.BOLD, Style.ITALIC));</span><br></pre></td></tr></table></figure><p>请注意，<code>applyStyles</code>方法采用<code>Set&lt;Style&gt;</code>而不是<code>EnumSet&lt;Style&gt;</code>参数。 尽管所有客户端都可能会将<code>EnumSet</code>传递给该方法，但接受接口类型而不是实现类型通常是很好的做法（条目 64）。 这允许一个不寻常的客户端通过其他Set实现的可能性。</p><p>总之，<strong>仅仅因为枚举类型将被用于集合中，所以没有理由用位属性来表示它</strong>。 <code>EnumSet</code>类将位属性的简洁性和性能与条目 34中所述的枚举类型的所有优点相结合。<code>EnumSet</code>的一个真正缺点是，它不像Java 9那样创建一个不可变的<code>EnumSet</code>，但是在即将发布的版本中可能会得到补救。 同时，你可以用<code>Collections.unmodifiableSet</code>封装一个<code>EnumSet</code>，但是简洁性和性能会受到影响。</p><h2 id="37-使用EnumMap替代序数索引"><a href="#37-使用EnumMap替代序数索引" class="headerlink" title="37. 使用EnumMap替代序数索引"></a>37. 使用EnumMap替代序数索引</h2><p>有时可能会看到使用<code>ordinal</code>方法（条目 35）来索引到数组或列表的代码。 例如，考虑一下这个简单的类来代表一种植物：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Plant &#123;</span><br><span class="line">    enum LifeCycle &#123; ANNUAL, PERENNIAL, BIENNIAL &#125;</span><br><span class="line">    final String name;</span><br><span class="line">    final LifeCycle lifeCycle;</span><br><span class="line"></span><br><span class="line">    Plant(String name, LifeCycle lifeCycle) &#123;</span><br><span class="line">        [this.name](http://this.name) = name;</span><br><span class="line">        this.lifeCycle = lifeCycle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override public String toString() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在假设你有一组植物代表一个花园，想要列出这些由生命周期组织的植物(一年生，多年生，或双年生)。为此，需要构建三个集合，每个生命周期作为一个，并遍历整个花园，将每个植物放置在适当的集合中。一些程序员可以通过将这些集合放入一个由生命周期序数索引的数组中来实现这一点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// Using ordinal() to index into an array - DON&apos;T DO THIS!</span><br><span class="line"></span><br><span class="line">Set&lt;Plant&gt;[] plantsByLifeCycle =</span><br><span class="line"></span><br><span class="line">    (Set&lt;Plant&gt;[]) new Set[Plant.LifeCycle.values().length];</span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt; plantsByLifeCycle.length; i++)</span><br><span class="line"></span><br><span class="line">    plantsByLifeCycle[i] = new HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">for (Plant p : garden)</span><br><span class="line"></span><br><span class="line">    plantsByLifeCycle[p.lifeCycle.ordinal()].add(p);</span><br><span class="line"></span><br><span class="line">// Print the results</span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt; plantsByLifeCycle.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">    System.out.printf(&quot;%s: %s%n&quot;,</span><br><span class="line"></span><br><span class="line">        Plant.LifeCycle.values()[i], plantsByLifeCycle[i]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法是有效的，但充满了问题。 因为数组不兼容泛型（条目 28），程序需要一个未经检查的转换，并且不会干净地编译。 由于该数组不知道索引代表什么，因此必须手动标记索引输出。 但是这种技术最严重的问题是，当你访问一个由枚举序数索引的数组时，你有责任使用正确的int值; int不提供枚举的类型安全性。 如果你使用了错误的值，程序会默默地做错误的事情，如果你幸运的话，抛出一个<code>ArrayIndexOutOfBoundsException</code>异常。</p><p>有一个更好的方法来达到同样的效果。 该数组有效地用作从枚举到值的映射，因此不妨使用Map。 更具体地说，有一个非常快速的Map实现，设计用于枚举键，称为<code>java.util.EnumMap</code>。 下面是当程序重写为使用<code>EnumMap</code>时的样子：</p><p><code>`</code><br>// Using an EnumMap to associate data with an enum</p><p>Map&lt;Plant.LifeCycle, Set<plant>&gt;  plantsByLifeCycle =</plant></p><pre><code>new EnumMap&lt;&gt;(Plant.LifeCycle.class);</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Effective-Java-3rd&quot;&gt;&lt;a href=&quot;#Effective-Java-3rd&quot; class=&quot;headerlink&quot; title=&quot;Effective Java 3rd&quot;&gt;&lt;/a&gt;Effective Java 3rd&lt;/h1&gt;&lt;p&gt;[TOC]&lt;
      
    
    </summary>
    
      <category term="java" scheme="http://luxiangdong.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java8极简手册-01</title>
    <link href="http://luxiangdong.com/2018/05/04/java8guide01/"/>
    <id>http://luxiangdong.com/2018/05/04/java8guide01/</id>
    <published>2018-05-03T16:09:48.000Z</published>
    <updated>2018-05-08T06:00:22.805Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>为忙碌的程序员归纳总结和翻译的Java8极简教程，有助于快速了解Java8的新特性。</p></blockquote><h2 id="接口的默认方法（Default-Methods-for-Interfaces）"><a href="#接口的默认方法（Default-Methods-for-Interfaces）" class="headerlink" title="接口的默认方法（Default Methods for Interfaces）"></a>接口的默认方法（Default Methods for Interfaces）</h2><p>Java 8允许我们利用<code>default</code>关键字在接口中定义非抽象的方法实现，这个功能也被称为虚拟扩展方法( <a href="http://stackoverflow.com/a/24102730" target="_blank" rel="noopener">virtual extension methods</a>)。</p><p>以下是第一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Formula</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">double</span> <span class="title">sqrt</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.sqrt(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了抽象方法（可以理解为无具体实现的方法） <code>calculate</code>之外，接口 <code>Formula</code> 里面还定了一个默认方法 <code>sqrt</code>。在具体的实现类里面，抽象方法 <code>calculate</code>需要被重新实现，而默认方法<code>sqrt</code>则可以被实现类直接使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Formula formula = <span class="keyword">new</span> Formula() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sqrt(a * <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">formula.calculate(<span class="number">100</span>);     <span class="comment">// 100.0</span></span><br><span class="line">formula.sqrt(<span class="number">16</span>);           <span class="comment">// 4.0</span></span><br></pre></td></tr></table></figure><p>该公式是作为匿名对象实现的，代码或许过于冗长：6行代码实现的仅仅是一个简单的计算 <code>sqrt(a * 100)</code>，下一节我们将看到在Java8中是怎么样更优雅地实现这样的单方法对象的。</p><h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p>让我们从一个简单的例子来说明如何在以前版本的Java中对字符串列表进行排序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; names = Arrays.asList(<span class="string">"peter"</span>, <span class="string">"anna"</span>, <span class="string">"mike"</span>, <span class="string">"xenia"</span>);</span><br><span class="line"></span><br><span class="line">Collections.sort(names, <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b.compareTo(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>静态方法<code>Collections.sort</code>接受一个list和一个comparator，以便对给定list的元素进行排序。 很多时候我们会发现需要先创建匿名comparator，并将它们传递给排序方法。</p><p>从Java 8开始，我们不需要整天创建匿名对象了，而是可以使用更短的语法 ：<strong>lambda expressions</strong>（lambda表达式）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(names, (String a, String b) -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> b.compareTo(a);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>你可以看见，代码更精简，而且更具可读性了（注：可读性是对于熟悉lambda的开发者来说的），而且，我们还可以把代码写的更精简:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(names, (String a, String b) -&gt; b.compareTo(a));</span><br></pre></td></tr></table></figure><p>对于一行方法体，您可以跳过大括号<code>{}</code>和<code>return</code>关键字， 所以还可以把它变得更短：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">names.sort((a, b) -&gt; b.compareTo(a));</span><br></pre></td></tr></table></figure><p>列表现在有了一个排序方法。 此外，java编译器会知道参数类型，所以你可以跳过它们。 让我们深入了解如何在更多的场景中使用lambda表达式。</p><h2 id="函数式接口（Functional-Interfaces）"><a href="#函数式接口（Functional-Interfaces）" class="headerlink" title="函数式接口（Functional Interfaces）"></a>函数式接口（Functional Interfaces）</h2><p>Lambda表达式如何匹配识别Java的类型系统？</p><p>每个lambda对应于由接口指定的给定类型，一个所谓的<em>函数式接口</em>必须包含<strong>一个精确的抽象方法声明</strong>，该类型的每个lambda表达式都将与此抽象方法匹配。 由于默认方法不是抽象的，你可以自由地将默认方法添加到你的函数式接口。</p><p>只要接口满足只包含一个抽象方法的约定，我们就可以使用任意接口作为lambda表达式。 为了确保你的接口符合要求，你应该添加<code>@FunctionalInterface</code>注解。 编译器知道这个注释，并会在你尝试向接口添加第二个抽象方法声明后立即抛出编译器错误。</p><p>例子:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Converter</span>&lt;<span class="title">F</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">convert</span><span class="params">(F from)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Converter&lt;String, Integer&gt; converter = (from) -&gt; Integer.valueOf(from);</span><br><span class="line">Integer converted = converter.convert(<span class="string">"123"</span>);</span><br><span class="line">System.out.println(converted);    <span class="comment">// 123</span></span><br></pre></td></tr></table></figure><p>需要注意的是，如果<code>@FunctionalInterface</code>注释被省略掉，代码也是有效的。</p><h2 id="方法和构造器引用"><a href="#方法和构造器引用" class="headerlink" title="方法和构造器引用"></a>方法和构造器引用</h2><p>The above example code can be further simplified by utilizing static method references:</p><p>上面的示例代码可以通过使用静态方法引用进一步简化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Converter&lt;String, Integer&gt; converter = Integer::valueOf;</span><br><span class="line">Integer converted = converter.convert(<span class="string">"123"</span>);</span><br><span class="line">System.out.println(converted);   <span class="comment">// 123</span></span><br></pre></td></tr></table></figure><p>Java 8让您能够通过<code>::</code>关键字传递方法或构造函数的引用。 上面的例子展示了如何引用一个静态方法。 但是我们也可以引用对象的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Something</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">startsWith</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(s.charAt(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Something something = <span class="keyword">new</span> Something();</span><br><span class="line">Converter&lt;String, String&gt; converter = something::startsWith;</span><br><span class="line">String converted = converter.convert(<span class="string">"Java"</span>);</span><br><span class="line">System.out.println(converted);    <span class="comment">// "J"</span></span><br></pre></td></tr></table></figure><p>Let’s see how the <code>::</code> keyword works for constructors. First we define an example class with different constructors:</p><p>我们来看看<code>::</code>关键字如何用于构造函数，首先我们用不同的构造函数定义一个示例类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String firstName;</span><br><span class="line">    String lastName;</span><br><span class="line"></span><br><span class="line">    Person() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    Person(String firstName, String lastName) &#123;</span><br><span class="line">        <span class="keyword">this</span>.firstName = firstName;</span><br><span class="line">        <span class="keyword">this</span>.lastName = lastName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，我们指定一个用于创建新的人员的<code>Person</code>工厂接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">PersonFactory</span>&lt;<span class="title">P</span> <span class="keyword">extends</span> <span class="title">Person</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">P <span class="title">create</span><span class="params">(String firstName, String lastName)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们不是手动实现工厂，而是通过构造函数引用将所有东西粘合在一起：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PersonFactory&lt;Person&gt; personFactory = Person::<span class="keyword">new</span>;</span><br><span class="line">Person person = personFactory.create(<span class="string">"Peter"</span>, <span class="string">"Parker"</span>);</span><br></pre></td></tr></table></figure><p>我们通过<code>Person :: new</code>创建一个对Person构造函数的引用。 Java编译器通过匹配<code>PersonFactory.create</code>的参数和类型自动选择正确的构造函数。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;为忙碌的程序员归纳总结和翻译的Java8极简教程，有助于快速了解Java8的新特性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;接口的默认方法（Default-Methods-for-Interfaces）&quot;&gt;&lt;a href=&quot;#接口的默
      
    
    </summary>
    
      <category term="java" scheme="http://luxiangdong.com/categories/java/"/>
    
    
      <category term="java" scheme="http://luxiangdong.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Apache Cassandra手册中文版01</title>
    <link href="http://luxiangdong.com/2018/05/03/Cassandra-CN-01/"/>
    <id>http://luxiangdong.com/2018/05/03/Cassandra-CN-01/</id>
    <published>2018-05-03T09:44:56.000Z</published>
    <updated>2018-05-03T09:49:44.082Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于本文档"><a href="#关于本文档" class="headerlink" title="关于本文档"></a>关于本文档</h2><p>欢迎来到DataStax提供的Cassandra文档。 为确保您在使用本文档时获得最佳体验，请花点时间查看使用DataStax文档的提示。</p><p>着陆页提供有关受支持平台，产品兼容性，规划和测试集群部署，推荐的生产设置，故障排除，第三方软件，更多信息的资源，管理员和开发人员主题以及早期文档的信息。</p><h2 id="Apache-Cassandra概览"><a href="#Apache-Cassandra概览" class="headerlink" title="Apache Cassandra概览"></a>Apache Cassandra概览</h2><p>Apache Cassandra™ 是一个大规模可扩展的开源NoSQL数据库。 Cassandra非常适合跨多个数据中心和云，来管理大量结构化、半结构化和非结构化数据。 Cassandra在许多商用服务器上提供持续可用性、线性可扩展性和操作简单性，而没有单点故障，以及强大的动态数据模型，旨在实现最大的灵活性和快速的响应时间。</p><h2 id="Cassandra如何工作"><a href="#Cassandra如何工作" class="headerlink" title="Cassandra如何工作?"></a>Cassandra如何工作?</h2><p>Cassandra基于可扩展的架构，意味着它能够每秒处理PB级信息和数千个并发用户/操作。</p><table><thead><tr><th><strong>Cassandra是一个分区的行存储数据库</strong></th><th>Cassandra的体系结构允许任何授权用户连接到任何数据中心的任何节点，并使用CQL语言访问数据。为了便于使用，CQL使用了与SQL相似的语法。与Cassandra互动的最基本的方式是使用CQL shell，cqlsh。使用cqlsh，您可以创建键空间和表、插入和查询表，以及更多。Cassandra的这一版本与Cassandra 2.2和后来的CQL合作。如果您喜欢图形化工具，您可以使用数据中心DevCenter。对于生产，数据中心提供了一个数字驱动程序，以便CQL语句可以从客户机传递到集群和返回。</th></tr></thead><tbody><tr><td><strong>自动化的数据分布</strong></td><td>Cassandra提供了所有参与到环(比如hash链路环)或数据库集群的节点的自动数据分布。由于数据在集群中的所有节点上都是透明的，因此，开发人员或管理员不需要进行编程，也不需要通过代码来跨集群分发数据。</td></tr><tr><td><strong>内置的、可定制的复制</strong></td><td>Cassandra还提供了内置的和可定制的复制，它在节点上存储了冗余的数据副本。这意味着，如果集群中的任何节点宕机，该节点数据的一个或多个副本就可以在集群中的其他计算机上使用。可以将复制配置为跨一个数据中心、多个数据中心和多个云可用区域进行工作。</td></tr><tr><td><strong>供应线性可伸缩性</strong></td><td>Cassandra 提供线性可伸缩性，这意味着通过在网络上添加新的节点可以轻松地添加容量。例如，如果2个节点每秒处理10万个事务，那么4个节点将支持200,000个事务/秒，8个节点将处理40万事务/秒:</td></tr><tr><td></td><td><img src="http://docs.datastax.com/en/cassandra/3.0/cassandra/images/intro_cassandra.png" alt="img"></td></tr></tbody></table><h2 id="Cassandra与关系数据库有什么不同"><a href="#Cassandra与关系数据库有什么不同" class="headerlink" title="Cassandra与关系数据库有什么不同?"></a>Cassandra与关系数据库有什么不同?</h2><p>Cassandra的设计是作为一个分布式数据库来进行点对点的交流。作为最佳实践，查询应该是每个表的一个。数据被规范化以使这成为可能。由于这个原因，表之间的连接的概念并不存在，尽管客户端连接可以在应用程序中使用。</p><h2 id="什么是NoSQL"><a href="#什么是NoSQL" class="headerlink" title="什么是NoSQL?"></a>什么是NoSQL?</h2><p>最常见的翻译是“Not Only SQL”，这意味着使用存储方法不同于关系型数据库或SQL数据库的数据库。有许多不同类型的NoSQL数据库，因此即使是最常用的类型也没有什么用处。现在的数据库管理员必须对多语言友好，这意味着他们必须知道如何使用许多不同的RDBMS和NoSQL数据库。</p><h2 id="什么是CQL"><a href="#什么是CQL" class="headerlink" title="什么是CQL?"></a>什么是CQL?</h2><p><a href="http://docs.datastax.com/en/cql/3.3/cql/cqlIntro.html" target="_blank" rel="noopener">Cassandra Query Language (CQL)</a> 是Cassandra DBMS的主要接口。使用CQL类似于使用SQL(结构化查询语言)。CQL和SQL共享一个由列和行组成的表的抽象概念。与SQL的主要区别在于，Cassandra不支持连接或子查询。相反，Cassandra强调了通过CQL的特性，比如在模式层次上指定的集合和集群。</p><p>CQL是与Cassandra互动的推荐方式。性能和简单的阅读和使用CQL是现代Cassandra对旧Cassandra api的优势。</p><p>详见 <a href="http://docs.datastax.com/en/cql/3.3/index.html" target="_blank" rel="noopener">CQL documentation</a>。</p><h2 id="如何与Cassandra交互"><a href="#如何与Cassandra交互" class="headerlink" title="如何与Cassandra交互?"></a>如何与Cassandra交互?</h2><p>与Cassandra互动的最基本的方式是使用CQL shell，cqlsh。使用cqlsh，您可以创建键空间和表、插入和查询表，以及更多。如果您喜欢图形化工具，您可以使用DevCenter。对于生产，数据中心提供了多种编程语言的驱动程序，因此CQL语句可以从客户端传递到集群和返回。</p><h2 id="如何把数据迁移到Cassnadra或者从Cassandra迁移数据"><a href="#如何把数据迁移到Cassnadra或者从Cassandra迁移数据" class="headerlink" title="如何把数据迁移到Cassnadra或者从Cassandra迁移数据?"></a>如何把数据迁移到Cassnadra或者从Cassandra迁移数据?</h2><p>使用CQL插入命令、CQL复制命令和CSV文件插入数据，或者使用sstableloader。但实际上，您需要考虑客户机应用程序如何查询这些表，并首先进行数据建模。关系和NoSQL之间的范式转换意味着，从RDBMS数据库到Cassandra的数据直接转移将注定失败。</p><h2 id="Cassandra还有什么其他的工具吗"><a href="#Cassandra还有什么其他的工具吗" class="headerlink" title="Cassandra还有什么其他的工具吗?"></a>Cassandra还有什么其他的工具吗?</h2><p>Cassandra自动安装了节点工具，这是Cassandra的一个有用的命令行管理工具。在默认情况下，还安装了一个负载压力和基本基准测试的工具—<code>cassandra-stress</code>。</p><h2 id="需要什么类型的硬件-云环境来运行Cassandra"><a href="#需要什么类型的硬件-云环境来运行Cassandra" class="headerlink" title="需要什么类型的硬件/云环境来运行Cassandra?"></a>需要什么类型的硬件/云环境来运行Cassandra?</h2><p>Cassandra的设计是在普通的商用硬件上运行。在云计算中，Cassandra适应了大多数的公共产品。</p><h2 id="Apache-Cassandra-3-0-新特性"><a href="#Apache-Cassandra-3-0-新特性" class="headerlink" title="Apache Cassandra 3.0 新特性"></a>Apache Cassandra 3.0 新特性</h2><h3 id="Cassandra-3-0-新特性"><a href="#Cassandra-3-0-新特性" class="headerlink" title="Cassandra 3.0 新特性"></a>Cassandra 3.0 新特性</h3><table><thead><tr><th><strong>存储引擎重构</strong></th><th>存储引擎已经被重构了。</th></tr></thead><tbody><tr><td><strong>物化视图</strong></td><td>物化视图处理了自动化的服务器端变性，在基础和视图数据之间保持一致。</td></tr><tr><td><strong>操作的改进</strong></td><td></td></tr><tr><td><strong>将MAX_WINDOW_SIZE_SECONDS添加到DTCS压缩管理</strong></td><td>允许DTCS压缩治理基于最大窗口大小而不是SSTable年龄。</td></tr><tr><td><strong>基于文件的提示存储和改进的重播</strong></td><td>提示现在存储在文件中，并且重播得到改进。</td></tr><tr><td><strong>垃圾收集器切换到 G1</strong></td><td><a href="http://docs.datastax.com/en/cassandra/3.0/cassandra/operations/opsTuneJVM.html" target="_blank" rel="noopener">Default garbage collector</a> is changed from Concurrent-Mark-Sweep (CMS) to G1. G1 performance is better for nodes with heap size of 4GB or greater.</td></tr><tr><td><strong>更改了CREATE TABLE压缩选项的语法</strong></td><td>Made the compression options more consistent for <code>CREATE TABLE</code>.</td></tr><tr><td><strong>添加nodetool命令强制重复阻止批处理日志</strong></td><td>BatchlogManager can force batchlog replay using nodetool.</td></tr><tr><td><strong>基于SSL的Nodetool</strong></td><td>Nodetool can connect using SSL like cqlsh.</td></tr><tr><td><strong>用于提示的nodetool工具选项</strong></td><td>Nodetool options <code>disablehintsfordc</code> and <code>enablehintsfordc</code>added. to selectively disable or enable hinted handoffs for a datacenter.</td></tr><tr><td><strong>nodetool stop</strong></td><td>Nodetool option added to stop compactions.</td></tr><tr><td><strong>其他值得注意的变化</strong></td><td></td></tr><tr><td><strong>需要Java 8</strong></td><td>Java 8 is now required.</td></tr><tr><td><strong>nodetool cfstats和nodetool cfhistograms重命名</strong></td><td>Renamed <code>nodetool cfstats</code> to <code>nodetool tablestats</code>. Renamed <code>nodetool cfhistograms</code> to <code>nodetool tablehistograms</code>.</td></tr><tr><td><strong>抛除Native protocol v1 and v2</strong></td><td>Native protocol v1 and v2 are dropped in Cassandra 3.0.</td></tr><tr><td><strong>DataStax AMI does not install Cassandra 3.0 or 3.x</strong></td><td>您可以在Amazon EC2上安装Cassandra 2.1和更早版本，使用DataSet AMI（Amazon Machine Image），如Cassandra 2.1的AMI文档中所述。要在Amazon EC2上安装Cassandra 3.0及更高版本，请在您的平台上使用受信任的AMI 该平台的安装方法。</td></tr></tbody></table><h1 id="理解架构"><a href="#理解架构" class="headerlink" title="理解架构"></a>理解架构</h1><h2 id="架构简介"><a href="#架构简介" class="headerlink" title="架构简介"></a>架构简介</h2><p>Cassandra旨在处理多个节点之间的大数据工作负载，无单点故障。</p><p>它的架构是基于这样的前提，即<strong>系统和硬件故障允许而且确实会发生</strong>。 Cassandra通过在同簇节点之间采用点对点分布式系统来解决故障问题，数据分布在群集中的所有节点之间。每个节点通过使用点对点Gossip通信协议频繁地跨群集交换关于自身和其他节点的状态信息。每个节点上顺序写入的commit log捕获写入操作以确保数据的持久性。然后将数据编入索引并写入内存结构，称为<code>memtable</code>，类似于回写缓存。每次内存结构都已满时，数据将写入SSTables数据文件中的磁盘。所有写入在整个集群中自动分区和复制。 Cassandra会使用一个名为compaction的过程定期整合SSTables，丢弃哪些已经被标记为遗弃的数据删除。为了确保集群中的所有数据保持一致，采用了各种修复机制。</p><p>Cassandra是一个分区行存储数据库，其中，行被组织成具有所需主键的表。 Cassandra的架构允许任何授权用户连接到任何数据中心的任何节点，并使用CQL语言访问数据。 为了易于使用，CQL使用与SQL类似的语法，并与表数据一起使用。 开发人员可以通过cqlsh，DevCenter访问CQL，并通过驱动程序访问应用程序语言。 通常，群集对于由许多不同的表组成的应用程序具有一个密钥空间。</p><p>客户端读或写请求可以发送到集群中的任何节点。 当客户端连接到具有请求的节点时，该节点用作该特定客户机操作的协调器。 协调器充当客户端应用程序和拥有正在请求的数据的节点之间的代理。 协调器根据集群的配置方式确定环中的哪些节点应该获取请求。</p><h3 id="键结构"><a href="#键结构" class="headerlink" title="键结构"></a>键结构</h3><ul><li><p>节点</p><p>存储数据的地方，这是Cassandra的基本基础设施。</p></li><li><p>数据中心</p><p>一组相关节点。数据中心可以是一个物理数据中心或虚拟数据中心。不同的工作负载应该使用单独的数据中心，无论是物理的还是虚拟的。复制是由数据中心设置的。使用单独的数据中心可以防止Cassandra的事务受到其他工作负载的影响，并将请求保持在较低的等待时间。根据复制因素，可以将数据写入多个数据中心。数据中心永远不能跨越物理位置。</p></li><li><p>集群</p><p>一个集群包含一个或多个数据中心。它可以跨越物理位置。</p></li><li><p>commit log</p><p>所有数据都首先写入提交日志，以保证持久性。在所有的数据都被刷新到s马厩后，它可以被归档、删除或回收。</p></li><li><p>SSTable</p><p>一个排序的字符串表(SSTable)是一个不可变的数据文件，Cassandra定期地写备忘录。SSTables只附加并存储在磁盘上，并为每一个Cassandra表维护。</p></li><li><p>CQL Table</p><p>由表行获取的有序列的集合。一个表由列组成，并有一个主键。</p></li></ul><h3 id="配置Cassandra的关键组件"><a href="#配置Cassandra的关键组件" class="headerlink" title="配置Cassandra的关键组件"></a>配置Cassandra的关键组件</h3><ul><li><a href="http://docs.datastax.com/en/cassandra/3.0/cassandra/architecture/archGossipAbout.html" target="_blank" rel="noopener">Gossip</a> 一个点对点通信协议，用于发现和共享关于Cassandra集群中其他节点的位置和状态信息。当节点重新启动时，每个节点都将在本地持久保存流言信息。</li><li><a href="http://docs.datastax.com/en/cassandra/3.0/cassandra/architecture/archPartitionerAbout.html" target="_blank" rel="noopener">Partitioner</a> 分区程序确定哪个节点将接收到一个数据的第一个副本，以及如何在集群中的其他节点上分发其他副本。每一行数据由主键惟一标识，这可能与它的分区键相同，但也可能包括其他集群列。分区程序是一个哈希函数，它从一行的主键派生一个令牌。分区程序使用令牌值来确定集群中的哪个节点接收该行的副本。<code>Murmur3Partitioner</code>是新Cassandra集群的默认分区策略，在几乎所有的情况下，新的集群都是正确的选择。您必须设置分区，并为每个节点分配一个<code>num_token</code>值。您分配的令牌的数量取决于系统的硬件功能。如果不使用虚拟节点(<code>vnode</code>)，则使用<code>initial_token</code>设置。</li><li><a href="http://docs.datastax.com/en/cassandra/3.0/cassandra/architecture/archDataDistributeReplication.html" target="_blank" rel="noopener">Replication factor</a> 跨集群的副本总数。一个复制因子1表示一个节点上的每一行只有一个副本。复制因子2表示每一行的两个副本，每个副本在一个不同的节点上。所有的副本都同等重要，没有主或主副本。您可以为每个数据中心定义复制因子。通常，您应该将复制策略设置为大于1，但不超过集群中的节点数量。</li><li><a href="http://docs.datastax.com/en/cassandra/3.0/cassandra/architecture/archDataDistributeReplication.html" target="_blank" rel="noopener">Replica placement strategy</a>  Cassandra在多个节点上存储数据(副本)，以确保可靠性和容错。复制策略决定将哪些节点放置在该节点上。数据的第一个副本只是第一个副本;它在任何意义上都不是惟一的。对于大多数部署来说， <a href="http://docs.datastax.com/en/cassandra/3.0/cassandra/architecture/archDataDistributeReplication.html#archDataDistributeReplication__networkToplogyStrategy-ph" target="_blank" rel="noopener">NetworkTopologyStrategy</a>是非常推荐的，因为在未来的扩展需要时，扩展到多个数据中心要容易得多。在创建一个keyspace时，您必须定义副本放置策略和您想要的副本数量。</li><li><a href="http://docs.datastax.com/en/cassandra/3.0/cassandra/architecture/archSnitchesAbout.html" target="_blank" rel="noopener">Snitch</a> Snitch将一组机器定义为数据中心和机架(拓扑)，复制策略用于放置副本。您必须在创建集群时配置一个Snitch。所有的snitches都使用动态的snitch层，它可以监控性能，并选择最佳的读取副本。默认情况下启用它，并建议在大多数部署中使用它。为cassandra中的每个节点配置动态的snitch阈值。yaml配置文件。默认的SimpleSnitch不识别数据中心或机架信息。将它用于单数据中心部署或公共云中的单一区域。生产的GossipingPropertyFileSnitch推荐。它定义了一个节点的数据中心和机架，并使用流言传播这些信息到其他节点。</li><li><a href="http://docs.datastax.com/en/cassandra/3.0/cassandra/configuration/configCassandra_yaml.html" target="_blank" rel="noopener">The cassandra.yaml configuration file</a> 用于设置集群的初始化属性、用于表的缓存参数、调优和资源利用率、超时设置、客户端连接、备份和安全性的主要配置文件。默认情况下，一个节点被配置为存储它管理的数据，存储在该目录中的一个目录中。<code>yaml</code>文件。在生产集群部署中，您可以将提交日志目录从<code>datafile-directory</code>更改为不同的磁盘驱动器。</li><li><a href="http://docs.datastax.com/en/cql/3.3/cql/cql_reference/cqlCreateTable.html#tabProp" target="_blank" rel="noopener">System keyspace table properties</a> 您可以通过编程或使用客户端应用程序，例如CQL，在每个键空间或每个表的基础上设置存储配置属性。</li></ul><h2 id="内部节点通信-gossip"><a href="#内部节点通信-gossip" class="headerlink" title="内部节点通信(gossip)"></a>内部节点通信(gossip)</h2><p>Gossip是一种点对点通信协议，其中节点周期性地交换关于他们自己和关于他们知道的其他节点的状态信息。 Gossip进程每秒运行一次，并与群集中最多三个其他节点交换状态消息。 节点交换有关自己和有关其他节点的关联节点的信息，所以所有节点都快速了解集群中的所有其他节点。Gossip消息具有与之相关联的版本，使得在 gossip交换期间，较旧的信息将被特定节点的最新状态覆盖。</p><p>为了防止gossip通信中的问题，请为群集中的所有节点使用相同的种子节点列表。 这是节点第一次启动时最关键的。 默认情况下，一个节点会记住它在随后的重新启动之间闲置的其他节点。 除了为加入群集的新节点引导gossip进程之外，种子节点的名称除外。 种子节点不是单点故障，在集群操作之外，除了节点的引导之外，它们也不具有任何其他特殊用途。</p><p><strong>注意</strong>：在多个数据中心集群中，包括种子列表中每个数据中心（复制组）的至少一个节点。 建议为每个数据中心指定多个单个种子节点进行容错。 否则，gossip必须在引导节点时与其他数据中心进行通信。由于增加了维护和减少了gossip性能，因此不推荐使用每个节点的种子节点。 gossip优化并不重要，但<strong>建议使用小型种子列表（每个数据中心约三个节点）</strong>。</p><h3 id="故障检测和恢复"><a href="#故障检测和恢复" class="headerlink" title="故障检测和恢复"></a>故障检测和恢复</h3><p>故障检测是一种用于从gossip状态和历史记录中，判断系统中的另一个节点关闭或已经恢复的方法。 Cassandra使用此信息避免将客户端请求尽可能地路由到不可达节点。 （Cassandra也可以通过<code>dynamic snitch</code>避免路由请求到活着的节点，但性能不佳。）</p><p>Gossip负责处理从其他节点直接跟踪状态（节点直接与其通话）和间接（节点在二手，三手等上进行通信）跟踪状态。 Cassandra使用权责发生制检查机制来计算一个考虑到网络性能，工作负载和历史条件的每个节点的阈值，而不是使用固定的阈值来标记故障节点。在gossip交流期间，每个节点都保持了来自集群中其他节点的gossip消息到达时间的滑动窗口。配置<code>phi_convict_threshold</code>属性调整故障检测器的灵敏度。较低的值增加了无响应节点被标记为关闭的可能性，而较高的值会降低导致节点故障的瞬态故障的可能性。在大多数情况下使用默认值，但是对于Amazon EC2（由于频繁发生的网络拥塞）而将其增加到10或12。在不稳定的网络环境（如EC2有时），将值提高到10或12有助于防止虚假故障。不推荐值高于12，低于5的值。</p><p>节点故障可能是由各种原因造成的，比如硬件故障和网络中断。节点中断通常是短暂的，但可以持续很长一段时间。因为节点中断很少表示永久离开集群，所以它不会自动导致从环上删除节点。其他节点将定期尝试重新建立与失败节点的联系，以确定它们是否恢复了。为了永久更改集群中的节点成员，管理员必须使用nodetool实用程序显式地添加或删除一个Cassandra集群中的节点。</p><p>当一个节点在停机后重新上线，它可能会错过它所维护的副本数据的写入。<code>Repair mechanisms</code>的存在是为了恢复丢失的数据，比如提示的手动修复和<code>nodetool repair</code>的手工修复。中断的长度将决定使用哪个修复机制来使数据保持一致。</p><h2 id="数据分发与复制"><a href="#数据分发与复制" class="headerlink" title="数据分发与复制"></a>数据分发与复制</h2><p>在Cassandra内部，数据分发和复制都在一起。数据由表组织，由主键标识，该键确定数据存储在哪个节点上。副本是行的副本。当第一次写入数据时，它也被称为副本。</p><p>影响复制的因素包括:</p><ul><li><a href="http://docs.datastax.com/en/cassandra/3.0/cassandra/architecture/archDataDistributeVnodesUsing.html" target="_blank" rel="noopener">Virtual nodes</a>: 将数据所有权分配给物理机器.</li><li><a href="http://docs.datastax.com/en/cassandra/3.0/cassandra/architecture/archPartitionerAbout.html" target="_blank" rel="noopener">Partitioner</a>: 在集群中给数据分区.</li><li><a href="http://docs.datastax.com/en/cassandra/3.0/cassandra/architecture/archDataDistributeReplication.html" target="_blank" rel="noopener">Replication strategy</a>: 确定每行数据的副本.</li><li><a href="http://docs.datastax.com/en/cassandra/3.0/cassandra/architecture/archSnitchesAbout.html" target="_blank" rel="noopener">Snitch</a>: 定义复制策略用于放置副本的拓扑信息.</li></ul><h3 id="Consistent-hashing-一致性哈希"><a href="#Consistent-hashing-一致性哈希" class="headerlink" title="Consistent hashing 一致性哈希"></a>Consistent hashing 一致性哈希</h3><p>一致性hash允许跨集群的数据分布，以便添加或删除节点时，重组能最小化。一致性hash分区数据基于分区键。(<em>有关分区键和主键的说明，请参阅Cassandra 2.2及更高版本的CQL中的数据建模示例。</em>)</p><p>例如, 有以下数据:</p><table><thead><tr><th>name</th><th>age</th><th>car</th><th>gender</th></tr></thead><tbody><tr><td>jim</td><td>36</td><td>camaro</td><td>M</td></tr><tr><td>carol</td><td>37</td><td>bmw</td><td>F</td></tr><tr><td>johnny</td><td>12</td><td></td><td>M</td></tr><tr><td>suzy</td><td>10</td><td></td><td>F</td></tr></tbody></table><p>Cassandra为每个分区键分配一个hash值：</p><table><thead><tr><th>Partition key</th><th>Murmur3 hash value</th></tr></thead><tbody><tr><td>jim</td><td>-2245462676723223822</td></tr><tr><td>carol</td><td>7723358927203680754</td></tr><tr><td>johnny</td><td>-6723372854036780875</td></tr><tr><td>suzy</td><td>1168604627387940318</td></tr></tbody></table><p>集群中的每个节点都使用hash值来管理一系列数据。</p><p>一个四个节点的集群中的hash值。<img src="http://docs.datastax.com/en/cassandra/3.0/cassandra/images/arc_hashValueRange.png" alt="img"></p><p>Cassandra根据分区键的值和节点管理的范围将数据放在每个节点上。 例如，在四节点集群中，本示例中的数据分布如下：</p><table><thead><tr><th>Node</th><th>Start range</th><th>End range</th><th>Partition key</th><th>Hash value</th></tr></thead><tbody><tr><td>A</td><td>-9223372036854775808</td><td>-4611686018427387904</td><td>johnny</td><td>-6723372854036780875</td></tr><tr><td>B</td><td>-4611686018427387903</td><td>-1</td><td>jim</td><td>-2245462676723223822</td></tr><tr><td>C</td><td>0</td><td>4611686018427387903</td><td>suzy</td><td>1168604627387940318</td></tr><tr><td>D</td><td>4611686018427387904</td><td>9223372036854775807</td><td>carol</td><td>7723358927203680754</td></tr></tbody></table><h3 id="Virtual-nodes-虚拟节点"><a href="#Virtual-nodes-虚拟节点" class="headerlink" title="Virtual nodes(虚拟节点)"></a>Virtual nodes(虚拟节点)</h3><p>虚拟节点，一般简称为Vnodes，以更细粒度的方式在节点之间分配数据，而不是使用计算的token可以轻松实现的。 Vnodes简化了Cassandra中的许多任务：</p><ul><li>Tokens将自动计算并分配给每个节点。</li><li>添加或删除节点时，会自动实现重新平衡群集。 当节点加入集群时，它承担来自集群中其他节点的数据的偶数部分的责任。 如果一个节点出现故障，则负载在集群中的其他节点之间均匀分布。</li><li>重建宕机节点会更快，因为它本身就已经包含了集群中其他节点的信息。</li><li>分配给集群中的每个机器的vnode的比例可以调节，因此可以在构建群集时使用更小和更大的计算机。</li></ul><p>更多信息，请参阅Cassandra 1.2中的<a href="https://www.datastax.com/dev/blog/virtual-nodes-in-cassandra-1-2" target="_blank" rel="noopener">虚拟节点</a>。 要将现有集群转换为vnodes，请参阅<a href="http://docs.datastax.com/en/cassandra/3.0/cassandra/configuration/configVnodesProduction.html" target="_blank" rel="noopener">启用现有生产集群上的虚拟节点</a>。</p><h3 id="如何通过集群分布数据（使用虚拟节点）"><a href="#如何通过集群分布数据（使用虚拟节点）" class="headerlink" title="如何通过集群分布数据（使用虚拟节点）"></a>如何通过集群分布数据（使用虚拟节点）</h3><p>在Cassandra 1.2之前，您必须为群集中的每个节点计算并分配单个token。 每个token根据其hash值确定节点在环中的位置及其部分数据。在Cassandra 1.2及更高版本中，每个节点都允许许多token。 新的范例称为虚拟节点（Vnodes）。 Vnodes允许每个节点拥有分布在整个集群中的大量小分区范围。 Vnodes还使用一致hash来分发数据，但使用它们不需要生成和分配token。</p><p>虚拟化 vs 单token 架构<img src="http://docs.datastax.com/en/cassandra/3.0/cassandra/images/arc_vnodes_compare.png" alt="img"></p><p>上半部分图：显示没有vnodes的群集。 在这个范例中，每个节点都被分配一个代表环中位置的token。 每个节点存储通过将分区密钥映射到从先前节点到其分配值的范围内的令牌值所确定的数据。 每个节点还包含集群中其他节点的每一行的副本。 例如，如果复制因子为3，范围E复制到节点5,6和1.请注意，节点在环空间中只拥有一个连续的分区范围。</p><p>下半部分图：显示带有vnodes的环。 在集群中，虚拟节点被随机选择并且不连续。 行的放置由属于每个节点的许多较小分区范围内的分区密钥的hash确定。</p><h3 id="数据复制"><a href="#数据复制" class="headerlink" title="数据复制"></a>数据复制</h3><p>Cassandra将副本存储在多个节点上，以确保可靠性和容错能力。 复制策略确定放置副本的节点。 集群中的副本总数称为复制因子。 复制因子为1表示集群中每行只有一个副本。 如果包含行的节点关闭，则无法检索该行。 复制因子2表示每行的两个副本，其中每个副本位于不同的节点上。 所有副本同样重要; 没有主副本。 作为一般规则，复制因子不应超过集群中的节点数。 但是，您可以增加复制因子，然后稍后添加所需数量的节点。</p><p>以下是两种可用的复制策略：</p><ul><li><code>SimpleStrategy</code>: 仅用于单个数据中心和一个机架， 如果您打算使用多个数据中心，请使用 <code>NetworkTopologyStrategy</code>。</li><li><code>NetworkTopologyStrategy</code>: 强烈推荐用于大多数部署，因为在将来的扩展需要的时候，它更容易扩展到多个数据中心。</li></ul><ul><li><p>SimpleStrategy</p><p>仅用于单个数据中心和一个机架。 SimpleStrategy将第一个副本放置在由分区器确定的节点上。 额外的副本被放置在环的顺时针的下一个节点上，而不考虑拓扑（机架或数据中心位置）。</p></li></ul><ul><li><p>NetworkTopologyStrategy</p><p>您有（或计划拥有）多个数据中心部署的群集时，请使用NetworkTopologyStrategy。此策略指定每个数据中心中需要多少个副本.NetworkTopologyStrategy将副本放在同一个数据中心中，方法是顺时针旋转环直到到达另一个机架中的第一个节点。 NetworkTopologyStrategy尝试将副本放在不同的机架上，因为同一机架（或类似的物理分组）中的节点由于电源，冷却或网络问题而经常同时发生故障。当决定在每个数据中心配置多少份副本时，考虑因素是（1）能够本地满足读取，而不会导致跨数据中心延迟，以及（2）故障情形。配置多个数据中心集群的两种最常见方法是：每个数据中心中的两个副本：此配置可以容许每个复制组中的单个节点发生故障，并且仍然允许本地读取在一个一致性级别。每个数据中心的三个副本：此配置每个复制组中的一个节点在<code>LOCAL_QUORUM</code>的强一致性级别或使用一致性级别ONE的每个数据中心的多个节点故障时可能会发生故障。不对称复制分组也是可能的。例如，您可以在一个数据中心中拥有三个副本，以提供实时应用程序请求，并在其他地方使用单个副本来运行分析。</p></li></ul><p>每个密钥空间定义复制策略，并在密钥空间创建期间设置复制策略。 要设置密钥空间，请参阅<a href="http://docs.datastax.com/en/cql/3.3/cql/cql_using/useCreateKeyspace.html" target="_blank" rel="noopener">创建密钥空间</a>。</p><p>有关复制策略选项的更多信息，请参阅<a href="http://docs.datastax.com/en/cassandra/3.0/cassandra/operations/opsChangeKSStrategy.html" target="_blank" rel="noopener">更改密钥空间复制策略</a>。</p><h2 id="分区器"><a href="#分区器" class="headerlink" title="分区器"></a>分区器</h2><p>分区器确定数据如何在集群中的节点（包括副本）上分布。 基本上，分区器是用于从其分区键（通常通过散列）导出表示行的令牌的函数。 然后通过令牌的值将每行数据分布在集群中。</p><p><code>Murmur3Partitioner</code>和<code>RandomPartitioner</code>都使用令牌来帮助将相等的数据分配给每个节点，并将数据从所有表格均匀地分布在整个环或其他分组（例如键空间）中。 即使表格使用不同的<a href="http://docs.datastax.com/en/glossary/doc/glossary/gloss_partition_key.html" target="_blank" rel="noopener">分区键</a>（例如用户名或最小化）也是如此。 此外，对集群的读取和写入请求也是均匀分布的，并且简化了负载平衡，因为散列范围的每个部分平均接收到相等数量的行。 有关更多详细信息，请参阅<a href="http://docs.datastax.com/en/cassandra/3.0/cassandra/architecture/archDataDistributeHashing.html" target="_blank" rel="noopener">一致散列</a>。</p><p>两个分区器之间的主要区别是每个分区器如何生成token hash。 <code>RandomPartitioner</code>使用比<code>Murmur3Partitioner</code>更长的生成加密哈希值。 Cassandra并不需要加密散列，所以使用<code>Murmur3Partitioner</code>可以提高3-5倍的性能。</p><p>Cassandra提供了可以在<a href="http://docs.datastax.com/en/cassandra/3.0/cassandra/configuration/configCassandra_yaml.html" target="_blank" rel="noopener">cassandra.yaml file</a>文件中设置的以下分区器。</p><ul><li><code>Murmur3Partitioner</code> (默认): 基于MurmurHash哈希值，统一分布整个群集中的数据。</li><li><code>RandomPartitioner</code>: 根据MD5哈希值，统一分布整个群集的数据。</li><li><code>ByteOrderedPartitioner</code>: 通过关键字节保持数据的有序分布。</li></ul><p><code>Murmur3Partitioner</code>是Cassandra 1.2及更高版本的新集群的默认分区策略，几乎在所有情况下都是新集群的正确选择。 但是，分区器不兼容，并且用一个分区器分区的数据不能轻易地转换为其他分区器。</p><p><strong>Note</strong>:如果使用虚拟节点（vnodes），则不需要计算令牌。 如果不使用vnodes，则必须计算要分配给<a href="http://docs.datastax.com/en/cassandra/3.0/cassandra/architecture/archPartitionerAbout.html#archPartitionerAbout__cassandrayaml" target="_blank" rel="noopener">cassandra.yaml</a> 文件中的 <a href="http://docs.datastax.com/en/cassandra/3.0/cassandra/configuration/configCassandra_yaml.html#configCassandra_yaml__initial_token" target="_blank" rel="noopener">initial_token</a> 参数的令牌。 请参阅生成令牌，并使用您正在使用的分区器类型的方法。</p><h3 id="Murmur3Partitioner"><a href="#Murmur3Partitioner" class="headerlink" title="Murmur3Partitioner"></a>Murmur3Partitioner</h3><p><code>Murmur3Partitioner</code>是默认分区器。 <code>Murmur3Partitioner</code>提供比<code>RandomPartitioner</code>更快的hash和改进的性能。 <code>Murmur3Partitioner</code>可以与<code>vnodes</code>一起使用。 但是，如果不使用vnodes，则必须按照生成token中的描述计算token。</p><p>将Murmur3Partitioner用于新集群; 您不能更改使用其他分区器的现有群集中的分区。 Murmur3Partitioner使用MurmurHash功能。 此散列函数创建分区密钥的64位哈希值。 哈希值的可能范围是  到 -1。</p><p>使用Murmur3Partitioner时，可以使用CQL查询中的令牌功能来浏览所有行。</p><h3 id="RandomPartitioner"><a href="#RandomPartitioner" class="headerlink" title="RandomPartitioner"></a>RandomPartitioner</h3><p><code>RandomPartitioner</code>是Cassandra 1.2之前的默认分区器。 它被包括用于向后兼容。 <code>RandomPartitioner</code>可以与虚拟节点（vnodes）一起使用。 但是，如果不使用vnodes，则必须按照生成令牌中所述计算令牌.<code>RandomPartitioner</code>使用行密钥的MD5哈希值在节点间均匀分布数据。 哈希值的可能范围为0到 -1。</p><p>使用<code>RandomPartitioner</code>时，可以使用CQL查询中的令牌函数来浏览所有行。</p><h3 id="ByteOrderedPartitioner"><a href="#ByteOrderedPartitioner" class="headerlink" title="ByteOrderedPartitioner"></a>ByteOrderedPartitioner</h3><p>Cassandra提供了<code>ByteOrderedPartitioner</code>进行有序分区。 它被包括用于向后兼容。 该分区器按照字节顺序排列行。 您可以通过查看分区密钥数据的实际值并使用密钥中的主要字符的十六进制表示来计算token。 例如，如果要按字母顺序分区行，则可以使用其十六进制表示41来分配A token。</p><p>使用有序的分区器可以通过主键进行有序扫描。 这意味着您可以扫描行，就像您将光标移动到传统索引一样。 例如，如果您的应用程序具有用户名作为分区键，则可以扫描名称位于Jake和Joe之间的用户的行。 这种类型的查询不可能使用随机分区的分区键，因为密钥按照它们的MD5哈希（不是顺序）的顺序存储。</p><p>尽管有能力对行进行范围扫描听起来像有序分区器的理想特征，但是有一些方法可以使用表索引来实现相同的功能。</p><p>不推荐使用有序的分区器，原因如下：</p><ul><li><p>负载均衡困难</p><p>负载平衡集群需要更多的管理开销。 有序分区器要求管理员根据分区密钥分发的估计值手动计算分区范围。 在实践中，这需要主动移动节点token，以适应数据一旦被加载的实际分布。</p></li></ul><ul><li><p>顺序写入容易引起过热节点</p><p>如果您的应用程序一次写入或更新顺序的行块，则写入不会分布在集群中; 他们都去一个节点。 对于处理时间戳数据的应用程序，这通常是一个问题。</p></li></ul><ul><li><p>多表的负载平衡不均衡</p><p>如果您的应用程序有多个表，那么这些表有可能具有不同的行键和不同的数据分布。 对于一个表平衡的有序分区器可能会导致同一集群中另一个表的热点和不均匀分布。</p></li></ul><h2 id="Snitches"><a href="#Snitches" class="headerlink" title="Snitches"></a>Snitches</h2><p>Snitch决定哪个数据中心和架子节点属于哪个。他们将网络拓扑告知Cassandra，以便有效地路由请求，并允许Cassandra通过将机器分组到数据中心和机架来分发副本。具体来说，复制策略将副本基于新snitch提供的信息。所有节点必须返回到相同的机架和数据中心。Cassandra最好不要在同一个机架上有多个副本(这并不一定是一个物理位置)。</p><p>注意：如果您更改snitches，您可能需要执行其他步骤，因为snitch会影响放置副本的位置。 请参阅切换线程。</p><h3 id="动态报告"><a href="#动态报告" class="headerlink" title="动态报告"></a>动态报告</h3><p>默认情况下，所有的snitches都使用一个动态的snitch层来监视读取延迟，并且在可能的情况下，将请求路由到执行较差的节点。动态的snitch是默认启用的，建议在大多数部署中使用。有关如何工作的信息，请参见Cassandra:过去、现在和未来的动态snitch。为每个节点配置动态的snitch阈值。yaml配置文件。</p><p>有关更多信息，请参见在故障检测和恢复中列出的属性。</p><h3 id="SimpleSnitch"><a href="#SimpleSnitch" class="headerlink" title="SimpleSnitch"></a>SimpleSnitch</h3><p>SimpleSnitch(默认)只用于单数据中心部署。它不承认数据中心或机架信息，只能在公共云中的单数据中心部署或单区使用。它将策略顺序视为接近性，它可以在禁用读修复时提高缓存位置。</p><p>使用SimpleSnitch，您可以定义keyspace来使用SimpleStrategy并指定一个复制因子。</p><h3 id="RackInferringSnitch"><a href="#RackInferringSnitch" class="headerlink" title="RackInferringSnitch"></a>RackInferringSnitch</h3><p>The RackInferringSnitch determines the proximity of nodes by rack and datacenter, which are assumed to correspond to the 3rd and 2nd octet of the node’s IP address, respectively. This snitch is best used as an example for writing a custom snitch class (unless this happens to match your deployment conventions).</p><p>RackInferringSnitch决定了通过机架和数据中心的临近节点，这些节点被假定分别对应于节点IP地址的第3和第2个数字。这个snitch最好用于编写一个定制的snitch类(除非这恰好符合您的部署约定)。</p><p><img src="http://docs.datastax.com/en/cassandra/3.0/cassandra/images/arc_rack_inferring_snitch_ips.png" alt="img"></p><h3 id="PropertyFileSnitch"><a href="#PropertyFileSnitch" class="headerlink" title="PropertyFileSnitch"></a>PropertyFileSnitch</h3><p>这个snitch决定了由机架和数据中心决定的距离。它使用位于cassandra拓扑中的网络详细信息。属性文件。当使用这个snitch时，您可以定义您的数据中心名称来做任何您想要的。确保数据中心名称与keyspace定义中数据中心的名称相关。集群中的每个节点都应该在cassandra拓扑中描述。属性文件，这个文件在集群中的每个节点上都应该是完全相同的。</p><h3 id="Procedure"><a href="#Procedure" class="headerlink" title="Procedure"></a>Procedure</h3><p>如果您有不一致的IPs和两个物理数据中心，每一个都有两个机架，还有一个用于复制分析数据的第三个逻辑数据中心，即cassandra拓扑。属性文件可能是这样的:注意:数据中心和机架名称区分大小写。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># datacenter One</span><br><span class="line"></span><br><span class="line">175.56.12.105=DC1:RAC1</span><br><span class="line">175.50.13.200=DC1:RAC1</span><br><span class="line">175.54.35.197=DC1:RAC1</span><br><span class="line"></span><br><span class="line">120.53.24.101=DC1:RAC2</span><br><span class="line">120.55.16.200=DC1:RAC2</span><br><span class="line">120.57.102.103=DC1:RAC2</span><br><span class="line"></span><br><span class="line"># datacenter Two</span><br><span class="line"></span><br><span class="line">110.56.12.120=DC2:RAC1</span><br><span class="line">110.50.13.201=DC2:RAC1</span><br><span class="line">110.54.35.184=DC2:RAC1</span><br><span class="line"></span><br><span class="line">50.33.23.120=DC2:RAC2</span><br><span class="line">50.45.14.220=DC2:RAC2</span><br><span class="line">50.17.10.203=DC2:RAC2</span><br><span class="line"></span><br><span class="line"># Analytics Replication Group</span><br><span class="line"></span><br><span class="line">172.106.12.120=DC3:RAC1</span><br><span class="line">172.106.12.121=DC3:RAC1</span><br><span class="line">172.106.12.122=DC3:RAC1</span><br><span class="line"></span><br><span class="line"># default for unknown nodes </span><br><span class="line">default =DC3:RAC1</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;关于本文档&quot;&gt;&lt;a href=&quot;#关于本文档&quot; class=&quot;headerlink&quot; title=&quot;关于本文档&quot;&gt;&lt;/a&gt;关于本文档&lt;/h2&gt;&lt;p&gt;欢迎来到DataStax提供的Cassandra文档。 为确保您在使用本文档时获得最佳体验，请花点时间查看使用Dat
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Google API 权威指南</title>
    <link href="http://luxiangdong.com/2018/05/03/google-api/"/>
    <id>http://luxiangdong.com/2018/05/03/google-api/</id>
    <published>2018-05-03T05:41:14.000Z</published>
    <updated>2018-05-08T08:08:58.689Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>这是网络API的一般设计指南。自2014年以来，它已在Google内部使用，是Google在设计Cloud API和其他Google API时所遵循的指南。本设计指南在此共享，以通知外部开发人员，并使我们所有人更容易合作。</p><p>Google Cloud Endpoints开发人员可能会发现本指南在设计gRPC API时特别有用，我们强烈建议此类开发人员使用这些设计原则。但是，我们不要求使用它。您可以使用Cloud Endpoints和gRPC，而无需遵循指南。</p><p>本指南适用于REST API和RPC API，特别关注gRPC API。 gRPC API使用Protocol Buffersto定义其API表面和API服务配置来配置其API服务，包括HTTP映射，日志记录和监视。 HTTP映射功能由Google API和云端点用于JSON / HTTP到协议缓冲区/ RPC转码的gRPC API使用。</p><p>本指南是生活文件，随着时间的推移，新的风格和设计模式得到采纳和批准。以这种精神，它永远不会是完整的，而且API设计的艺术和手艺将永远有足够的空间。</p><h2 id="本文档的使用约定"><a href="#本文档的使用约定" class="headerlink" title="本文档的使用约定"></a>本文档的使用约定</h2><p>要求等级关键字“MUST”，“MUST NOT”，“REQUIRED”，“SHALL”，“SHALL NOT”，“SHOULD”，“SHOULD NOT”，“RECOMMENDED”，“MAY”和“OPTIONAL” 文档将被解释为RFC 2119中所述。</p><p>在本文档中，使用粗体字体突出显示这些关键字。</p><h1 id="面向资源设计"><a href="#面向资源设计" class="headerlink" title="面向资源设计"></a>面向资源设计</h1><p>本指南的总目标是为了帮助开发者设计简单、易用和风格一致性的网络API。 At the same time, it also helps converging designs of socket-based RPC APIs with HTTP-based REST APIs.</p><p>传统上，people design RPC APIs in terms of API interfaces and methods, such as CORBA and Windows COM. As time goes by, more and more interfaces and methods are introduced. The end result can be an overwhelming number of interfaces and methods, each of them different from the others. Developers have to learn each one carefully in order to use it correctly, which can be both time consuming and error prone.</p><p>REST架构风格第一次出现是在2000年左右, 主要目的是为了让在HTTP/1.1协议上更有效的工作。 它的核心思想是定义那些可以使用少量操作方法来操作的命名资源。The resources and methods are known as <em>名词</em> and <em>动词</em> of APIs. With the HTTP protocol, the resource names naturally map to URLs, and methods naturally map to HTTP methods <code>POST</code>, <code>GET</code>, <code>PUT</code>, <code>PATCH</code>, and <code>DELETE</code>.</p><p>在互联网上，HTTP REST API最近取得了巨大的成功。在2010年，大约74％的公共网络API是HTTP REST API。</p><p>虽然HTTP REST API在互联网上非常受欢迎，但它们传输的数据量比传统的RPC API小。例如，美国高峰时段的互联网流量的大约一半是视频内容，很少有人会因为性能原因考虑使用REST API来传送这些内容。在数据中心内部，许多公司使用基于插座的RPC API来承载大多数网络流量，这可能比公共REST API高出数量级。</p><p>实际上，由于各种原因需要RPC API和HTTP REST API。理想情况下，API平台应为所有API提供最佳支持。本设计指南可帮助您设计和构建符合这一原则的API。它通过将资源导向的设计原理应用于通用API设计来实现，并且定义了许多常见的设计模式以提高可用性并降低复杂性。</p><p>注意：本设计指南解释了如何将REST原理应用于独立于编程语言，操作系统或网络协议的API设计。它不仅仅是创建REST API的指南。</p><h2 id="What-is-a-REST-API"><a href="#What-is-a-REST-API" class="headerlink" title="What is a REST API?"></a>What is a REST API?</h2><p>REST API被建模为可单独寻址的资源（API的名词）的集合。 资源通过其资源名称引用，并通过一小组方法（也称为动词或操作）进行操作。</p><p>REST Google API（也称为REST方法）的标准方法是列表，获取，创建，更新和删除。 自定义方法（也称为自定义动词或自定义操作）也可用于API设计人员的功能，这些功能不容易映射到诸如数据库事务之类的标准方法之一。</p><p>注意：自定义动词并不意味着创建自定义HTTP动词以支持自定义方法。 对于基于HTTP的API，它们只是映射到最合适的HTTP动词。</p><h2 id="设计流程"><a href="#设计流程" class="headerlink" title="设计流程"></a>设计流程</h2><p>《设计指南》建议参照以下步骤设计面向资源的APIs:</p><ul><li>确定API提供的资源类型；</li><li>确定资源之间的关系；</li><li>基于资源的类型和关系确定资源的命名方式；</li><li>决定资源模式；</li><li>给资源附上最小化的方法集。</li></ul><h2 id="Resources"><a href="#Resources" class="headerlink" title="Resources"></a>Resources</h2><p>一个面向资源的API 通常都是按资源层级来建模的， 各层级的节点被称为资源或者资源集合。 简单起见， 我们往往分别称之为资源或者集合。</p><ul><li>一个集合包含一组<strong>相同类型</strong>的资源。比如，一个用户的所有联系人就是一个资源集合。</li><li>一个资源会有一些状态，也可能拥有几个子资源。每个子资源都可以表示一个资源或者一个资源集合。 </li></ul><p>Gmail的API拥有一组用户资源，每个用户又拥有消息资源集合，线程资源集合，标签资源集合等，一个描述资源和多个设置资源等。</p><p>虽然存储系统和REST API之间存在一些概念上的一致性，但面向资源的API的服务并不一定是数据库，在解释资源和方法方面具有很大的灵活性。 例如，创建一个日历事件(resource)可以为参与者创建额外的事件，发送电子邮件邀请到出席者，预订会议室，以及更新视频会议日程。</p><h2 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h2><p>面向资源的API的关键特性是它强调资源(数据模型)，而不是在资源(功能)上执行的方法。一个典型的面向资源的API使用少量的方法公开大量资源。这些方法可以是标准方法或者自定义方法。在本文中， 标准方法有: <code>List</code>, <code>Get</code>, <code>Create</code>, <code>Update</code>, and <code>Delete</code>.</p><p>如果API的功能可以自然地映射到某一标准方法，那么该方法应该在API设计中使用。对于不能自然映射到标准方法的功能，可以使用自定义方法。自定义方法提供了与传统RPC API相同的设计自由度，这些api可用于实现常见的编程模式，如数据库事务或数据分析。</p><h2 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h2><p>下面几节介绍了如何将面向资源的API设计应用于大型服务的一些实际示例。</p><h3 id="Gmail-API"><a href="#Gmail-API" class="headerlink" title="Gmail API"></a>Gmail API</h3><p>Gmail API服务实现了Gmail API，并暴露了Gmail的大部分功能。它有以下资源模型:</p><ul><li>Gmail API 服务: <code>gmail.googleapis.com</code></li><li>users的API集合: <code>users/*</code>. 每个用户都拥有以下资源。A collection of messages: <code>users/*/messages/*</code>.A collection of threads: <code>users/*/threads/*</code>.A collection of labels: <code>users/*/labels/*</code>.A collection of change history: <code>users/*/history/*</code>.A resource representing the user profile: <code>users/*/profile</code>.A resource representing user settings: <code>users/*/settings</code>.</li></ul><h3 id="Google-Cloud-Pub-Sub-API"><a href="#Google-Cloud-Pub-Sub-API" class="headerlink" title="Google Cloud Pub/Sub API"></a>Google Cloud Pub/Sub API</h3><p><code>pubsub.googleapis.com</code>服务实现了Google Cloud的订阅发布API，定义了以下资源模型：</p><ul><li>API服务：<code>pubsub.googleapis.com</code></li><li>主题集合：<code>projects/*/topics/</code>*。</li><li>订阅集合：<code>projects/*/subscriptions/*</code>。</li></ul><p>注意：Pub / Sub API的其他实现可以选择不同的资源命名方案。</p><h1 id="资源命名"><a href="#资源命名" class="headerlink" title="资源命名"></a>资源命名</h1><p>在面向资源的api中，资源被命名为实体，资源名是它们的标识符。每个资源都有自己独特的资源名。资源名是由资源本身的ID、任何父资源的ID和它的API服务名组成的。我们将在下面章节研究资源ID，以及如何构造资源名。</p><p>gRPC api应该为资源名使用无模式的uri。它们通常遵循REST的URL约定，并且表现得很像网络文件路径。它们可以很容易地映射到REST url:请参阅标准方法部分以获得详细信息。</p><p><strong>集合</strong>是一种特殊类型的资源，它包含相同类型的子资源列表。例如，目录是文件资源的集合。集合的资源ID称为集合ID。</p><p>资源名称使用集合ID和资源ID进行分层组织，以正斜杠分隔。 如果一个资源包含一个子资源，子资源的名称是通过指定父资源名称后跟子资源的ID来形成的，再次用正斜杠分隔。</p><p>Example 1: 存储服务有一组 <code>buckets</code>，每个 <code>buckets</code>都有一个对象集合:</p><table><thead><tr><th>API Service Name</th><th>Collection ID</th><th>Resource ID</th><th>Collection ID</th><th>Resource ID</th></tr></thead><tbody><tr><td>//storage.googleapis.com</td><td>/buckets</td><td>/bucket-id</td><td>/objects</td><td>/object-id</td></tr></tbody></table><p>Example 2: 电子邮件服务有一组用户。 每个用户都有一个设置子资源，并且设置子资源有许多其他子资源，包括<code>customFrom</code>：</p><table><thead><tr><th>API Service Name</th><th>Collection ID</th><th>Resource ID</th><th>Resource ID</th><th>Resource ID</th></tr></thead><tbody><tr><td>//mail.googleapis.com</td><td>/users</td><td>/<a href="mailto:name@example.com" target="_blank" rel="noopener">name@example.com</a></td><td>/settings</td><td>/customFrom</td></tr></tbody></table><p>只要在资源层次结构中它们是唯一的，API生产者可以为资源和集合ID选择任何可接受的值。 您可以在下面找到更多有关选择适当的资源和集合ID的准则。</p><p>通过拆分资源名称，例如name.split（“/”）[n]，假设没有一个段包含任何正斜杠，可以获取各个集合ID和资源ID。</p><h2 id="完整的资源名称"><a href="#完整的资源名称" class="headerlink" title="完整的资源名称"></a>完整的资源名称</h2><p>由DNS兼容的API服务名称和资源路径组成的无方案URI。 资源路径也称为相对资源名称。 例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;//library.googleapis.com/shelves/shelf1/books/book2&quot;</span><br></pre></td></tr></table></figure><p>API服务名称用于客户端定位API服务端点; 它可能是内部服务的假DNS名称。 如果API服务名称从上下文中显而易见，则通常使用相对的资源名称。</p><h2 id="相对路径资源名称"><a href="#相对路径资源名称" class="headerlink" title="相对路径资源名称"></a>相对路径资源名称</h2><p>没有前导“/”的URI路径（path-noscheme）。 它标识API服务中的资源。 例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;shelves/shelf1/books/book2&quot;</span><br></pre></td></tr></table></figure><h2 id="资源ID"><a href="#资源ID" class="headerlink" title="资源ID"></a>资源ID</h2><p>识别其父资源中资源的非空URI段（segment-nz-nc），请参见上述示例。</p><p>资源名称中的尾随资源ID可能有多个URI段。 例如：</p><table><thead><tr><th>Collection ID</th><th>Resource ID</th></tr></thead><tbody><tr><td>files</td><td>/source/py/parser.py</td></tr></tbody></table><p>API服务应在可行时使用URL友好的资源ID。 资源ID必须清楚记录，无论客户端，服务器还是由客户端分配。 例如，文件名通常由客户机分配，而电子邮件消息ID通常由服务器分配。</p><h2 id="集合ID"><a href="#集合ID" class="headerlink" title="集合ID"></a>集合ID</h2><p>标识其父资源中的集合资源的非空URI段（segment-nz-nc），请参见上述示例。</p><p>因为集合ID通常出现在生成的客户端库中，所以它们必须符合以下要求：</p><ul><li><strong>Must</strong>是有效的C / C ++标识符。</li><li><strong>Must</strong>是复数形式与lowerCamel case。</li><li><strong>Must</strong>使用清晰简明的英文术语。</li><li>应避免或超出合格范围。 例如，<code>RowValue</code>优于<code>Value</code>。 应该避免以下条款，无需资格：ElementEntryInstanceItemObjectResourceTypeValue</li></ul><h2 id="资源名-vs-URL"><a href="#资源名-vs-URL" class="headerlink" title="资源名 vs URL"></a>资源名 vs URL</h2><p>虽然完整的资源名称与普通URL相似，但它们并不一样。 单一资源可以由不同版本的API和不同的API协议公开。 完整的资源名称不指定此类信息，因此必须将其映射到特定协议和API版本以供实际使用。</p><p>要通过REST API使用完整的资源名称，必须通过在服务名称之前添加HTTPS方案，在资源路径之前添加API主版本以及将URL转义为资源路径，将其转换为REST URL。 例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// calendar事件资源名称.</span><br><span class="line">&quot;//calendar.googleapis.com/users/john smith/events/123&quot;</span><br><span class="line"></span><br><span class="line">// 相应的HTTP URL.</span><br><span class="line">&quot;https://calendar.googleapis.com/v3/users/john%20smith/events/123&quot;</span><br></pre></td></tr></table></figure><h2 id="Resource-Name-as-String"><a href="#Resource-Name-as-String" class="headerlink" title="Resource Name as String"></a>Resource Name as String</h2><p>Google API必须使用字符串来表示资源名称，除非是向后兼容性问题。 资源名称应该像普通文件路径一样处理，并且不支持％-encoding。</p><p>对于资源定义，第一个字段应该是资源名称的字符串字段，它应该被叫作<code>name</code>.</p><p><strong>Note:</strong> 其他相关的name字段应该避免混淆，比如 <code>display_name</code>, <code>first_name</code>, <code>last_name</code>, <code>full_name</code>.</p><p>例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">service LibraryService &#123;</span><br><span class="line">  rpc GetBook(GetBookRequest) returns (Book) &#123;</span><br><span class="line">    option (google.api.http) = &#123;</span><br><span class="line">      get: &quot;/v1/&#123;name=shelves/*/books/*&#125;&quot;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">  rpc CreateBook(CreateBookRequest) returns (Book) &#123;</span><br><span class="line">    option (google.api.http) = &#123;</span><br><span class="line">      post: &quot;/v1/&#123;parent=shelves/*&#125;/books&quot;</span><br><span class="line">      body: &quot;book&quot;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message Book &#123;</span><br><span class="line">  // Resource name of the book. It must have the format of &quot;shelves/*/books/*&quot;.</span><br><span class="line">  // For example: &quot;shelves/shelf1/books/book2&quot;.</span><br><span class="line">  string name = 1;</span><br><span class="line"></span><br><span class="line">  // ... other properties</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message GetBookRequest &#123;</span><br><span class="line">  // Resource name of a book. For example: &quot;shelves/shelf1/books/book2&quot;.</span><br><span class="line">  string name = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message CreateBookRequest &#123;</span><br><span class="line">  // Resource name of the parent resource where to create the book.</span><br><span class="line">  // For example: &quot;shelves/shelf1&quot;.</span><br><span class="line">  string parent = 1;</span><br><span class="line">  // The Book resource to be created. Client must not set the `Book.name` field.</span><br><span class="line">  Book book = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Note:</strong> 为了资源名称的一致性，前导正斜杠<strong>不能</strong>被任何URL模板变量捕获。 例如，必须使用URL模板<code>&quot;/v1/{name=shelves/*/books/*}&quot;</code>来代替<code>&quot;/v1{name=/shelves/*/books/*}&quot;</code>。</p><h1 id="标准方法"><a href="#标准方法" class="headerlink" title="标准方法"></a>标准方法</h1><p>本章节来定义标准方法的概念，这些方法是： <code>List</code>, <code>Get</code>, <code>Create</code>, <code>Update</code>, and <code>Delete</code>. 标准方法降低复杂性并提高一致性。超过70% 的Google API方法都是标准方法 ， 这使得他们更加易于学习和使用。</p><p>下表介绍了如何将标准方法映射到HTTP方法：</p><table><thead><tr><th>Standard Method</th><th>HTTP Mapping</th><th>HTTP Request Body</th><th>HTTP Response Body</th></tr></thead><tbody><tr><td><a href="https://cloud.google.com/apis/design/standard_methods#list" target="_blank" rel="noopener"><code>List</code></a></td><td><code>GET &lt;collection URL&gt;</code></td><td>Empty</td><td>Resource* list</td></tr><tr><td><a href="https://cloud.google.com/apis/design/standard_methods#get" target="_blank" rel="noopener"><code>Get</code></a></td><td><code>GET &lt;resource URL&gt;</code></td><td>Empty</td><td>Resource*</td></tr><tr><td><a href="https://cloud.google.com/apis/design/standard_methods#create" target="_blank" rel="noopener"><code>Create</code></a></td><td><code>POST &lt;collection URL&gt;</code></td><td>Resource</td><td>Resource*</td></tr><tr><td><a href="https://cloud.google.com/apis/design/standard_methods#update" target="_blank" rel="noopener"><code>Update</code></a></td><td><code>PUT or PATCH &lt;resource URL&gt;</code></td><td>Resource</td><td>Resource*</td></tr><tr><td><a href="https://cloud.google.com/apis/design/standard_methods#delete" target="_blank" rel="noopener"><code>Delete</code></a></td><td><code>DELETE &lt;resource URL&gt;</code></td><td>Empty</td><td>Empty**</td></tr></tbody></table><p>*从 <code>List</code>, <code>Get</code>, <code>Create</code>和 <code>Update</code> 方法返回的资源可能包含部分数据，如果方法支持字段掩码，指定要返回的字段的子集。 在某些情况下，API平台本身支持所有方法的字段掩码。</p><p><code>Delete</code>方法的返回响应，并不是立即删除资源（例如更新标志或创建长时间运行的删除操作）的Delete方法返回的响应应该包含长时间运行的操作或修改的资源。</p><p>对于在单个API调用的时间范围内未完成的请求，标准方法也可能返回长时间运行的操作。</p><p>以下部分详细介绍了每种标准方法。 示例显示.proto文件中定义的方法，其中包含HTTP映射的特殊注释。 您可以在Google API资源库中找到使用标准方法的许多示例。</p><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p><code>List</code>方法将集合名称和零个或多个参数作为输入，并返回与输入匹配的资源列表。</p><p><code>List</code>通常用于搜索资源， <code>List</code>适合来自单个集合的数据，该集合的大小有限，而不是高速缓存。 对于更广泛的情况，应使用<strong>自定义</strong>的<code>Search</code>方法。</p><p>批处理获取（如采用多个资源ID并返回每个ID的对象）的方法应该被实现为自定义<code>BatchGet</code>方法而不是<code>List</code></p><p>。 但是，如果您已有一个已经存在的<code>List</code>方法提供相同的功能，则可以重新使用<code>List</code>方法。 如果您使用自定义<code>BatchGet</code>方法，则应将其映射到<code>HTTP GET</code>。</p><p>适用的常见模式：分页，结果排序。</p><p>适用的命名约定：过滤器字段，结果字段。</p><p>HTTP映射:</p><ul><li><code>List</code> 方法b必须使用HTTP的<code>GET</code>动词.</li><li>接收列出其资源的集合的名称的请求消息字段应映射到URL路径。 如果集合名称映射到URL路径，则URL模板的最后一个段（集合ID）必须是字面值。</li><li>所有剩余的请求消息字段应映射到URL查询参数。</li><li>没有请求body，API配置不能声明一个body子句。</li><li>响应body应包含资源列表以及可选元数据。</li></ul><p>以下代码示例定义了一个书本集合的标准<code>List</code>方法 :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// 列出给定的书架上的所有书本。</span><br><span class="line">rpc ListBooks(ListBooksRequest) returns (ListBooksResponse) &#123;</span><br><span class="line">  // List method maps to HTTP GET.</span><br><span class="line">  option (google.api.http) = &#123;</span><br><span class="line">    // The `parent` captures the parent resource name, such as &quot;shelves/shelf1&quot;.</span><br><span class="line">    get: &quot;/v1/&#123;parent=shelves/*&#125;/books&quot;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message ListBooksRequest &#123;</span><br><span class="line">  // The parent resource name, for example, &quot;shelves/shelf1&quot;.</span><br><span class="line">  string parent = 1;</span><br><span class="line"></span><br><span class="line">  // The maximum number of items to return.</span><br><span class="line">  int32 page_size = 2;</span><br><span class="line"></span><br><span class="line">  // The next_page_token value returned from a previous List request, if any.</span><br><span class="line">  string page_token = 3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message ListBooksResponse &#123;</span><br><span class="line">  // The field name should match the noun &quot;books&quot; in the method name.  There</span><br><span class="line">  // will be a maximum number of items returned based on the page_size field</span><br><span class="line">  // in the request.</span><br><span class="line">  repeated Book books = 1;</span><br><span class="line"></span><br><span class="line">  // Token to retrieve the next page of results, or empty if there are no</span><br><span class="line">  // more results in the list.</span><br><span class="line">  string next_page_token = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Get"><a href="#Get" class="headerlink" title="Get"></a>Get</h2><p> <code>Get</code> 方法将有一个资源名，零或多个参数，和资源的返回值说明。</p><p>HTTP mapping:</p><ul><li>The <code>Get</code> 方法使用HTTP的<code>Get</code>形式。</li><li>The request message field(s) receiving the resource name <strong>should</strong> map to the URL path.</li><li>All remaining request message fields <strong>shall</strong> map to the URL query parameters.</li><li>There is no request body; the API configuration <strong>must not</strong> declare a <code>body</code> clause.</li><li>The returned resource <strong>shall</strong> map to the entire response body.</li></ul><p>The following code example defines a standard <code>Get</code> method that gets a specified book:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// Gets the specified book.</span><br><span class="line">rpc GetBook(GetBookRequest) returns (Book) &#123;</span><br><span class="line">  // Get maps to HTTP GET. Resource name is mapped to the URL. No body.</span><br><span class="line">  option (google.api.http) = &#123;</span><br><span class="line">    // Note the URL template variable which captures the multi-segment resource</span><br><span class="line">    // name of the requested book, such as &quot;shelves/shelf1/books/book2&quot;</span><br><span class="line">    get: &quot;/v1/&#123;name=shelves/*/books/*&#125;&quot;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message GetBookRequest &#123;</span><br><span class="line">  // The field will contain name of the resource requested, for example:</span><br><span class="line">  // &quot;shelves/shelf1/books/book2&quot;</span><br><span class="line">  string name = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Create"><a href="#Create" class="headerlink" title="Create"></a>Create</h2><p> <code>Create</code> 方法拥有一组名称，一个资源，零个或多个参数，它在指定的集合中创建一个新资源，并返回新创建的资源。</p><p>如果API支持创建资源，则应该为可以创建的每种资源类型创建一个<code>Create</code>方法。</p><p>HTTP映射：</p><ul><li><code>Create</code>方法必须使用HTTP <code>POST</code>动词。</li><li>请求消息应该有一个字段<code>parent</code>，指定资源要创建的父资源名称。</li><li>所有剩余的请求消息字段应映射到URL查询参数。</li><li>请求可能包含名为<code>&lt;resource&gt;_id</code>的字段，以允许呼叫者选择客户端分配的ID。 该字段必须映射到URL查询参数。</li><li>包含资源的请求消息字段应映射到请求主体。 如果<code>body</code>的HTTP配置子句用于<code>Create</code>方法，则必须使用<code>body：&quot;&lt;resource_field&gt;&quot;</code>表单。</li><li>返回的资源将映射到整个响应体。</li></ul><p>如果<code>Create</code>方法支持客户端分配的资源名称并且资源已经存在，则该请求应该失败，并出现错误代码<code>google.rpc.Code.ALREADY_EXISTS</code>，或使用不同的服务器分配的资源名称，并且文档应清楚创建的资源名称 可能与传入的不同。</p><p>以下代码示例定义了一个标准的<code>Create</code>方法，该方法在父书架内创建一本书：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">rpc CreateBook(CreateBookRequest) returns (Book) &#123;</span><br><span class="line">  // Create maps to HTTP POST. URL path as the collection name.</span><br><span class="line">  // HTTP request body contains the resource.</span><br><span class="line">  option (google.api.http) = &#123;</span><br><span class="line">    // The `parent` captures the parent resource name, such as &quot;shelves/1&quot;.</span><br><span class="line">    post: &quot;/v1/&#123;parent=shelves/*&#125;/books&quot;</span><br><span class="line">    body: &quot;book&quot;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message CreateBookRequest &#123;</span><br><span class="line">  // The parent resource name where the book to be created.</span><br><span class="line">  string parent = 1;</span><br><span class="line"></span><br><span class="line">  // The book id to use for this book.</span><br><span class="line">  string book_id = 3;</span><br><span class="line"></span><br><span class="line">  // The book resource to create.</span><br><span class="line">  // The field name should match the Noun in the method name.</span><br><span class="line">  Book book = 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rpc CreateShelf(CreateShelfRequest) returns (Shelf) &#123;</span><br><span class="line">  option (google.api.http) = &#123;</span><br><span class="line">    post: &quot;/v1/shelves&quot;</span><br><span class="line">    body: &quot;shelf&quot;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message CreateShelfRequest &#123;</span><br><span class="line">  Shelf shelf = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h2><p><code>Update</code>方法接收包含资源和零个或多个参数的请求消息。 它更新指定的资源及其属性，并返回更新的资源。</p><p>可变资源属性应该由<code>Update</code>方法可变，除了包含资源名称或父属性。 <strong>重新命名或移动资源</strong>的任何功能不得在<code>Update</code>方法中发生，而应由自定义方法处理。</p><p>HTTP映射：</p><ul><li>标准<code>Update</code>方法应该支持部分资源更新，并使用名为<code>update_mask</code>的<code>FieldMask</code>字段的HTTP动词<code>PATCH</code>。</li><li>需要使用更高级的修补语义（如附加到重复字段）的<code>Update</code>方法应该通过自定义方法提供。</li><li>如果<code>Update</code>方法仅支持完全资源更新，则必须使用HTTP动词<code>PUT</code>。 但是，完全更新非常不鼓励，因为在添加新的资源字段时它具有向后的兼容性问题。</li><li>接收资源名称的消息字段必须映射到URL路径。 该字段可能在资源消息本身中。</li><li>包含资源的请求消息字段必须映射到请求主体。</li><li>所有剩余的请求消息字段必须映射到URL查询参数。</li><li>响应消息必须是更新的资源本身。</li></ul><p>如果API接受客户端分配的资源名称，则服务器可能允许客户端指定不存在的资源名称并创建新的资源。 否则，<code>Update</code>方法应该以不存在的资源名称失败。 如果它是唯一的错误条件，则应使用错误代码<code>NOT_FOUND</code>。</p><p>具有支持资源创建的<code>Update</code>方法的API还应提供<code>Create</code>方法。 理由是，如果<code>Update</code>方法是唯一的方法，它不清楚如何创建资源。</p><p>以下代码示例定义了更新指定书籍的标准<code>Update</code>方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">rpc UpdateBook(UpdateBookRequest) returns (Book) &#123;</span><br><span class="line">  // Update maps to HTTP PATCH. Resource name is mapped to a URL path.</span><br><span class="line">  // Resource is contained in the HTTP request body.</span><br><span class="line">  option (google.api.http) = &#123;</span><br><span class="line">    // Note the URL template variable which captures the resource name of the</span><br><span class="line">    // book to update.</span><br><span class="line">    patch: &quot;/v1/&#123;book.name=shelves/*/books/*&#125;&quot;</span><br><span class="line">    body: &quot;book&quot;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message UpdateBookRequest &#123;</span><br><span class="line">  // The book resource which replaces the resource on the server.</span><br><span class="line">  Book book = 1;</span><br><span class="line"></span><br><span class="line">  // The update mask applies to the resource. For the `FieldMask` definition,</span><br><span class="line">  // see https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#fieldmask</span><br><span class="line">  FieldMask update_mask = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h2><p> <code>Delete</code> 方法使用资源名称和零个或多个参数，并删除或调度以删除指定的资源。 <code>Delete</code>方法应该返回<code>google.protobuf.Empty</code>。</p><p>API不应该依赖于<code>Delete</code>方法返回的任何信息，因为它不能重复调用。</p><p>HTTP映射：</p><ul><li>Delete方法必须使用HTTP <code>DELETE</code>动词。</li><li>接收资源名称的请求消息字段应映射到URL路径。</li><li>所有剩余的请求消息字段应映射到URL查询参数。</li><li>没有请求机构 API配置不能声明一个<code>body</code>子句。</li><li>如果<code>Delete</code>方法立即删除资源，它应该返回一个空的响应。</li><li>如果<code>Delete</code>方法启动长时间运行的操作，则应返回长时间运行的操作。</li><li>如果<code>Delete</code>方法仅将资源标记为已删除，则应返回更新的资源。</li></ul><p>Calls to the <code>Delete</code> method should be <a href="http://tools.ietf.org/html/rfc2616#section-9.1.2" target="_blank" rel="noopener">idempotent</a> in effect, but do not need to yield the same response. Any number of<code>Delete</code> requests <strong>should</strong> result in a resource being (eventually) deleted, but only the first request should result in a success code. Subsequent requests should result in a <code>google.rpc.Code.NOT_FOUND</code>.</p><p>The following code example defines a standard <code>Delete</code> method that deletes a specified book:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">rpc DeleteBook(DeleteBookRequest) returns (google.protobuf.Empty) &#123;</span><br><span class="line">  // Delete maps to HTTP DELETE. Resource name maps to the URL path.</span><br><span class="line">  // There is no request body.</span><br><span class="line">  option (google.api.http) = &#123;</span><br><span class="line">    // Note the URL template variable capturing the multi-segment name of the</span><br><span class="line">    // book resource to be deleted, such as &quot;shelves/shelf1/books/book2&quot;</span><br><span class="line">    delete: &quot;/v1/&#123;name=shelves/*/books/*&#125;&quot;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message DeleteBookRequest &#123;</span><br><span class="line">  // The resource name of the book to be deleted, for example:</span><br><span class="line">  // &quot;shelves/shelf1/books/book2&quot;</span><br><span class="line">  string name = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="自定义方法"><a href="#自定义方法" class="headerlink" title="自定义方法"></a>自定义方法</h1><p>本章节我们将讨论如何使用自定义方法来设计API。</p><p>除了5种标准方法之外，定制方法是指API方法。 它们只能用于<strong>不能通过标准方法表达的功能</strong>。 一般情况下，API设计人员应该在可行时选择使用自定义方法的标准方法。 标准方法有大多数开发人员熟悉的更简单和定义明确的语义，因此它们易于使用，并且容易出错。 标准方法的另一个优点是API平台对标准方法（如计费，错误处理，日志记录和监视）有更好的理解和支持。</p><p>自定义方法可以与资源，集合或服务相关联。 它可能需要任意的请求并返回任意的响应，并且还支持流请求和响应。</p><p>自定义方法名称必须遵循<a href="https://cloud.google.com/apis/design/naming_convention#method_names" target="_blank" rel="noopener">方法命名约定</a>.</p><h2 id="HTTP-mapping"><a href="#HTTP-mapping" class="headerlink" title="HTTP mapping"></a>HTTP mapping</h2><p>对于自定义方法，他们应该使用以下通用HTTP映射：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://service.name/v1/some/resource/name:customVerb</span><br></pre></td></tr></table></figure><p>使用<code>：</code>而不是<code>/</code>将资源名称中的自定义动词分开的原因是可以支持任意路径。 例如，取消删除文件可以映射到 <code>POST /files/a/long/file/name:undelete</code></p><p>选择HTTP映射时应适用以下准则：</p><ul><li>自定义方法应该使用HTTP <code>POST</code>动词，因为它具有最灵活的语义。</li><li>自定义方法不应该使用HTTP <code>PATCH</code>，但可能使用其他HTTP动词。在这种情况下，方法必须遵循该动词的标准HTTP语义。</li><li>值得注意的是，使用HTTP <code>GET</code>的自定义方法必须是幂等的，没有副作用。例如，在资源上实现特殊视图的自定义方法应该使用HTTP <code>GET</code>。</li><li>接收与自定义方法相关联的资源或集合的资源名称的请求消息字段应映射到URL路径。</li><li>URL路径必须以后缀为自定义动词的冒号结尾。</li><li>如果用于自定义方法的HTTP动词允许HTTP请求体（<code>POST</code>，<code>PUT</code>，<code>PATCH</code>或自定义HTTP动词），则此类自定义方法的HTTP配置必须使用<code>body：&quot;*&quot;</code>子句和所有其余请求消息字段应映射到HTTP请求体。</li><li>如果用于自定义方法的HTTP动词不接受HTTP请求体（<code>GET</code>，<code>DELETE</code>），则此类方法的HTTP配置根本不能使用<code>body</code>子句，所有剩余的请求消息字段都应映射到URL查询参数。</li></ul><p><strong>WARNING</strong>: If a service implements multiple APIs, the API producer <strong>must</strong> carefully create the service configuration to avoid custom verb conflicts between APIs.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// This is a service level custom method.</span><br><span class="line">rpc Watch(WatchRequest) returns (WatchResponse) &#123;</span><br><span class="line">  // Custom method maps to HTTP POST. All request parameters go into body.</span><br><span class="line">  option (google.api.http) = &#123;</span><br><span class="line">    post: &quot;/v1:watch&quot;</span><br><span class="line">    body: &quot;*&quot;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// This is a collection level custom method.</span><br><span class="line">rpc ClearEvents(ClearEventsRequest) returns (ClearEventsResponse) &#123;</span><br><span class="line">  option (google.api.http) = &#123;</span><br><span class="line">    post: &quot;/v3/events:clear&quot;</span><br><span class="line">    body: &quot;*&quot;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// This is a resource level custom method.</span><br><span class="line">rpc CancelEvent(CancelEventRequest) returns (CancelEventResponse) &#123;</span><br><span class="line">  option (google.api.http) = &#123;</span><br><span class="line">    post: &quot;/v3/&#123;name=events/*&#125;:cancel&quot;</span><br><span class="line">    body: &quot;*&quot;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// This is a batch get custom method.</span><br><span class="line">rpc BatchGetEvents(BatchGetEventsRequest) returns (BatchGetEventsResponse) &#123;</span><br><span class="line">  // The batch get method maps to HTTP GET verb.</span><br><span class="line">  option (google.api.http) = &#123;</span><br><span class="line">    get: &quot;/v3/events:batchGet&quot;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="用例"><a href="#用例" class="headerlink" title="用例"></a>用例</h2><p>其他一些使用自定义方法可能是正确选择的情况：</p><ul><li><strong>重启虚拟机.</strong> 设计备选方案可能是“重新启动收集重新引导资源”，其感觉不成比例地复杂，或者“虚拟机具有客户端可以从RUNNING更新到RESTARTING”的可变状态，这将打开关于哪些其他状态转换是可能的问题。 此外，重新启动是一个众所周知的概念，可以很好地转换为直观满足开发人员期望的自定义方法。</li><li><strong>邮件发送.</strong> 创建电子邮件不一定会发送（可以暂存于草稿）。 与设计的替代方案（将消息移动到“发件箱”集合）相比，自定义方法具有API用户更易于发现的优点，并更直接地模拟概念。</li><li><strong>激励员工.</strong> 如果实现是一个标准更新，客户端将不得不复制管理激励过程的公司政策，以确保激励在相同的职业阶梯中发生正确的水平。</li><li><strong>批量方法.</strong> 对于性能关键方法，提供自定义批处理方法以减少每个请求开销可能是有用的。 例如，<code>accounts.locations.batchGet</code>。</li></ul><p>标准方法比自定义方法更合适的几个例子：</p><ul><li>使用不同的查询参数查询资源（使用标准<code>list</code>过滤的标准列表方法）。</li><li>简单的资源属性更改（使用具有字段掩码的标准<code>update</code>方法）。</li><li>关闭通知（使用标准<code>delete</code>方法）。</li></ul><h2 id="通用的自定义方法"><a href="#通用的自定义方法" class="headerlink" title="通用的自定义方法"></a>通用的自定义方法</h2><p>常用或有用的自定义方法名称的策略列表如下。 API设计人员在引入自己的API之前应该考虑这些名称，以便于跨API的一致性。</p><table><thead><tr><th>方法名称</th><th>自定义谓语</th><th>HTTP 谓语</th><th>注释</th></tr></thead><tbody><tr><td>Cancel</td><td><code>:cancel</code></td><td><code>POST</code></td><td>取消未完成的操作（构建，计算等）。</td></tr><tr><td>BatchGet<plural noun=""></plural></td><td><code>:batchGet</code></td><td><code>GET</code></td><td>批量获取多个资源。 （详见列表的说明）</td></tr><tr><td>Move</td><td><code>:move</code></td><td><code>POST</code></td><td>将资源从一个父项移动到另一个父项。</td></tr><tr><td>Search</td><td><code>:search</code></td><td><code>GET</code></td><td>用于获取不符合List语义的数据的List的替代方法。</td></tr><tr><td>Undelete</td><td><code>:undelete</code></td><td><code>POST</code></td><td>还原以前删除的资源。 推荐的保留期为30天。</td></tr></tbody></table><h1 id="标准字段"><a href="#标准字段" class="headerlink" title="标准字段"></a>标准字段</h1><p>本节介绍在需要类似概念时应使用的一组标准消息字段定义。 这将确保相同的概念在不同的API中具有相同的名称和语义。</p><table><thead><tr><th>名称</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td><code>name</code></td><td><code>string</code></td><td><code>name</code> 字段应包含相对资源名称。</td></tr><tr><td><code>parent</code></td><td><code>string</code></td><td>对于资源定义和<code>List</code>/<code>Create</code>请求，<code>parent</code>字段应包含父相对资源名称。</td></tr><tr><td><code>create_time</code></td><td><a href="https://github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto" target="_blank" rel="noopener"><code>Timestamp</code></a></td><td>实体的创建时间戳。</td></tr><tr><td><code>update_time</code></td><td><a href="https://github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto" target="_blank" rel="noopener"><code>Timestamp</code></a></td><td>实体的最后更新时间戳。 注意：执行<code>create</code>/ <code>patch</code> /<code>delete</code>操作时<code>update_time</code>被更新。</td></tr><tr><td><code>delete_time</code></td><td><a href="https://github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto" target="_blank" rel="noopener"><code>Timestamp</code></a></td><td>实体的删除时间戳记，只有当它支持保留时。</td></tr><tr><td><code>time_zone</code></td><td><code>string</code></td><td>时区名称。 它应该是IANA TZ名称，例如“America / Los_Angeles”。 有关详细信息，请参阅<a href="https://en.wikipedia.org/wiki/List_of_tz_database_time_zones" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/List_of_tz_database_time_zones</a>。</td></tr><tr><td><code>region_code</code></td><td><code>string</code></td><td>位置的Unicode国家/地区代码（CLDR），例如“US”和“419”。 有关详细信息，请参阅<a href="http://www.unicode.org/reports/tr35/#unicode_region_subtag" target="_blank" rel="noopener">http://www.unicode.org/reports/tr35/#unicode_region_subtag</a>。</td></tr><tr><td><code>language_code</code></td><td><code>string</code></td><td>BCP-47语言代码，如“en-US”或“sr-Latn”。 有关详细信息，请参阅<a href="http://www.unicode.org/reports/tr35/#Unicode_locale_identifier" target="_blank" rel="noopener">http://www.unicode.org/reports/tr35/#Unicode_locale_identifier</a>。</td></tr><tr><td><code>display_name</code></td><td><code>string</code></td><td>实体的显示名称。</td></tr><tr><td><code>title</code></td><td><code>string</code></td><td>实体的正式名称，如公司名称。 它应该被视为<code>display_name</code>的正式版本。</td></tr><tr><td><code>description</code></td><td><code>string</code></td><td>实体的一个或多个文本描述段落。</td></tr><tr><td><code>filter</code></td><td><code>string</code></td><td>List方法的标准过滤器参数。</td></tr><tr><td><code>query</code></td><td><code>string</code></td><td>如果应用于搜索方法（即：搜索），则与<code>filter</code>相同(ie <a href="https://cloud.google.com/apis/design/custom_methods#common_custom_methods" target="_blank" rel="noopener"><code>:search</code></a>)</td></tr><tr><td><code>page_token</code></td><td><code>string</code></td><td>列表请求中的分页令牌。</td></tr><tr><td><code>page_size</code></td><td><code>int32</code></td><td>列表请求中的分页大小。</td></tr><tr><td><code>total_size</code></td><td><code>int32</code></td><td>列表中的项目总数，不管分页。</td></tr><tr><td><code>next_page_token</code></td><td><code>string</code></td><td>List响应中的下一个分页令牌。 它应该用作<code>page_token</code>作为以下请求。 一个空值意味着没有更多的结果。</td></tr><tr><td><code>order_by</code></td><td><code>string</code></td><td>指定列表请求的结果顺序。</td></tr><tr><td><code>request_id</code></td><td><code>string</code></td><td>用于检测重复请求的唯一字符串ID。</td></tr><tr><td><code>resume_token</code></td><td><code>string</code></td><td>用于恢复流请求的不透明令牌。</td></tr><tr><td><code>labels</code></td><td><code>map&lt;string,string&gt;</code></td><td>表示云资源标签。</td></tr><tr><td><code>deleted</code></td><td><code>bool</code></td><td>如果一个资源允许取消删除行为，它必须有一个已<code>deleted</code>的字段，指示资源被删除。</td></tr><tr><td><code>show_deleted</code></td><td><code>bool</code></td><td>如果资源允许取消删除行为，则相应的列表方法必须具有<code>show_deleted</code>字段，以便客户端可以发现已删除的资源。</td></tr><tr><td><code>update_mask</code></td><td><a href="https://github.com/google/protobuf/blob/master/src/google/protobuf/field_mask.proto" target="_blank" rel="noopener"><code>FieldMask</code></a></td><td>它用于<code>Update</code>请求消息，用于对资源执行部分更新。</td></tr><tr><td><code>validate_only</code></td><td><code>bool</code></td><td>如果为true，表示给定的请求只能被验证，而不是执行。</td></tr></tbody></table><h1 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h1><p>本章概述了Google API错误模型以及开发人员如何正确生成和处理错误的一般指导。</p><p>Google API使用简单的协议无关错误模型，可让我们在不同的API，API协议（如gRPC或HTTP）以及错误上下文（例如异步，批处理或工作流错误）中公开一致的体验。</p><h2 id="错误模型"><a href="#错误模型" class="headerlink" title="错误模型"></a>错误模型</h2><p>错误模型由<code>google.rpc.Status</code>在逻辑上定义，当发生API错误时，它的一个实例返回给客户端。 以下代码片段显示了错误模型的总体设计：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package google.rpc;</span><br><span class="line"></span><br><span class="line">message Status &#123;</span><br><span class="line">  // A simple error code that can be easily handled by the client. The</span><br><span class="line">  // actual error code is defined by `google.rpc.Code`.</span><br><span class="line">  int32 code = 1;</span><br><span class="line"></span><br><span class="line">  // A developer-facing human-readable error message in English. It should</span><br><span class="line">  // both explain the error and offer an actionable resolution to it.</span><br><span class="line">  string message = 2;</span><br><span class="line"></span><br><span class="line">  // Additional error information that the client code can use to handle</span><br><span class="line">  // the error, such as retry delay or a help link.</span><br><span class="line">  repeated google.protobuf.Any details = 3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于大多数Google API都使用面向资源的API设计，所以错误处理遵循相同的设计原则，通过使用一小批具有大量资源的标准错误。 例如，服务器不是定义不同种类的“未找到”错误，而是使用一个标准的<code>google.rpc.Code.NOT_FOUND</code>错误代码，告诉客户端没有找到哪个特定的资源。 较小的状态空间减少了文档的复杂性，在客户端库中提供了更好的惯用映射，并降低了客户端逻辑复杂性，同时不限制包含可操作信息。</p><h2 id="错误码"><a href="#错误码" class="headerlink" title="错误码"></a>错误码</h2><p>Google API必须使用<code>google.rpc.Code</code>定义的规范错误代码。 单独的API应避免定义其他错误代码，因为开发人员不太可能编写逻辑来处理大量的错误代码。 作为参考，每个API调用平均处理3个错误代码意味着大多数应用程序逻辑只是用于错误处理，这不是一个好的开发者体验。</p><h2 id="错误消息"><a href="#错误消息" class="headerlink" title="错误消息"></a>错误消息</h2><p>错误消息可以帮助用户轻松快速地了解和解决API错误。 一般来说，在编写错误消息时，请考虑以下准则：</p><ul><li>不要以为用户是API的专家用户。 用户可以是客户开发人员，操作人员，IT人员或应用程序的最终用户。</li><li>不要以为用户了解您的服务实现或熟悉错误的上下文（如日志分析）。</li><li>如果可能，应构建错误消息，以便技术用户（但不一定是API的开发人员）可以对错误进行响应并进行更正。</li><li>保留错误消息简短。 如果需要，请提供一个链接，让困惑的读者可以提出问题，提供反馈或获取不完全符合错误信息的更多信息。 否则，使用详细信息字段来展开。</li></ul><h2 id="错误详情"><a href="#错误详情" class="headerlink" title="错误详情"></a>错误详情</h2><p>Google API为错误详细信息定义了一组标准错误有效载荷，您可以在<a href="https://github.com/googleapis/googleapis/blob/master/google/rpc/error_details.proto" target="_blank" rel="noopener">google/rpc/error_details.proto</a>中找到。这些涵盖了API错误最常见的需求，例如配额失败和无效参数。像错误代码一样，错误细节应尽可能使用这些标准有效载荷。</p><p>只有在可以帮助应用程序代码来处理错误的情况下，才应引入附加的错误详细信息类型。如果错误信息只能由人类处理，请依赖于错误消息内容，让开发人员手动处理错误信息，而不是引入新的错误详细信息类型。请注意，如果引入了其他错误详细信息类型，则必须明确注册它们。</p><p>以下是一些示例<code>error_details</code>的有效载荷：</p><ul><li><code>RetryInfo</code>描述当客户端可以重试失败的请求时，可能会在<code>Code.UNAVAILABLE</code>或<code>Code.ABORTED</code>上返回</li><li><code>QuotaFailure</code>描述配额检查如何失败，可能会在<code>Code.RESOURCE_EXHAUSTED</code>上返回</li><li><code>BadRequest</code>描述客户端请求中的违规行为，可以在<code>Code.INVALID_ARGUMENT</code>上返回</li></ul><h2 id="HTTP映射"><a href="#HTTP映射" class="headerlink" title="HTTP映射"></a>HTTP映射</h2><p>虽然proto3消息具有本地化的JSON编码，但Google的API平台使用以下JSON表示形式进行直接的HTTP-JSON错误响应，以允许向后兼容性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;error&quot;: &#123;</span><br><span class="line">    &quot;code&quot;: 401,</span><br><span class="line">    &quot;message&quot;: &quot;Request had invalid credentials.&quot;,</span><br><span class="line">    &quot;status&quot;: &quot;UNAUTHENTICATED&quot;,</span><br><span class="line">    &quot;details&quot;: [&#123;</span><br><span class="line">      &quot;@type&quot;: &quot;type.googleapis.com/google.rpc.RetryInfo&quot;,</span><br><span class="line">      ...</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>字段</th><th>描述</th></tr></thead><tbody><tr><td><code>error</code></td><td>额外的层面是为了向后兼容Google API客户端库。 它还使JSON表示对人类更加可读。</td></tr><tr><td><code>code</code></td><td><code>Status.code</code>的HTTP状态代码映射</td></tr><tr><td><code>message</code></td><td>对应 <code>Status.message</code></td></tr><tr><td><code>status</code></td><td>对应 <code>Status.code</code></td></tr><tr><td><code>details</code></td><td>对应 <code>Status.details</code></td></tr></tbody></table><h2 id="RPC映射"><a href="#RPC映射" class="headerlink" title="RPC映射"></a>RPC映射</h2><p>不同的RPC协议以不同的方式映射错误模型。 对于<code>gRPC</code>，错误模型由生成的代码和每种支持的语言的运行时库本机支持。 您可以在gRPC的API文档中找到更多内容（例如，请参阅gRPC Java的<code>io.grpc.Status</code>）。</p><h2 id="客户端库映射"><a href="#客户端库映射" class="headerlink" title="客户端库映射"></a>客户端库映射</h2><p>Google客户端库可能会选择以不同的语言来表现错误，以符合既定习惯。 例如，<code>google-cloud-go</code>库将返回一个实现与<code>google.rpc.Status</code>相同的界面的错误，而<code>google-cloud-java</code>会引发一个异常。</p><h2 id="本地化错误提示"><a href="#本地化错误提示" class="headerlink" title="本地化错误提示"></a>本地化错误提示</h2><p><code>google.rpc.Status</code>中的<code>message</code>字段是面向开发人员的，必须是英文。</p><p>如果需要面向用户的错误消息，请使用<code>google.rpc.LocalizedMessage</code>作为您的详细信息字段。 虽然<code>google.rpc.LocalizedMessage</code>中的邮件字段可以进行本地化，但请确保<code>google.rpc.Status</code>中的邮件字段为英文。</p><p>默认情况下，API服务应使用经过身份验证的用户的区域设置或HTTP <code>Accept-Language</code>标头来确定本地化的语言。</p><h2 id="错误处理机制"><a href="#错误处理机制" class="headerlink" title="错误处理机制"></a>错误处理机制</h2><p>以下是包含<code>google.rpc.Code</code>中定义的所有gRPC错误代码的表格，以及其原因的简短说明。 要处理错误，您可以检查返回的状态代码的描述，并相应地修改您的呼叫。</p><table><thead><tr><th>HTTP</th><th>RPC</th><th>描述</th></tr></thead><tbody><tr><td>200</td><td><code>OK</code></td><td>正常.</td></tr><tr><td>400</td><td><code>INVALID_ARGUMENT</code></td><td>客户端指定了无效参数，检查错误信息和错误详细信息以获取更多信息。</td></tr><tr><td>400</td><td><code>FAILED_PRECONDITION</code></td><td>请求无法在当前系统状态下执行，如删除非空目录。</td></tr><tr><td>400</td><td><code>OUT_OF_RANGE</code></td><td>过界，客户端需要指明无效范围。</td></tr><tr><td>401</td><td><code>UNAUTHENTICATED</code></td><td>由于缺失、无效或过期的OAuth token，请求未通过身份验证。</td></tr><tr><td>403</td><td><code>PERMISSION_DENIED</code></td><td>客户端没有足够的权限。这可能是因为OAuth token没有正确的范围，客户端没有权限，还没有为客户端项目启用API。</td></tr><tr><td>404</td><td><code>NOT_FOUND</code></td><td>指定资源没有被发现，或者该请求被未公开的原因拒绝，例如白名单。</td></tr><tr><td>409</td><td><code>ABORTED</code></td><td>并发冲突，如读 - 修改 - 写冲突。</td></tr><tr><td>409</td><td><code>ALREADY_EXISTS</code></td><td>客户端尝试创建的资源已经存在。</td></tr><tr><td>429</td><td><code>RESOURCE_EXHAUSTED</code></td><td>资源配额或者达到限制速率，客户端应该查找google.rpc.QuotaFailure错误详细信息以获取更多信息。</td></tr><tr><td>499</td><td><code>CANCELLED</code></td><td>请求被客户取消。</td></tr><tr><td>500</td><td><code>DATA_LOSS</code></td><td>不可恢复的数据丢失或数据损坏。 客户端应该向用户报告错误。</td></tr><tr><td>500</td><td><code>UNKNOWN</code></td><td>未知的服务器错误。 通常是服务器错误。</td></tr><tr><td>500</td><td><code>INTERNAL</code></td><td>内部服务器错误。 通常是服务器错误。</td></tr><tr><td>501</td><td><code>NOT_IMPLEMENTED</code></td><td>API方法未由服务器实现。</td></tr><tr><td>503</td><td><code>UNAVAILABLE</code></td><td>服务不可用，一般是服务器宕机所致。</td></tr><tr><td>504</td><td><code>DEADLINE_EXCEEDED</code></td><td>请求超期，如果重复发生，请考虑减少请求的复杂性。</td></tr></tbody></table><h3 id="错误重试"><a href="#错误重试" class="headerlink" title="错误重试"></a>错误重试</h3><p>客户端应该重新尝试500、503和504的错误，并使用指数级的恢复。 最小延迟应为1秒，除非另有说明。对于429错误，客户端可能会重试至少30秒的延迟。 对于所有其他错误，重试可能不适用 - 首先确保您的请求是幂等的，并查看错误消息以获得指导。</p><h3 id="错误传播"><a href="#错误传播" class="headerlink" title="错误传播"></a>错误传播</h3><p>如果您的API服务依赖于其他服务，则不应盲目地将这些服务中的错误传播给您的客户。 翻译错误时，我们建议如下：</p><ul><li>隐藏实施细节和机密信息。</li><li>调整对错误负责的一方。 例如，从其他服务接收INVALID_ARGUMENT错误的服务器应将INTERNAL传播到自己的调用者。</li></ul><h2 id="如何生成错误提示"><a href="#如何生成错误提示" class="headerlink" title="如何生成错误提示"></a>如何生成错误提示</h2><p>如果您是服务器开发人员，您应该产生足够的信息来帮助客户开发人员了解并解决问题。 同时，您必须了解用户数据的安全性和隐私性，并避免在错误消息和错误详细信息中披露敏感信息，因为错误经常被记录并可能被其他人访问。 例如，诸如“客户端IP地址不在白名单128.0.0.0/8”之类的错误消息暴露了有关服务器端策略的信息，用户可能无法访问这些信息。</p><p>为了产生正确的错误，您首先需要熟悉google.rpc.Code，为每个错误条件选择最合适的错误代码。 服务器应用程序可以并行检查多个错误条件，并返回第一个。</p><p>下表列出了每个错误代码和一个良好的错误消息的示例。</p><table><thead><tr><th>HTTP</th><th>RPC</th><th>Example Error Message</th></tr></thead><tbody><tr><td>400</td><td><code>INVALID_ARGUMENT</code></td><td>Request field x.y.z is xxx, expected one of [yyy, zzz].</td></tr><tr><td>400</td><td><code>FAILED_PRECONDITION</code></td><td>Resource xxx is a non-empty directory, so it cannot be deleted.</td></tr><tr><td>400</td><td><code>OUT_OF_RANGE</code></td><td>Parameter ‘age’ is out of range [0, 125].</td></tr><tr><td>401</td><td><code>UNAUTHENTICATED</code></td><td>Invalid authentication credentials.</td></tr><tr><td>403</td><td><code>PERMISSION_DENIED</code></td><td>Permission ‘xxx’ denied on file ‘yyy’.</td></tr><tr><td>404</td><td><code>NOT_FOUND</code></td><td>Resource ‘xxx’ not found.</td></tr><tr><td>409</td><td><code>ABORTED</code></td><td>Couldn’t acquire lock on resource ‘xxx’.</td></tr><tr><td>409</td><td><code>ALREADY_EXISTS</code></td><td>Resource ‘xxx’ already exists.</td></tr><tr><td>429</td><td><code>RESOURCE_EXHAUSTED</code></td><td>Quota limit ‘xxx’ exceeded.</td></tr><tr><td>499</td><td><code>CANCELLED</code></td><td>Request cancelled by the client.</td></tr><tr><td>500</td><td><code>DATA_LOSS</code></td><td>See note.</td></tr><tr><td>500</td><td><code>UNKNOWN</code></td><td>See note.</td></tr><tr><td>500</td><td><code>INTERNAL</code></td><td>See note.</td></tr><tr><td>501</td><td><code>NOT_IMPLEMENTED</code></td><td>Method ‘xxx’ not implemented.</td></tr><tr><td>503</td><td><code>UNAVAILABLE</code></td><td>See note.</td></tr><tr><td>504</td><td><code>DEADLINE_EXCEEDED</code></td><td>See note.</td></tr></tbody></table><p><strong>NOTE</strong>:由于客户端无法修复服务器错误，因此无法生成其他错误详细信息。 为了避免在错误条件下泄漏敏感信息，建议不要生成任何错误消息，只生成<code>google.rpc.DebugInfo</code>错误详细信息。 <code>DebugInfo</code>是专门为服务器端日志记录而设计的，不能发送给客户端。</p><p><code>google.rpc</code>软件包定义了一组标准错误有效载荷，它们优先于自定义错误有效载荷。 下表列出了每个错误代码及其匹配的标准错误有效载荷（如果适用）。</p><table><thead><tr><th>HTTP</th><th>RPC</th><th>Recommended Error Detail</th></tr></thead><tbody><tr><td>400</td><td><code>INVALID_ARGUMENT</code></td><td><code>google.rpc.BadRequest</code></td></tr><tr><td>400</td><td><code>FAILED_PRECONDITION</code></td><td><code>google.rpc.PreconditionFailure</code></td></tr><tr><td>400</td><td><code>OUT_OF_RANGE</code></td><td><code>google.rpc.BadRequest</code></td></tr><tr><td>401</td><td><code>UNAUTHENTICATED</code></td><td></td></tr><tr><td>403</td><td><code>PERMISSION_DENIED</code></td><td></td></tr><tr><td>404</td><td><code>NOT_FOUND</code></td><td><code>google.rpc.ResourceInfo</code></td></tr><tr><td>409</td><td><code>ABORTED</code></td><td></td></tr><tr><td>409</td><td><code>ALREADY_EXISTS</code></td><td><code>google.rpc.ResourceInfo</code></td></tr><tr><td>429</td><td><code>RESOURCE_EXHAUSTED</code></td><td><code>google.rpc.QuotaFailure</code></td></tr><tr><td>499</td><td><code>CANCELLED</code></td><td></td></tr><tr><td>500</td><td><code>DATA_LOSS</code></td><td></td></tr><tr><td>500</td><td><code>UNKNOWN</code></td><td></td></tr><tr><td>500</td><td><code>INTERNAL</code></td><td></td></tr><tr><td>501</td><td><code>NOT_IMPLEMENTED</code></td><td></td></tr><tr><td>503</td><td><code>UNAVAILABLE</code></td><td></td></tr><tr><td>504</td><td><code>DEADLINE_EXCEEDED</code></td></tr></tbody></table><h1 id="命名约定"><a href="#命名约定" class="headerlink" title="命名约定"></a>命名约定</h1><p>为了在许多API和长时间内提供一致的开发人员体验，API使用的所有名称应为：</p><ul><li>简单</li><li>直觉</li><li>一致</li></ul><p>这包括接口，资源，集合，方法和消息的名称。</p><p>由于许多开发人员不是英文母语人士，因此这些命名约定的目标之一是确保大多数开发人员能够轻松了解API。 它通过鼓励在命名方法和资源时使用简单，一致和小的词汇表来实现。</p><ul><li>API中使用的名称应该是正确的美国英语。例如，license（而不是licence），color（而不是colour）。</li><li>可以简单地使用常用的简短形式或长字的缩写。例如，API优于应用程序编程接口。</li><li>尽可能使用直观，熟悉的术语。例如，当描述删除（和销毁）资源时，删除是优先于擦除。</li><li>对同一概念使用相同的名称或术语，包括跨API共享的概念。</li><li>避免名称重载。为不同的概念使用不同的名称。</li><li>避免在API和Google API的更大生态系统的上下文中含有不明确的通用名称。他们可能会导致对API概念的误解。相反，请选择准确描述API概念的特定名称。这对于定义一阶API元素（例如资源）的名称尤其重要。没有明确的名称列表来避免，因为每个名字都必须在其他名称的上下文中进行评估。实例，信息和服务是过去有问题的名称的示例。所选择的名称应该清楚地描述API概念（例如：什么的实例），并将其与其他相关概念区分开（例如：“alert”是指规则，信号还是通知？）。</li><li>仔细考虑使用可能与常用编程语言中的关键字冲突的名称。可以使用这些名称，但在API审查期间可能会触发额外的审查。谨慎和谨慎地使用它们。</li></ul><h2 id="产品名称"><a href="#产品名称" class="headerlink" title="产品名称"></a>产品名称</h2><p>产品名称指的是API的产品营销名称，如<em>Google Calendar API</em>。 API，UI，文档，服务条款，结算单，商业合同等一贯使用产品名称。</p><p>Google API必须使用从Google开始的产品名称，除非它们以不同的品牌提供，例如Gmail，Nest，YouTube。 一般来说，产品名称应由产品和营销团队决定。</p><p>下表显示了所有相关API名称及其一致性的示例。 有关各自名称及其约定的更多详细信息，请参阅本页面。</p><table><thead><tr><th>API Name</th><th>Example</th></tr></thead><tbody><tr><td><strong>Product Name</strong></td><td>Google <strong>Calendar</strong> API</td></tr><tr><td><strong>Service Name</strong></td><td><code>calendar.googleapis.com</code></td></tr><tr><td><strong>Package Name</strong></td><td><code>google.calendar.v3</code></td></tr><tr><td><strong>Interface Name</strong></td><td><code>google.calendar.v3.CalendarService</code></td></tr><tr><td><strong>Source Directory</strong></td><td><code>//google/calendar/v3</code></td></tr><tr><td><strong>API Name</strong></td><td><code>calendar</code></td></tr></tbody></table><h2 id="服务名称"><a href="#服务名称" class="headerlink" title="服务名称"></a>服务名称</h2><p>服务名称应该是可以解析为一个或多个网络地址的语法有效的DNS名称（根据RFC 1035）。 公开Google API的服务名称遵循以下格式：<code>xxx.googleapis.com</code>。 例如，Google日历的服务名称是<code>calendar.googleapis.com</code>。</p><p>如果一个API由几个服务组成，那么它们应该以一种帮助可发现性的方式命名。 一种方法是使服务名称共享公共前缀。 例如，服务<code>build.googleapis.com</code>和<code>buildresults.googleapis.com</code>都是Google Build API的一部分。</p><h2 id="包名称"><a href="#包名称" class="headerlink" title="包名称"></a>包名称</h2><p>在API <code>.proto</code>文件中声明的软件包名称应与产品和服务名称一致。 具有版本的API的软件包名称必须以版本结尾。 例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// Google Calendar API</span><br><span class="line">package google.calendar.v3;</span><br></pre></td></tr></table></figure><p>与Google Watcher API等服务无直接关联的抽象API应使用与产品名称一致的原包名称：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// Google Watcher API</span><br><span class="line">package google.watcher.v1;</span><br></pre></td></tr></table></figure><p>API <code>.proto</code>文件中指定的Java程序包名称必须与标准Java程序包名称前缀（<code>com.</code>，<code>edu.</code>，<code>net.</code>等）的原始程序包名称相匹配。 例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">package google.calendar.v3;</span><br><span class="line"></span><br><span class="line">// Specifies Java package name, using the standard prefix &quot;com.&quot;</span><br><span class="line">option java_package = &quot;com.google.calendar.v3&quot;;</span><br></pre></td></tr></table></figure><h2 id="集合IDs"><a href="#集合IDs" class="headerlink" title="集合IDs"></a>集合IDs</h2><p>集合ID应使用复数形式和<code>lowerCamelCase</code>，以及美式英文拼写和语义。 例如：<code>events</code>，<code>children</code>或<code>deletedEvents</code>。</p><h2 id="接口命名"><a href="#接口命名" class="headerlink" title="接口命名"></a>接口命名</h2><p>为了避免与服务名称（如<code>pubsub.googleapis.com</code>）混淆，术语接口名称是指在<code>.proto</code>文件中定义<code>service</code>时使用的名称：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Library is the interface name.</span><br><span class="line">service Library &#123;</span><br><span class="line">  rpc ListBooks(...) returns (...);</span><br><span class="line">  rpc ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>您可以将服务名称视为对一组API的实际实现的参考，而接口则引用API的抽象定义。</p><p>接口名称应该使用直观的名词，如Calendar或Blob。 该名称不应与编程语言及其运行时库（例如File）中任何已建立的概念冲突。</p><p>在少见的情况下，接口名会与API中的另一个名称冲突，应使用后缀（例如<code>Api</code>或<code>Service</code>）来消除歧义。</p><h2 id="方法命名"><a href="#方法命名" class="headerlink" title="方法命名"></a>方法命名</h2><p>在IDL规范中，服务可以定义一个或多个与集合和资源上的方法相对应的RPC方法。方法名应该遵循上驼峰上的VerbNoun的命名惯例，在这个例子中，名词通常是资源类型。</p><table><thead><tr><th></th><th>名词</th><th>方法名称</th><th>请求消息</th><th>响应消息</th></tr></thead><tbody><tr><td><code>List</code></td><td><code>Book</code></td><td><code>ListBooks</code></td><td><code>ListBooksRequest</code></td><td><code>ListBooksResponse</code></td></tr><tr><td><code>Get</code></td><td><code>Book</code></td><td><code>GetBook</code></td><td><code>GetBookRequest</code></td><td><code>Book</code></td></tr><tr><td><code>Create</code></td><td><code>Book</code></td><td><code>CreateBook</code></td><td><code>CreateBookRequest</code></td><td><code>Book</code></td></tr><tr><td><code>Update</code></td><td><code>Book</code></td><td><code>UpdateBook</code></td><td><code>UpdateBookRequest</code></td><td><code>Book</code></td></tr><tr><td><code>Rename</code></td><td><code>Book</code></td><td><code>RenameBook</code></td><td><code>RenameBookRequest</code></td><td><code>RenameBookResponse</code></td></tr><tr><td><code>Delete</code></td><td><code>Book</code></td><td><code>DeleteBook</code></td><td><code>DeleteBookRequest</code></td><td><code>google.protobuf.Empty</code></td></tr></tbody></table><p>方法名的动词部分应使用命令式语气，即用于要求或命令，而不是用于提问的指示性语气。</p><p>当动词提出关于API中的子资源的问题时，这很容易混淆，这通常以指示性语气表达。 例如，订购API来创建一本书，这显然是<code>CreateBook</code>（强制性语气），但是要求API关于图书发行者的状态可能会使用指示性的语气，例如<code>IsBookPublisherApproved</code>或<code>NeedsPublisherApproval</code>。 要在这样的情况下保持紧张的语气，依靠诸如“check”（<code>CheckBookPublisherApproved</code>）和“validate”（<code>ValidateBookPublisher</code>）等命令。</p><h2 id="消息命名"><a href="#消息命名" class="headerlink" title="消息命名"></a>消息命名</h2><p>RPC方法的请求和响应消息应分别以后缀为Request和Response的方法名命名，除非方法请求或响应类型为：</p><ul><li>一个空信息（使用<code>google.protobuf.Empty</code>），</li><li>资源类型，或</li><li>表示操作的资源</li></ul><p>这通常适用于在标准方法<code>Get</code>, <code>Create</code>, <code>Update</code>, 或 <code>Delete</code>中使用的请求或响应。</p><h2 id="枚举命名"><a href="#枚举命名" class="headerlink" title="枚举命名"></a>枚举命名</h2><p>枚举类型必须使用UpperCamelCase名称。</p><p>枚举值必须使用CAPITALIZED_NAMES_WITH_UNDERSCORES。 每个枚举值必须以分号结尾，而不能以逗号结尾。 第一个值应该命名为ENUM_TYPE_UNSPECIFIED，因为当枚举值未被明确指定时返回。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enum FooBar &#123;</span><br><span class="line">  // The first value represents the default and must be == 0.</span><br><span class="line">  FOO_BAR_UNSPECIFIED = 0;</span><br><span class="line">  FIRST_VALUE = 1;</span><br><span class="line">  SECOND_VALUE = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字段命名"><a href="#字段命名" class="headerlink" title="字段命名"></a>字段命名</h2><p><code>.proto</code>文件中的字段定义必须使用<code>lower_case_underscore_separated_names</code>。 这些名称将映射到每种编程语言的生成代码中的本机命名约定。</p><p>字段名称应避免介词（例如“for”，“during”，“at”），例如：</p><ul><li><code>reason_for_error</code>应该是<code>error_reason</code></li><li><code>cpu_usage_at_time_of_failure</code>应该是<code>fail_time_cpu_usage</code></li></ul><p>字段名称也应避免使用后置正式形容词（名词之后的修饰符），例如：</p><ul><li><code>items_collected</code>应该是<code>collect_items</code></li><li><code>objects_imported</code>应该是<code>import_objects</code></li></ul><h3 id="复数字段的命名"><a href="#复数字段的命名" class="headerlink" title="复数字段的命名"></a>复数字段的命名</h3><p>API中的复数字段必须使用适当的复数形式。 这符合现有Google API的惯例，也是外部开发人员的常用惯例。</p><h3 id="时间和时间段"><a href="#时间和时间段" class="headerlink" title="时间和时间段"></a>时间和时间段</h3><p>为了表示一个时间点独立于任何时区或日历，应该使用<code>google.protobuf.Timestamp</code>，并且字段名称应以<code>time</code></p><p>结尾，如<code>start_time</code>和<code>end_time</code>。</p><p>如果时间是指一个活动，则字段名称应该具有verb_time的形式，如<code>create_time</code>，<code>update_time</code>。 避免使用过去时的动词，如<code>created_time</code>或<code>last_updated_time</code>。</p><p>代表两个时间点之间的时间间隔，与时间无关，如“日”或“月”，应该使用<code>google.protobuf.Duration</code>等概念。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">message FlightRecord &#123;</span><br><span class="line">  google.protobuf.Timestamp takeoff_time = 1;</span><br><span class="line">  google.protobuf.Duration flight_duration = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果由于遗留或兼容性原因（包括挂钟时间，持续时间，推迟和延迟），必须使用整数类型表示与时间相关的字段，则字段名称必须具有以下格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xxx_&#123;time|duration|delay|latency&#125;_&#123;seconds|millis|micros|nanos&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">message Email &#123;</span><br><span class="line">  int64 send_time_millis = 1;</span><br><span class="line">  int64 receive_time_millis = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果您必须使用字符串类型代表传统或兼容性原因的时间戳，则字段名称不应包含任何单位后缀。 字符串表示应使用RFC 3339格式，例如“2014-07-30T10:43:17Z”。</p><h3 id="时间和日期"><a href="#时间和日期" class="headerlink" title="时间和日期"></a>时间和日期</h3><p>对于独立于时区和时间的日期，应使用<code>google.type.Date</code>，并且应该使用后缀<code>_date</code>。 如果日期必须用字符串表示，那么它应该是ISO 8601日期格式YYYY-MM-DD，例如。2014年7月30日。</p><p>对于独立于时区和日期的时间段，应使用<code>google.type.TimeOfDay</code>，并应使用后缀<code>_time</code>。 如果一天中的时间必须以字符串形式表示，那么它应该是ISO 8601 24小时制格式HH:MM:SS [.FFF]，例如。14:55:01.672。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">message StoreOpening &#123;</span><br><span class="line">  google.type.Date opening_date = 1;</span><br><span class="line">  google.type.TimeOfDay opening_time = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数量表示"><a href="#数量表示" class="headerlink" title="数量表示"></a>数量表示</h3><p>以整数类型表示的数量必须包括测量单位。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xxx_&#123;bytes|width_pixels|meters&#125;</span><br></pre></td></tr></table></figure><p>如果数量是许多项，则该字段应该具有后缀<code>_count</code>，例如<code>node_count</code>。</p><h3 id="列表过滤字段"><a href="#列表过滤字段" class="headerlink" title="列表过滤字段"></a>列表过滤字段</h3><p>如果API支持对<code>List</code>方法返回的资源进行过滤，则包含过滤器表达式的字段应该命名为<code>filter</code>。 例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">message ListBooksRequest &#123;</span><br><span class="line">  // The parent resource name.</span><br><span class="line">  string parent = 1;</span><br><span class="line"></span><br><span class="line">  // The filter expression.</span><br><span class="line">  string filter = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="List的响应"><a href="#List的响应" class="headerlink" title="List的响应"></a>List的响应</h3><p>列表方法的响应消息中包含资源 <code>List</code> 的字段名称必须是资源名称本身的复数形式。 例如，一个方法<code>CalendarApi.ListEvents()</code>必须定义一个响应消息<code>ListEventsResponse</code>，其中一个称为<code>events</code>的重复字段用于返回的资源列表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">service CalendarApi &#123;</span><br><span class="line">  rpc ListEvents(ListEventsRequest) returns (ListEventsResponse) &#123;</span><br><span class="line">    option (google.api.http) = &#123;</span><br><span class="line">      get: &quot;/v3/&#123;parent=calendars/*&#125;/events&quot;;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message ListEventsRequest &#123;</span><br><span class="line">  string parent = 1;</span><br><span class="line">  int32 page_size = 2;</span><br><span class="line">  string page_token = 3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message ListEventsResponse &#123;</span><br><span class="line">  repeated Event events = 1;</span><br><span class="line">  string next_page_token = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="驼峰写法"><a href="#驼峰写法" class="headerlink" title="驼峰写法"></a>驼峰写法</h2><p>除了字段名称和枚举值之外，<code>.proto</code>文件中的所有定义都必须使用由<code>Google Java Style</code>定义的大写的驼峰写法名称。</p><h2 id="名称缩写"><a href="#名称缩写" class="headerlink" title="名称缩写"></a>名称缩写</h2><p>对于软件开发人员（如配置和规范）中众所周知的缩写，缩写应用于API定义，而不是完整的拼写。 这将使源代码易于阅读和写入。 在正式文件中，应使用完整的拼写。 例子：</p><ul><li>配置（配置）</li><li>id（标识符）</li><li>规格（规格）</li><li>统计（统计）</li></ul><h1 id="通用设计模式"><a href="#通用设计模式" class="headerlink" title="通用设计模式"></a>通用设计模式</h1><h2 id="空响应"><a href="#空响应" class="headerlink" title="空响应"></a>空响应</h2><p>标准的<code>Delete</code>方法必须返回<code>google.protobuf.Empty</code>才能实现全局一致性。 它还可以防止客户端依赖于重试期间不可用的其他元数据。 对于自定义方法，它们必须具有自己的<code>XxxResponse</code>消息，即使它们是空的，因为它们的功能很可能随着时间的推移而增长，并且需要返回附加数据。</p><h2 id="表示范围"><a href="#表示范围" class="headerlink" title="表示范围"></a>表示范围</h2><p>表示范围的字段应使用具有命名约定[start_xxx，end_xxx]的半开间隔，例如<code>[start_key，end_key]</code>或<code>[start_time，end_time]</code>。 半开间隔语义通常由C ++ STL库和Java标准库使用。 API应避免使用其他方式表示范围，例如<code>(index, count)</code>或 <code>[first, last]</code>。</p><h2 id="资源标签"><a href="#资源标签" class="headerlink" title="资源标签"></a>资源标签</h2><p>在面向资源的API中，资源模式由API定义。 为了让客户端将少量的简单元数据附加到资源（例如，将虚拟机资源标记为数据库服务器），API应使用<code>google.api.LabelDescriptor</code>中描述的资源标签设计模式。</p><p>为此，API设计应该在资源定义中添加一个字段<code>map&lt;string，string&gt;</code>标签。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">message Book &#123;</span><br><span class="line">  string name = 1;</span><br><span class="line">  map&lt;string, string&gt; labels = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="长运行操作"><a href="#长运行操作" class="headerlink" title="长运行操作"></a>长运行操作</h2><p>如果API方法通常需要很长时间才能完成，则可以设计为将长运行操作资源返回给客户端，客户端可以使用该资源来跟踪进度并接收结果。该操作定义了一个标准接口来处理长时间运行的操作。单个API不能为长时间运行的操作定义自己的接口，以避免不一致。</p><p>操作资源必须作为响应消息直接返回，并且操作的任何直接后果应反映在API中。例如，创建资源时，该资源应该出现在LIST和GET方法中，尽管资源应该指示它尚未准备好使用。当操作完成时，如果方法不长时间运行，<code>Operation.response</code>字段应包含直接返回的消息。</p><p>操作可以使用<code>Operation.metadata</code>字段提供有关其进度的信息。即使初始实现不填充<code>metadata</code>字段，API也应该定义该元数据的消息。</p><h2 id="列表分页"><a href="#列表分页" class="headerlink" title="列表分页"></a>列表分页</h2><p>列表形式的集合应该支持分页，即使结果通常很小。</p><p><strong>理由</strong>：尽管添加了对现有API的分页支持纯粹是从API表面的角度来添加的，但这是一种使用方式上的改变，不知道已经转变为分页形式的已有客户端将错误地假设它们收到了完整的列表结果，而它们只接收第一个页面。</p><p>为了在<code>List</code>方法中支持分页（返回列表结果页），API应该遵循以下原则：</p><ul><li>在<code>List</code>方法的请求消息中定义一个<code>page_token</code>字段。客户端使用此字段请求列表结果的指定页面。</li><li>在<code>List</code>方法的请求消息中定义一个<code>int32</code>字段<code>page_size</code>。客户端使用此字段指定要由服务器返回的最大结果数。服务器可以进一步约束在单个页面中返回的最大结果数量。如果<code>page_size</code>为<code>0</code>，则服务器将决定要返回的结果数。</li><li>在<code>List</code>方法的响应消息中定义一个字符串字段<code>next_page_token</code>。此字段表示检索下一页结果的分页令牌。如果值为<code>&quot;&quot;</code>，则表示该请求没有进一步的结果。</li></ul><p>要检索下一页结果，客户端应在随后的<code>List</code>方法调用（请求消息的<code>page_token</code>字段）中传递响应的<code>next_page_token</code>的值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">rpc ListBooks(ListBooksRequest) returns (ListBooksResponse);</span><br><span class="line"></span><br><span class="line">message ListBooksRequest &#123;</span><br><span class="line">  string name = 1;</span><br><span class="line">  int32 page_size = 2;</span><br><span class="line">  string page_token = 3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message ListBooksResponse &#123;</span><br><span class="line">  repeated Book books = 1;</span><br><span class="line">  string next_page_token = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当客户端传递除了页面token之外查询参数时，如果查询参数与页面token不一致，则服务必须对请求失败。</p><p>页面token内容应该是一个网络安全的<code>base64编码协议</code>buffer。 这允许内容发展而没有兼容性问题。 如果页面token包含潜在的敏感信息，则该信息应该被加密。 服务必须防止篡改页面token通过以下方法之一暴露无意的数据：</p><ul><li>需要根据后续请求分配查询参数。</li><li>仅在页面token中引用服务器端会话状态。</li><li>对页面token中的查询参数进行加密和签名，并在每次调用时重新验证和重新授权这些参数。</li></ul><p>分页的实现还可以提供名为<code>total_size</code>的<code>int32</code>字段中的项目总数。</p><h2 id="列表子集合"><a href="#列表子集合" class="headerlink" title="列表子集合"></a>列表子集合</h2><p>有时，一个API需要让一个客户端<code>List/Search</code>跨子集。 例如，图书馆API有一个书架集合，每个书架都有一组书籍，客户想要在所有货架上搜索一本书。 在这种情况下，建议在子集合中使用标准<code>List</code>，并为父集合指定通配符集合<code>&quot;-&quot;</code>。 对于图书馆API示例，我们可以使用以下REST API请求：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET https://library.googleapis.com/v1/shelves/-/books?filter=xxx</span><br></pre></td></tr></table></figure><p>NOTE: 选择<code>&quot;-&quot;</code>而不是<code>&quot;*&quot;</code>的原因是为了避免URL转义的需要。</p><h2 id="从子集获取唯一资源"><a href="#从子集获取唯一资源" class="headerlink" title="从子集获取唯一资源"></a>从子集获取唯一资源</h2><p>有时，子集合中的资源具有在其父集合内是唯一的标识符。 在这种情况下，允许<code>Get</code>在不知道哪个父集合包含它的情况下检索该资源可能是有用的。 在这种情况下，建议使用资源上的标准<code>Get</code>，并为资源唯一的所有父集合指定通配符集合<code>&quot;-&quot;</code>。 例如，在图书馆API中，我们可以使用以下REST API请求，如果该书在所有书架上的所有书籍中都是唯一的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET https://library.googleapis.com/v1/shelves/-/books/&#123;id&#125;</span><br></pre></td></tr></table></figure><p>对此调用的响应中的资源名称必须使用资源的规范名称，每个父集合使用实际的父集合标识符而不是<code>&quot;-&quot;</code>。 例如，上面的请求应该返回一个名为<code>shelves/shelf713/books/book8141</code>，而不是<code>shelves/-/books/book8141</code>的资源。</p><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>如果API方法允许客户端为列表结果指定排序顺序，请求消息应包含一个字段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string order_by = ...;</span><br></pre></td></tr></table></figure><p>字符串值应遵循SQL语法：逗号分隔的字段列表。 例如：<code>&quot;foo,bar&quot;</code>。 默认排序顺序为升序。 要指定字段的降序，后缀<code>&quot;desc&quot;</code>应附加到字段名称。 例如：<code>&quot;foo desc,bar&quot;</code>。</p><p>冗余的空格字符在语法上是微不足道的。 <code>&quot;foo,bar desc&quot;</code>和<code>&quot;foo,bar desc&quot;</code>相当。</p><h2 id="请求验证"><a href="#请求验证" class="headerlink" title="请求验证"></a>请求验证</h2><p>如果API方法有副作用，并且需要验证请求而不引起这种副作用，请求消息应包含一个字段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool validate_only = ...;</span><br></pre></td></tr></table></figure><p>如果这个字段被设置为true，服务器就不能执行任何副作用，并且只执行与完整请求一致的特定于实现的验证。</p><p>如果验证成功，则必须返回<code>google.rpc.Code.OK</code>，并且使用相同请求消息的任何完整请求不应返回<code>google.rpc.Code.INVALID_ARGUMENT</code>。 请注意，由于其他错误（如<code>google.rpc.Code.ALREADY_EXISTS</code>）或由于竞争条件，请求可能仍然失败。</p><h2 id="请求幂等"><a href="#请求幂等" class="headerlink" title="请求幂等"></a>请求幂等</h2><p>对于网络API，特权API方法是非常优先的，因为它们可以在网络故障后安全地重试。 然而，一些API方法不能轻易地是幂等的，例如创建资源，并且需要避免不必要的重复。 对于这种用例，请求消息应包含一个唯一的ID，如UUID，服务器将使用它来检测重复，并确保只处理该请求一次。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// A unique request ID for server to detect duplicated requests.</span><br><span class="line">// This field **should** be named as `request_id`.</span><br><span class="line">string request_id = ...;</span><br></pre></td></tr></table></figure><p>如果检测到重复请求，则服务器应返回以前成功请求的响应，因为客户端很可能没有收到先前的响应。</p><h2 id="枚举默认值"><a href="#枚举默认值" class="headerlink" title="枚举默认值"></a>枚举默认值</h2><p>每个枚举定义必须以<code>0</code>值条目开始，当没有明确指定枚举值时，它将被使用。 API必须记录如何处理<code>0</code>值。</p><p>如果有一个常见的默认行为，那么应该使用枚举值<code>0</code>，并且API应该记录预期的行为。</p><p>如果没有常见的默认行为，则枚举值<code>0</code>应该命名为<code>ENUM_TYPE_UNSPECIFIED</code>，并且在使用时应该被拒绝，错误为<code>INVALID_ARGUMENT</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">enum Isolation &#123;</span><br><span class="line">  // Not specified.</span><br><span class="line">  ISOLATION_UNSPECIFIED = 0;</span><br><span class="line">  // Reads from a snapshot. Collisions occur if all reads and writes cannot be</span><br><span class="line">  // logically serialized with concurrent transactions.</span><br><span class="line">  SERIALIZABLE = 1;</span><br><span class="line">  // Reads from a snapshot. Collisions occur if concurrent transactions write</span><br><span class="line">  // to the same rows.</span><br><span class="line">  SNAPSHOT = 2;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// When unspecified, the server will use an isolation level of SNAPSHOT or</span><br><span class="line">// better.</span><br><span class="line">Isolation level = 1;</span><br></pre></td></tr></table></figure><p>An idiomatic name <strong>may</strong> be used for the <code>0</code> value. For example, <code>google.rpc.Code.OK</code> is the idiomatic way of specifying the absence of an error code. In this case, <code>OK</code> is semantically equivalent to <code>UNSPECIFIED</code> in the context of the enum type.</p><p>In cases where an intrinsically sensible and safe default exists, that value <strong>may</strong> be used for the ‘0’ value. For example, <code>BASIC</code> is the ‘0’ value in the <a href="https://cloud.google.com/apis/design/design_patterns#resource_view" target="_blank" rel="noopener">Resource View</a> enum.</p><p>一个惯用名称可以用于<code>0</code>值。 例如，<code>google.rpc.Code.OK</code>是指定缺少错误代码的惯用方式。 在这种情况下，<code>OK</code>在语义上类似于<code>UNSPECIFIED</code>。</p><p>在存在内在敏感和安全默认值的情况下，该值可用于<code>&#39;0&#39;</code>值。 例如，<code>BASIC</code>是<code>Resource View</code>枚举中的<code>&#39;0&#39;</code>值。</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>在某些API设计中，有必要为某些数据格式定义简单的语法，例如可接受的文本输入。 为了在API之间提供一致的开发人员体验并减少学习曲线，API设计人员必须使用ISO 14977 Extended Backus-Naur Form（EBNF）语法来定义此类语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Production  = name &quot;=&quot; [ Expression ] &quot;;&quot; ;</span><br><span class="line">Expression  = Alternative &#123; &quot;|&quot; Alternative &#125; ;</span><br><span class="line">Alternative = Term &#123; Term &#125; ;</span><br><span class="line">Term        = name | TOKEN | Group | Option | Repetition ;</span><br><span class="line">Group       = &quot;(&quot; Expression &quot;)&quot; ;</span><br><span class="line">Option      = &quot;[&quot; Expression &quot;]&quot; ;</span><br><span class="line">Repetition  = &quot;&#123;&quot; Expression &quot;&#125;&quot; ;</span><br></pre></td></tr></table></figure><p>NOTE: <code>TOKEN</code> 表示在语法之外定义的终端。</p><h2 id="整形类型"><a href="#整形类型" class="headerlink" title="整形类型"></a>整形类型</h2><p>在API设计中，不应使用无符号整数类型，例如<code>uint32</code>和<code>fixed32</code>，因为一些重要的编程语言和系统不能很好地支持它们，例如Java，JavaScript和OpenAPI。 而且它们更有可能导致溢出错误。 另一个问题是，不同的API很可能对同一件事情使用不匹配的有符号和无符号类型。</p><p>当带符号的整数类型用于负值不重要的事物（如大小或超时）时，值<code>-1</code>（且仅为<code>-1</code>）可用于指示特殊含义，例如文件结尾（EOF），无限大 超时，无限制配额限制或未知年龄。 必须清楚记录这些用法以避免混淆。 如果API生成器不是非常明显的话，API生成器还应记录隐式默认值<code>0</code>的行为。</p><h2 id="子集响应"><a href="#子集响应" class="headerlink" title="子集响应"></a>子集响应</h2><p>有时API客户端只需要响应消息中的特定数据子集。 为了支持这种用例，一些API平台为部分响应提供本地支持。 Google API Platform通过响应字段掩码支持它。 对于任何REST API调用，都有一个隐式的系统查询参数<code>$ fields</code>，它是一个<code>google.protobuf.FieldMask</code>值的JSON表示形式。 响应消息将被发送回客户端之前被<code>$fields</code>过滤。 API平台为所有API方法自动处理此逻辑。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET https://library.googleapis.com/v1/shelves?$fields=name</span><br></pre></td></tr></table></figure><h2 id="资源视图"><a href="#资源视图" class="headerlink" title="资源视图"></a>资源视图</h2><p>为了减少网络流量，允许客户端限制服务器在其响应中返回的资源的哪些部分是有用的，返回资源的视图，而不是完整的资源表示。 通过向方法请求中添加参数来实现API中的资源视图支持，该参数允许客户端在响应中指定要接收的资源的哪个视图。</p><p>参数：</p><ul><li>应该是枚举类型</li><li>必须命名视图</li></ul><p>枚举的每个值定义资源的哪些部分（哪些字段）将在服务器的响应中返回。 正是为每个视图值返回的值是实现定义的，应在API文档中指定。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package google.example.library.v1;</span><br><span class="line"></span><br><span class="line">service Library &#123;</span><br><span class="line">  rpc ListBooks(ListBooksRequest) returns (ListBooksResponse) &#123;</span><br><span class="line">    option (google.api.http) = &#123;</span><br><span class="line">      get: &quot;/v1/&#123;name=shelves/*&#125;/books&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">enum BookView &#123;</span><br><span class="line">  // 服务器响应只包括作者，标题，ISBN和独特的书籍ID。</span><br><span class="line">  // The default value.</span><br><span class="line">  BASIC = 0;</span><br><span class="line"></span><br><span class="line">  // 本书的完整表示在服务器响应中返回，</span><br><span class="line">  // 包括书的内容。</span><br><span class="line">  FULL = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message ListBooksRequest &#123;</span><br><span class="line">  string name = 1;</span><br><span class="line"></span><br><span class="line">  // 指定应该返回图书资源的哪些部分</span><br><span class="line">  BookView view = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This construct will be mapped to URLs such as:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET https://library.googleapis.com/v1/shelves/shelf1/books?view=BASIC</span><br></pre></td></tr></table></figure><p>You can find out more about defining methods, requests, and responses in the <a href="https://cloud.google.com/apis/design/standard_methods" target="_blank" rel="noopener">Standard Methods</a> chapter of this Design Guide.</p><h2 id="ETags"><a href="#ETags" class="headerlink" title="ETags"></a>ETags</h2><p>ETag是一个不透明的标识符，允许客户端进行条件请求。 为了支持ETag，API应在资源定义中包含一个字符串字段<code>etag</code>，其语义必须与ETag的常用用法相匹配。 通常，<code>etag</code>包含由服务器计算的资源的指纹。 有关详细信息，请参阅维基百科和RFC 7232。</p><p>ETags可以强或弱验证，其中弱验证的ETag以W /为前缀。 在这种情况下，强验证意味着具有相同ETag的两个资源具有字节/字节相同的内容和相同的额外字段（即Content-Type）。 这意味着强烈验证的ETag允许缓存部分响应，以便稍后进行组合。</p><p>相反，具有相同弱验证的ETag值的资源意味着表示在语义上是等效的，但不一定是字节的字节相同，因此不适合于字节范围请求的响应缓存。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// This is a strong ETag, including the quotes.</span><br><span class="line">&quot;1a2f3e4d5b6c7c&quot;</span><br><span class="line">// This is a weak ETag, including the prefix and quotes.</span><br><span class="line">W/&quot;1a2b3c4d5ef&quot;</span><br></pre></td></tr></table></figure><h2 id="输出字段"><a href="#输出字段" class="headerlink" title="输出字段"></a>输出字段</h2><p>API可能希望区分由客户端提供的字段作为输入和仅在服务器上在特定资源的输出上返回的字段。 对于仅输出的字段，必须记录字段属性。</p><p>请注意，如果客户端在请求中设置了仅输出字段，或者客户端指定了仅输出域的<code>google.protobuf.FieldMask</code>，则服务器必须接受请求而不会出错。 这意味着服务器必须忽略仅输出字段的存在及其任何指示。 这个建议的原因是因为客户端通常会将服务器返回的资源重用为另一个请求输入，例如 一个检索到的书将在UPDATE方法中被再次使用。 如果仅输出字段验证，那么这将在客户端添加额外的工作以清除仅输出字段。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">message Book &#123;</span><br><span class="line">  string name = 1;</span><br><span class="line">  // Output only.</span><br><span class="line">  Timestamp create_time = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h1><p>本节提供了将内联文档添加到API的准则。 大多数API还将具有概述，教程和更高级别的参考文档，这些文档超出了本“设计指南”的范围。 有关API，资源和方法命名的信息，请参阅<a href="https://cloud.google.com/apis/design/naming_convention" target="_blank" rel="noopener">命名约定</a>。</p><h2 id="评论格式"><a href="#评论格式" class="headerlink" title="评论格式"></a>评论格式</h2><p>Add comments to your <code>.proto</code> file using the usual Protocol Buffers <code>//</code> comment format.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Creates a shelf in the library, and returns the new Shelf.</span><br><span class="line">rpc CreateShelf(CreateShelfRequest) returns (Shelf) &#123;</span><br><span class="line">  option (google.api.http) = &#123; post: &quot;/v1/shelves&quot; body: &quot;shelf&quot; &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="服务配置中的注释"><a href="#服务配置中的注释" class="headerlink" title="服务配置中的注释"></a>服务配置中的注释</h2><p>作为将文档注释添加到<code>.proto</code>文件的替代方法，您可以在其YAML服务配置文件中添加内联文档到您的API。 如果两个文件中都记录了相同的元素，则该文件中的文档将优先于<code>.proto</code>中的文档。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">documentation:</span><br><span class="line">  summary: Gets and lists social activities</span><br><span class="line">  overview: A simple example service that lets you get and list possible social activities</span><br><span class="line">  rules:</span><br><span class="line">  - selector: google.social.Social.GetActivity</span><br><span class="line">    description: Gets a social activity. If the activity does not exist, returns Code.NOT_FOUND.</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>如果您有多个服务使用相同的<code>.proto</code>文件并希望提供特定于服务的文档，则可能需要使用此方法。 YAML文档规则还可以为API描述添加更详细的概述。 但是，一般来说，添加文档注释到<code>.proto</code>是首选的。</p><p>与<code>.proto</code>注释一样，您可以使用Markdown在YAML文件注释中提供其他格式。</p><h2 id="API描述"><a href="#API描述" class="headerlink" title="API描述"></a>API描述</h2><p>The API description is a phrase starting with an active verb that describes what you can do with the API. In your <code>.proto</code>file, an API description is added as a comment to the corresponding <code>service</code>, as in the following example:</p><p>API描述是一个从活动动词开始的短语，用于描述您可以使用API做什么。 在<code>.proto</code>文件中，API描述作为注释添加到相应的服务中，如下例所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Manages books and shelves in a simple digital library.</span><br><span class="line">service LibraryService &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是一些更为示例的API说明：</p><ul><li>与世界各地的朋友分享更新，照片，视频等。</li><li>访问云托管的机器学习服务，可以轻松构建响应数据流的智能应用程序。</li></ul><h2 id="资源描述"><a href="#资源描述" class="headerlink" title="资源描述"></a>资源描述</h2><p>资源描述是描述资源代表什么的部分句子。 如果您需要添加更多的细节，请使用其他句子。 在<code>.proto</code>文件中，将资源描述作为注释添加到相应的消息类型中，如以下示例所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// A book resource in the Library API.</span><br><span class="line">message Book &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是一些示例资源描述：</p><ul><li>用户的待办事项列表中的任务。 每个任务都有一个独特的优先级。</li><li>用户日历上的事件。</li></ul><h2 id="现场和参数说明"><a href="#现场和参数说明" class="headerlink" title="现场和参数说明"></a>现场和参数说明</h2><p>描述字段或参数定义的名词短语，如以下示例所示：</p><ul><li>本系列中的主题数量。</li><li>纬度和经度坐标的精确度，以米为单位。必须是非负数。</li><li>管理是否为本系列中的提交资源返回附件URL值的标志。 <code>serial.insert</code>的默认值为<code>true</code>。</li><li>投票信息的容器。仅当投票信息被记录时才存在。</li><li>目前尚未使用或已弃用。</li></ul><p>现场和参数说明</p><ul><li>必须明确描述边界（即清楚有效和什么是无效的）请记住，工程师将尽力破坏任何服务，并且无法读取底层代码来澄清任何不清楚的信息。）</li><li>必须指定任何默认值或默认行为;换句话说，如果没有提供值，服务器将会做什么。</li><li>如果它是字符串，例如名称或路径，则描述语法和列出允许的字符以及任何所需的编码。例如：</li><li>集合中的1-255个字符[A-a0-9]</li><li>从RFC 2332约定开始的有效URL路径字符串。最大长度为500个字符。</li><li>应尽可能提供示例值。</li><li>如果需要字段值，仅输入，仅输出，则必须在字段描述开头记录。默认情况下，所有字段和参数都是可选的。例如：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">message Table &#123;</span><br><span class="line">  // Required. The resource name of the table.</span><br><span class="line">  string name = 1;</span><br><span class="line">  // Input only. Whether to dry run the table creation.</span><br><span class="line">  bool dryrun = 2;</span><br><span class="line">  // Output only. The timestamp when the table was created. Assigned by</span><br><span class="line">  // the server.</span><br><span class="line">  Timestamp create_time = 3;</span><br><span class="line">  // The display name of the table.</span><br><span class="line">  string display_name = 4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法描述"><a href="#方法描述" class="headerlink" title="方法描述"></a>方法描述</h2><p>一个方法描述是一个句子，指出方法有什么影响以及它所运行的资源。 它通常以第三人称现在时态动词（即以“s结尾的动词”）开始。 如果您需要添加更多的细节，请使用其他句子。 这里有些例子：</p><ul><li>列出已验证用户的日历事件。</li><li>使用请求中包含的数据更新日历事件。</li><li>从经过身份验证的用户的位置记录中删除位置记录。</li><li>使用请求中包含的数据创建或更新已验证用户的位置记录中的位置记录。 如果位置资源已经存在相同的时间戳值，则提供的数据将覆盖现有数据。</li></ul><h2 id="API描述的大纲"><a href="#API描述的大纲" class="headerlink" title="API描述的大纲"></a>API描述的大纲</h2><p>确保每个描述简单但完整，并且没有关于API的其他信息的用户可以理解。在大多数情况下，还有更多的是要重申明显的;例如，<code>serial.insert</code>方法的描述不应该只是说“插入一个系列”。 - 虽然你的命名应该是信息丰富的，但大多数读者都在阅读你的描述，因为他们需要比名字本身提供更多的信息。如果您不清楚说明中还有什么要说的话，请尝试回答以下所有相关问题：</p><ul><li>它是什么？</li><li>如果成功，该怎么办？如果失败，该怎么办？什么会导致失败，怎么办？</li><li>这是幂等吗？</li><li>什么是单位？ （示例：米，度，像素）</li><li>它接受哪些价值观？范围包括还是排他？</li><li>有什么副作用？</li><li>你如何使用它？</li><li>常见的错误是什么？</li><li>它总是存在吗？ （例如：“投票信息的容器”，只有在记录投票信息时才存在。）</li><li>它是否有默认设置？</li></ul><h2 id="约定"><a href="#约定" class="headerlink" title="约定"></a>约定</h2><p>本节列出了文本描述和文档的一些用法约定。 例如，在谈论标识符时使用“ID”（全部大写），而不是“Id”或“id”。 在引用该数据格式时使用“JSON”而不是“Json”或“json”。 以<code>代码字体</code>显示所有字段/参数名称。 将文字字符串值放在<code>代码字体</code>和引号中。</p><ul><li>ID</li><li>JSON</li><li>RPC</li><li>REST</li><li><code>property_name</code> or <code>&quot;string_literal&quot;</code></li><li><code>true</code> / <code>false</code></li></ul><h2 id="语言风格"><a href="#语言风格" class="headerlink" title="语言风格"></a>语言风格</h2><p>在我们的命名约定中，我们建议在编写文档注释时使用简单，一致的词汇和风格。 那些不会说英语的读者应该可以理解这个意见，所以要避免行话，俚语，复杂的隐喻，流行文化的引用或其他不容易理解的内容。 使用友好，专业的风格，直接与开发人员阅读您的评论，并尽可能简明扼要。 请记住，大多数读者想要了解如何使用API做某事，不要阅读文档！</p><h1 id="Protocol-Buffers-v3"><a href="#Protocol-Buffers-v3" class="headerlink" title="Protocol Buffers v3"></a>Protocol Buffers v3</h1><p>本章将讨论如何使用协议缓冲区与API设计。为了简化开发人员的体验并提高运行时效率，gRPC API应使用协议缓冲区版本3（proto3）进行API定义。</p><p>协议缓冲区是一种用于定义数据结构模式和编程接口的简单的语言中立和平台中立的界面定义语言（IDL）。它支持二进制和文本线格式，并且可以在不同平台上使用许多不同的线路协议。</p><p>Proto3是Protocol Buffers的最新版本，并且包括<code>proto2</code>的以下更改：</p><ul><li>现场存在，也称为hasField，不适用于原始字段。未定义的原始字段具有语言定义的默认值。消息字段的存在仍然可用，可以使用编译器生成的<code>hasFieldmethod</code>或与null进行比较或由实现定义的<code>sentinel</code>值进行测试。</li><li>字段的用户定义的默认值不再可用。</li><li>枚举定义必须以枚举值零开始。</li><li>必填字段不再可用。</li><li>扩展程序已不再可用。使用<code>google.protobuf.Any</code>代替。由于后向和运行时兼容性的原因，专门针对<code>google/protobuf/descriptor.proto</code>授予异常。</li><li>删除组语法。</li></ul><p>删除这些功能的原因是使API设计更简单，更稳定，性能更高。例如，在记录消息之前，通常需要过滤某些字段，例如删除敏感信息。如果这些字段是必需的，这是不可能的。</p><p>有关详细信息，请参阅协议缓冲区。</p><h1 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h1><p>本章提供了联网API的版本控制指南。由于一个API服务可以提供多个API接口，所以API版本控制策略适用于API接口级别，而不是在API服务级别。为了方便起见，术语API指的是以下部分中的API接口。</p><p>网络API应该使用语义版本控制。给定版本号<code>MAJOR.MINOR.PATCH</code>，增加：</p><ol><li><code>MAJOR</code>版本当您进行不兼容的API更改时，</li><li>当您以向后兼容的方式添加功能时，<code>MINOR</code>版本，</li><li>当您制作向后兼容的错误修复时，<code>PATCH</code>版本。</li></ol><p>不同的规则适用于根据API版本指定主版本号：</p><ul><li>对于API的版本1（v1），其主要版本号应以原包名称编码，例如<code>google.pubsub.v1</code>。如果软件包包含稳定的类型和不希望有突发性更改的接口，例如<code>google.protobuf</code>和<code>google.longrunning</code>，则主包可能会从主包中省略。</li><li>对于除v1以外的所有版本的API，主版本号必须以原包名称编码。例如，<code>google.pubsub.v2</code>。</li></ul><p>对于前GA版本（如alpha和beta），建议在版本号后附加一个后缀。后缀应包含预发行版本名称（例如alpha，beta）和可选的预发行版本号。</p><p>版本进度示例：</p><table><thead><tr><th>Version</th><th>Proto Package</th><th>Description</th></tr></thead><tbody><tr><td>v1alpha</td><td>v1alpha1</td><td>The v1 alpha release.</td></tr><tr><td>v1beta1</td><td>v1beta1</td><td>The v1 beta 1 release.</td></tr><tr><td>v1beta2</td><td>v1beta2</td><td>The second beta release of v1.</td></tr><tr><td>v1test</td><td>v1test</td><td>An internal test release with dummy data.</td></tr><tr><td>v1</td><td>v1</td><td>The v1 major version, general availability.</td></tr><tr><td>v1.1beta1</td><td>v1p1beta1</td><td>The first beta release for minor changes to v1.</td></tr><tr><td>v1.1</td><td>v1</td><td>The minor update to v1.1 release.</td></tr><tr><td>v2beta1</td><td>v2beta1</td><td>The v2 beta 1 release.</td></tr><tr><td>v2</td><td>v2</td><td>The v2 major version, general availability.</td></tr></tbody></table><p>次要和补丁编号应反映在API配置和文档中，它们不能以原包名称编码。</p><p><strong>NOTE:</strong> Google API Platform本来不支持小版本和补丁版本。对于每个主要的API版本，只有一组文档和客户端库。 API所有者需要通过API文档和发行说明手动记录它们。</p><p>API的新主要版本不能取决于同一个API的以前的主要版本。 API可能依赖于其他API，以了解与这些API相关联的依赖性和稳定性风险。稳定的API版本必须仅依赖于其他API的最新稳定版本。</p><p>在一段时间内，同一API的不同版本必须能够在单个客户端应用程序中同时工作。这是为了帮助客户顺利地从旧版本过渡到较新版本的API。</p><p>较旧的API版本应在其弃用期结束后才能删除。</p><p>许多API共享的常见且稳定的数据类型（如日期和时间）应在单独的原包中定义。如果有必要进行突破性更改，则必须引入新的类型名称或包含新主版本的软件包名称。</p><h2 id="向后兼容"><a href="#向后兼容" class="headerlink" title="向后兼容"></a>向后兼容</h2><p>确定什么被视为向后兼容的变化可能是困难的。</p><p>以下列表是快速参考起始点，但如果您有任何疑问，请参阅专用的兼容性部分了解更多详细信息。</p><h3 id="向后兼容（不间断）更改"><a href="#向后兼容（不间断）更改" class="headerlink" title="向后兼容（不间断）更改"></a>向后兼容（不间断）更改</h3><ul><li>向API服务添加API接口</li><li>将方法添加到API接口</li><li>向方法添加HTTP绑定</li><li>将字段添加到请求消息</li><li>将字段添加到响应消息</li><li>将值添加到枚举</li><li>添加仅输出资源字段</li></ul><h3 id="向后不兼容（断开）更改"><a href="#向后不兼容（断开）更改" class="headerlink" title="向后不兼容（断开）更改"></a>向后不兼容（断开）更改</h3><ul><li>删除或重命名服务，接口，字段，方法或枚举值</li><li>更改HTTP绑定</li><li>更改字段的类型</li><li>更改资源名称格式</li><li>更改现有请求的可见行为</li><li>更改HTTP定义中的URL格式</li><li>向资源消息添加读/写字段Compatibility</li></ul><p>此页面提供了有关<code>Versioningsection</code>中给出的破坏和不间断更改列表的更详细说明。</p><p>这并不总是完全清楚什么是破坏（不相容）的变化。这里的指导应被视为指示性的，而不是每一个可能的变化的综合清单。</p><p>这里列出的规则只涉及客户兼容性。预期API生产者在部署方面了解自己的要求，包括实施细节的变化。</p><p>一般的目标是客户端不应该被更新到新的小版本或补丁的服务中断。正在考虑的种种破坏是：</p><ul><li>源兼容性：针对1.0编写的代码无法针对1.1进行编译</li><li>二进制兼容性：针对1.0无法针对1.1客户端库进行链接/运行的代码编译。 （精确细节取决于客户端平台;在不同情况下有不同的变体）</li><li>电线兼容性：针对1.0无法与1.1服务器进行通信的应用程序</li><li>语义兼容性：一切都运行，但产生意想不到或令人惊讶的结果</li></ul><p>换句话说：老客户应该可以在同一个主要版本号的较新的服务器上工作，当他们想要更新到一个新的小版本（例如，利用一个新功能）时，他们应该能够这么容易</p><p>除了基于协议的理论考虑之外，由于存在涉及生成的代码和手写代码的客户端库，所以存在实际的考虑。通过生成新版本的客户端库并确保其测试仍然通过，尽可能地测试您正在考虑的更改。</p><p>下面的讨论将原始消息分为三类：</p><ul><li>请求消息（如<code>GetBookRequest</code>）</li><li>响应消息（如<code>ListBooksResponse</code>）</li><li>资源消息（例如<code>Book</code>，并包括在其他资源消息中使用的任何消息）</li></ul><p>这些类别具有不同的规则，因为请求消息仅从客户端发送到服务器，响应消息仅从服务器发送到客户端，但通常资源消息都以两种方式发送。特别地，可以更新的资源需要根据读取/修改/写入周期来考虑。</p><h2 id="向后兼容（不间断）更改-1"><a href="#向后兼容（不间断）更改-1" class="headerlink" title="向后兼容（不间断）更改"></a>向后兼容（不间断）更改</h2><h3 id="向API服务定义添加API接口"><a href="#向API服务定义添加API接口" class="headerlink" title="向API服务定义添加API接口"></a>向API服务定义添加API接口</h3><p>从协议的角度来看，这是永远安全的。 唯一需要注意的是，客户端库可能已经在手写代码中使用了您的新API接口名称。 如果您的新界面与现有界面完全正交，则不太可能; 如果它是现有界面的简化版本，那么更有可能导致冲突。</p><h3 id="向API接口添加方法"><a href="#向API接口添加方法" class="headerlink" title="向API接口添加方法"></a>向API接口添加方法</h3><p>除非您添加与客户端库中已经生成的方法冲突的方法，否则这应该是正常的。</p><p>（可能会破坏的例子）：如果您有GetFoo方法，则C＃代码生成器将已经创建了GetFoo和GetFooAsync方法。因此，在API接口中添加GetFooAsync方法将是从客户端库角度出发的一个突破性变化。）</p><h3 id="向方法添加HTTP绑定"><a href="#向方法添加HTTP绑定" class="headerlink" title="向方法添加HTTP绑定"></a>向方法添加HTTP绑定</h3><p>假设绑定没有引入任何歧义，使得服务器响应以前将拒绝的URL是安全的。当将现有操作应用于新的资源名称模式时，可以这样做。</p><h3 id="向请求消息添加字段"><a href="#向请求消息添加字段" class="headerlink" title="向请求消息添加字段"></a>向请求消息添加字段</h3><p>添加请求字段可以是不间断的，只要不指定该字段的客户端将在新版本中与旧版本相同。</p><p>最为明显的例子就是分页：如果API的v1.0不包含分页，则不能添加到v1.1中，除非默认的page_size被视为无限（通常是一个坏主意）。否则，希望从单个请求获得完整结果的v1.0客户端可能会收到截断的结果，而不知道该集合包含更多资源。</p><h3 id="向响应消息添加一个字段"><a href="#向响应消息添加一个字段" class="headerlink" title="向响应消息添加一个字段"></a>向响应消息添加一个字段</h3><p>只要不改变其他响应字段的行为，就可以扩展不是资源的响应消息（例如ListBooksResponse），而不会破坏客户端。以前在响应中填充的任何字段应该继续使用相同的语义填充，即使这引入了冗余。</p><p>例如，1.0中的查询响应可能具有contains_duplicate的布尔字段，以指示由于重复而省略了一些结果。在1.1中，我们可能会在duplicate_count字段中提供更详细的信息。即使从1.1角度来看它是多余的，但是containsduplicates字段仍然必须填充。</p><h3 id="向枚举中添加一个值"><a href="#向枚举中添加一个值" class="headerlink" title="向枚举中添加一个值"></a>向枚举中添加一个值</h3><p>仅在请求消息中使用的枚举可以自由扩展，以包含新元素。例如，使用资源视图模式，可以在新的次要版本中添加新视图。客户端从来不需要收到这个枚举，所以他们不需要知道他们不在乎的价值观。</p><p>对于资源消息和响应消息，默认假设是客户端应该处理它们不知道的枚举值。然而，API生产者应该意识到，编写应用程序来正确处理新的枚举元素可能很困难。 API所有者应该在遇到未知的枚举值时记录预期的客户端行为。</p><p>Proto3允许客户端收到他们不知道的值并保留消息维持相同的值，所以这不会中断读取/修改/写入周期。 JSON格式允许在值“未知”的位置发送数字值，但服务器通常不会知道客户端是否真正了解特定值。因此，JSON客户端可能会意识到他们已经收到以前对他们未知的值，但他们只会看到名称或号码 - 他们不会同时知道这两个。在读取/修改/写入周期中将相同的值返回给服务器不应修改该字段，因为服务器应该了解这两种形式。</p><h3 id="添加仅输出资源字段"><a href="#添加仅输出资源字段" class="headerlink" title="添加仅输出资源字段"></a>添加仅输出资源字段</h3><p>可以添加仅由服务器提供的资源实体中的字段。 服务器可以验证请求中的任何客户端提供的值是否有效，但是如果该值被省略则不能失败。</p><h2 id="向后不兼容（断开）更改-1"><a href="#向后不兼容（断开）更改-1" class="headerlink" title="向后不兼容（断开）更改"></a>向后不兼容（断开）更改</h2><h3 id="删除或重命名服务，字段，方法或枚举值"><a href="#删除或重命名服务，字段，方法或枚举值" class="headerlink" title="删除或重命名服务，字段，方法或枚举值"></a>删除或重命名服务，字段，方法或枚举值</h3><p>从根本上说，如果客户端代码可以引用某些东西，那么删除或重命名它是一个突破性的变化，并且必须导致主要的版本增加。 引用旧名称的代码将导致某些语言（如C＃和Java）的编译时出现故障，并可能导致其他语言的执行时间故障或数据丢失。 线格式的兼容性在这里是无关紧要的。</p><h3 id="更改HTTP绑定"><a href="#更改HTTP绑定" class="headerlink" title="更改HTTP绑定"></a>更改HTTP绑定</h3><p>这里的“更改”实际上是“删除和添加”。例如，如果您确定您真的希望支持PATCH，但您发布的版本支持PUT，或者您使用错误的自定义动词名称，则可以添加新的绑定，但是由于所有相同的原因，您不能删除旧的绑定因为删除服务方法是一个突破性的变化。</p><h3 id="更改字段的类型"><a href="#更改字段的类型" class="headerlink" title="更改字段的类型"></a>更改字段的类型</h3><p>即使新类型与线格式兼容，这可能会改变客户端库的生成代码，因此必须导致主版本的增加。对于编译的静态类型的语言，这可以很容易地引入编译时错误。</p><h3 id="更改资源名称格式"><a href="#更改资源名称格式" class="headerlink" title="更改资源名称格式"></a>更改资源名称格式</h3><p>资源不能更改其名称 - 这意味着无法更改集合名称。</p><p>与大多数突破性更改不同，这也影响主要版本：如果客户端可以期望使用v2.0访问在v1.0中创建的资源，反之亦然，则应在两个版本中使用相同的资源名称。</p><p>更精巧的是，有效的资源名称集合也不应该改变，原因如下：</p><ul><li>如果它变得更加限制，以前成功的请求现在将失败。</li><li>如果它比以前记录的限制较少，那么根据以前的文档做出假设的客户可能会被打破。客户端很有可能在其他地方存储资源名称，方式可能对允许的字符集和名称的长度敏感。或者，客户端可能会执行自己的资源名称验证来跟踪文档。 （例如，亚马逊给客户带来了许多警告，并且在开始允许更长的EC2资源ID时有迁移期）。</li></ul><p>请注意，这样的更改只能在原型文档中可见。因此，当检查CL为破损时，审查非评论变更是不够的。</p><h3 id="改变现有请求的可见行为"><a href="#改变现有请求的可见行为" class="headerlink" title="改变现有请求的可见行为"></a>改变现有请求的可见行为</h3><p>客户端通常依赖于API行为和语义，即使没有明确支持或记录此类行为。因此，在大多数情况下，更改API数据的行为或语义将被视为消费者的打破。如果行为不是加密隐藏的，那么你应该假设用户已经发现了它，并且会依赖它。例如，用户具有反向设计的AWS EC2资源标识符。</p><p>加密分页令牌也是一个好主意（即使数据不感兴趣），以防止用户创建自己的令牌，并在令牌行为发生变化时可能被破坏。</p><h3 id="更改HTTP定义中的URL格式"><a href="#更改HTTP定义中的URL格式" class="headerlink" title="更改HTTP定义中的URL格式"></a>更改HTTP定义中的URL格式</h3><p>在这里有两种更改可以考虑，超出以上列出的资源名称变化：</p><ul><li>自定义方法名称：虽然不是资源名称的一部分，但自定义方法名称是REST客户端发布的URL的一部分。更改自定义方法名称不应该破坏gRPC客户端，但是公共API必须假定它们具有REST客户端。</li><li>资源参数名称：从v1 / shelf / {shelf} / books / {book} tov1 / shelves / {shelf_id} / books / {book_id}改变不会影响替换的资源名称，但可能会影响代码生成。</li></ul><h3 id="向资源消息添加读-写字段"><a href="#向资源消息添加读-写字段" class="headerlink" title="向资源消息添加读/写字段"></a>向资源消息添加读/写字段</h3><p>客户端经常会执行读/写/写操作。大多数客户不会为他们不知道的领域提供价值，特别是proto3不支持这一点。您可以指定消息类型（而不是基本类型）的任何缺失字段意味着更新不会应用于这些字段，但这使得更难于从实体中显式删除这样的字段值。原始类型（包括字符串和字节）根本不能以这种方式处理，因为在明确指定int32字段为0并且根本不指定之前，proto3没有区别。</p><p>如果使用字段掩码执行所有更新，这不是问题，因为客户端不会隐式覆盖其不知道的字段。然而，这将是一个不寻常的API决定：大多数API允许“全部资源”更新。</p><h1 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h1><p>API服务通常使用<code>.proto</code>文件来定义API表面和<code>.yaml</code>文件来配置API服务。</p><p>每个API服务必须在API存储库中具有包含其定义文件和构建脚本的API目录。</p><p>API目录应具有以下标准布局：</p><ul><li>API目录</li><li>存储库先决条件</li><li><code>BUILD</code> - 构建文件。</li><li><code>METADATA</code> - 构建元数据文件。</li><li><code>OWNERS</code> - API目录所有者。</li><li>配置文件</li><li><code>{service} .yaml</code> - 基准服务配置文件，它是<code>google.api.Service</code> proto消息的YAML表示形式。</li><li><code>prod.yaml</code> - prod delta服务配置文件。</li><li><code>staging.yaml</code> - 分段delta服务配置文件。</li><li><code>test.yaml</code> - 测试增量服务配置文件。</li><li><code>local.yaml</code> - 本地delta服务配置文件。</li><li>文档文件</li><li><code>README.md</code> - 主要的自述文件。应包含一般生产概况，技术说明等。</li><li><code>doc/*</code> - 技术文档文件。他们应该是Markdown格式。</li><li>接口定义</li><li><code>v[0-9]*/*</code> - 每个这样的目录都包含主要版本的API，主要是原始文件和构建脚本。</li><li><code>{subapi}/v[0-9]*/*</code>- 每个<code>{subapi}</code>目录包含子API的接口定义。每个子API可能有自己独立的主要版本。</li><li><code>type/*-</code>包含不同API，不同版本的同一API之间或API与服务实现之间共享的类型的proto文件。类型<code>/*</code>下的类型定义在发布后不应该有破坏性的更改。</li></ul><h1 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h1><p>应使用proto3 IDL在<code>.proto</code>文件中定义<code>gRPC API</code>。</p><p>文件结构必须在较低级别和较不重要的项目之前提出更高级别和更重要的定义。 在每个原始文件中，适用的部分应按以下顺序：</p><ul><li>如果需要，版权和许可证通知。</li><li>按照该顺序的Proto语法，包，选项和导入语句。</li><li>API概述文档，为文件的其余部分准备读者。</li><li>API原始服务定义，按重要性降序排列。</li><li>资源消息定义。 父资源必须在其子资源之前定义。</li><li>RPC请求和响应消息定义，按照相应的方法顺序。 每个请求消息必须在其相应的响应消息之前（如果有）。</li></ul><p>如果单个原始文件包含整个API表面，则应以API命名：</p><table><thead><tr><th>API</th><th>Proto</th></tr></thead><tbody><tr><td><code>Library</code></td><td><code>library.proto</code></td></tr><tr><td><code>Calendar</code></td><td><code>calendar.proto</code></td></tr></tbody></table><p>Large.proto文件可能会分成多个文件。 服务，资源消息和请求/响应消息应根据需要移动到单独的文件中。</p><p>我们推荐每个服务一个文件及其相应的请求和响应。 考虑命名此文件<code>&lt;enclosed service name&gt;.proto</code>。 对于只有资源的原始文件，请考虑将该文件命名为<code>resources.proto</code>。</p><h2 id="原文件名称"><a href="#原文件名称" class="headerlink" title="原文件名称"></a>原文件名称</h2><p>Proto文件名应该使用lower_case_underscore_separated_names，并且必须使用扩展名<code>.proto</code>。 例如：<code>service controller.proto</code>。</p><h2 id="Proto选项"><a href="#Proto选项" class="headerlink" title="Proto选项"></a>Proto选项</h2><p>为了在不同的API之间生成一致的客户端库，API开发人员必须在<code>.proto</code>文件中使用一致的原始选项。 符合本指南的API定义必须使用以下文件级原始选项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">syntax = &quot;proto3&quot;;</span><br><span class="line"></span><br><span class="line">//包名应以公司名称开头，以</span><br><span class="line">//主要版本。</span><br><span class="line">package google.abc.xyz.v1;</span><br><span class="line"></span><br><span class="line">//此选项指定要在C＃代码中使用的命名空间。 这是默认值</span><br><span class="line">//到PascalCased版本的proto包，这是很好的</span><br><span class="line">//包名称由单字段组成。</span><br><span class="line">//例如，一个名为“google.shopping.pets.v1”的包将使用C＃</span><br><span class="line">//“Google.Shopping.Pets.V1”的命名空间。</span><br><span class="line">//但是，如果程序包名称的任何段由多个单词组成，</span><br><span class="line">//这个选项需要被指定，以避免只有第一个字</span><br><span class="line">//大写。 例如，Google Pet Store API可能具有包名称</span><br><span class="line">//“google.shopping.petstore.v1”，这意味着C＃的命名空间</span><br><span class="line">//“Google.Shopping.Petstore.V1”。 相反，应该使用该选项</span><br><span class="line">//正确地将其大小写为“Google.Shopping.PetStore.V1”。</span><br><span class="line">//有关C＃/。NET大小写规则的更多详细信息，请参阅[框架设计]</span><br><span class="line">//指南]（https://msdn.microsoft.com/en-us/library/ms229043）。</span><br><span class="line">option csharp_namespace = &quot;Google.Abc.Xyz.V1&quot;;</span><br><span class="line"></span><br><span class="line">//此选项让proto编译器在程序包中生成Java代码</span><br><span class="line">//名称（见下文），而不是外部类。 它创建一个更简单</span><br><span class="line">//通过减少一级名称嵌套的开发人员体验</span><br><span class="line">//与大多数不支持外部类的编程语言一致。</span><br><span class="line">option java_multiple_files = true;</span><br><span class="line"></span><br><span class="line">// Java外部类名应该是UpperCamelCase中的文件名。 这个</span><br><span class="line">//类只用于保存原始描述符，所以开发人员不需要</span><br><span class="line">//直接使用它</span><br><span class="line">option java_outer_classname = &quot;XyzProto&quot;;</span><br><span class="line"></span><br><span class="line">// The Java package name must be proto package name with proper prefix.</span><br><span class="line">option java_package = &quot;com.google.abc.xyz.v1&quot;;</span><br><span class="line"></span><br><span class="line">//从包中生成的Objective-C符号的合理前缀。</span><br><span class="line">//应该至少有3个字符长，全部大写和约定</span><br><span class="line">//是使用包名称的缩写。 有点短，但是</span><br><span class="line">//希望足够独特，不会与可能出现的事情冲突</span><br><span class="line">// 未来。 &apos;GPB&apos;保留给协议缓冲区实现本身。</span><br><span class="line">option objc_class_prefix = &quot;GABCX&quot;;</span><br></pre></td></tr></table></figure><h2 id="词汇表"><a href="#词汇表" class="headerlink" title="词汇表"></a>词汇表</h2><h3 id="联网API"><a href="#联网API" class="headerlink" title="联网API"></a>联网API</h3><ul><li>应用程序编程通过计算机网络运行的接口。它们使用包括HTTP在内的网络协议进行通信，并且经常由不同的组织生成，而不是消费它们。</li></ul><h3 id="Google-API"><a href="#Google-API" class="headerlink" title="Google API"></a>Google API</h3><ul><li>由Google服务公开的网络API。他们大多数托管在googleapis.com域上。它不包括其他类型的API，如客户端库和SDK。</li></ul><h3 id="API接口"><a href="#API接口" class="headerlink" title="API接口"></a>API接口</h3><ul><li>协议缓冲区服务定义。它通常映射到大多数编程语言中的接口。 API接口可以由任何数量的API服务来实现。</li></ul><h3 id="API版本"><a href="#API版本" class="headerlink" title="API版本"></a>API版本</h3><ul><li>API接口的版本或一组API接口，如果它们一起定义。 API版本通常由字符串（例如“v1”）表示，并呈现在API请求和协议缓冲区包名称中。</li></ul><h3 id="API方法"><a href="#API方法" class="headerlink" title="API方法"></a>API方法</h3><ul><li>API接口内的单独操作。它通过rpc定义在协议缓冲区中表示，并且通常在大多数编程语言中映射到API接口中的函数。</li></ul><h3 id="API请求"><a href="#API请求" class="headerlink" title="API请求"></a>API请求</h3><ul><li>单一调用API方法。它经常用作计费，记录，监控和速率限制的单位。</li></ul><h3 id="API服务"><a href="#API服务" class="headerlink" title="API服务"></a>API服务</h3><ul><li>在一个或多个网络端点上暴露的一个或多个API接口的部署实现。 API服务由其与RFC 1035 DNS兼容的服务名称（如calendar.googleapis.com）标识。</li></ul><h3 id="API端点"><a href="#API端点" class="headerlink" title="API端点"></a>API端点</h3><ul><li>指的是API服务用于服务实际API请求的网络地址，例如pubsub.googleapis.com和content-pubsub.googleapis.com。</li></ul><h3 id="API产品"><a href="#API产品" class="headerlink" title="API产品"></a>API产品</h3><ul><li>API服务加相关组件，如服务条款，文档，客户端库和服务支持，作为产品集体呈现给客户。例如Google Calendar API。注意：人们有时将API产品简称为API。</li></ul><h3 id="API服务定义"><a href="#API服务定义" class="headerlink" title="API服务定义"></a>API服务定义</h3><ul><li>用于定义API服务的API接口定义（.proto文件）和API服务配置（.yaml文件）的组合。</li></ul><h3 id="API消费者"><a href="#API消费者" class="headerlink" title="API消费者"></a>API消费者</h3><ul><li>消费API服务的实体。对于Google API，通常是拥有客户端应用程序或服务器资源的Google项目。</li></ul><h3 id="API制作人"><a href="#API制作人" class="headerlink" title="API制作人"></a>API制作人</h3><ul><li>实体生成API服务。对于Google API，它通常是拥有API服务的Google项目。</li></ul><h3 id="API后端"><a href="#API后端" class="headerlink" title="API后端"></a>API后端</h3><ul><li>一组服务器以及实现API服务业务逻辑的相关基础架构。单个API后端服务器通常称为API服务器。</li></ul><h3 id="API前端"><a href="#API前端" class="headerlink" title="API前端"></a>API前端</h3><ul><li>一组服务器和相关基础架构，可跨API服务提供通用功能，例如负载平衡和身份验证。单个API前端服务器通常称为API代理。注意：API前端和API后端可能彼此相邻或彼此远离运行。在某些情况下，它们可以编译成单个应用程序二进制文件，并在单个进程中运行。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;这是网络API的一般设计指南。自2014年以来，它已在Google内部使用，是Google在设计Cloud API和其他Google API
      
    
    </summary>
    
      <category term="scala" scheme="http://luxiangdong.com/categories/scala/"/>
    
    
  </entry>
  
</feed>
