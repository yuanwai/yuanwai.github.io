<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>员外在减肥</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://luxiangdong.com/"/>
  <updated>2018-05-03T09:49:44.082Z</updated>
  <id>http://luxiangdong.com/</id>
  
  <author>
    <name>Xiangdong Lu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Apache Cassandra手册中文版01</title>
    <link href="http://luxiangdong.com/2018/05/03/Cassandra-CN-01/"/>
    <id>http://luxiangdong.com/2018/05/03/Cassandra-CN-01/</id>
    <published>2018-05-03T09:44:56.000Z</published>
    <updated>2018-05-03T09:49:44.082Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于本文档"><a href="#关于本文档" class="headerlink" title="关于本文档"></a>关于本文档</h2><p>欢迎来到DataStax提供的Cassandra文档。 为确保您在使用本文档时获得最佳体验，请花点时间查看使用DataStax文档的提示。</p><p>着陆页提供有关受支持平台，产品兼容性，规划和测试集群部署，推荐的生产设置，故障排除，第三方软件，更多信息的资源，管理员和开发人员主题以及早期文档的信息。</p><h2 id="Apache-Cassandra概览"><a href="#Apache-Cassandra概览" class="headerlink" title="Apache Cassandra概览"></a>Apache Cassandra概览</h2><p>Apache Cassandra™ 是一个大规模可扩展的开源NoSQL数据库。 Cassandra非常适合跨多个数据中心和云，来管理大量结构化、半结构化和非结构化数据。 Cassandra在许多商用服务器上提供持续可用性、线性可扩展性和操作简单性，而没有单点故障，以及强大的动态数据模型，旨在实现最大的灵活性和快速的响应时间。</p><h2 id="Cassandra如何工作"><a href="#Cassandra如何工作" class="headerlink" title="Cassandra如何工作?"></a>Cassandra如何工作?</h2><p>Cassandra基于可扩展的架构，意味着它能够每秒处理PB级信息和数千个并发用户/操作。</p><table><thead><tr><th><strong>Cassandra是一个分区的行存储数据库</strong></th><th>Cassandra的体系结构允许任何授权用户连接到任何数据中心的任何节点，并使用CQL语言访问数据。为了便于使用，CQL使用了与SQL相似的语法。与Cassandra互动的最基本的方式是使用CQL shell，cqlsh。使用cqlsh，您可以创建键空间和表、插入和查询表，以及更多。Cassandra的这一版本与Cassandra 2.2和后来的CQL合作。如果您喜欢图形化工具，您可以使用数据中心DevCenter。对于生产，数据中心提供了一个数字驱动程序，以便CQL语句可以从客户机传递到集群和返回。</th></tr></thead><tbody><tr><td><strong>自动化的数据分布</strong></td><td>Cassandra提供了所有参与到环(比如hash链路环)或数据库集群的节点的自动数据分布。由于数据在集群中的所有节点上都是透明的，因此，开发人员或管理员不需要进行编程，也不需要通过代码来跨集群分发数据。</td></tr><tr><td><strong>内置的、可定制的复制</strong></td><td>Cassandra还提供了内置的和可定制的复制，它在节点上存储了冗余的数据副本。这意味着，如果集群中的任何节点宕机，该节点数据的一个或多个副本就可以在集群中的其他计算机上使用。可以将复制配置为跨一个数据中心、多个数据中心和多个云可用区域进行工作。</td></tr><tr><td><strong>供应线性可伸缩性</strong></td><td>Cassandra 提供线性可伸缩性，这意味着通过在网络上添加新的节点可以轻松地添加容量。例如，如果2个节点每秒处理10万个事务，那么4个节点将支持200,000个事务/秒，8个节点将处理40万事务/秒:</td></tr><tr><td></td><td><img src="http://docs.datastax.com/en/cassandra/3.0/cassandra/images/intro_cassandra.png" alt="img"></td></tr></tbody></table><h2 id="Cassandra与关系数据库有什么不同"><a href="#Cassandra与关系数据库有什么不同" class="headerlink" title="Cassandra与关系数据库有什么不同?"></a>Cassandra与关系数据库有什么不同?</h2><p>Cassandra的设计是作为一个分布式数据库来进行点对点的交流。作为最佳实践，查询应该是每个表的一个。数据被规范化以使这成为可能。由于这个原因，表之间的连接的概念并不存在，尽管客户端连接可以在应用程序中使用。</p><h2 id="什么是NoSQL"><a href="#什么是NoSQL" class="headerlink" title="什么是NoSQL?"></a>什么是NoSQL?</h2><p>最常见的翻译是“Not Only SQL”，这意味着使用存储方法不同于关系型数据库或SQL数据库的数据库。有许多不同类型的NoSQL数据库，因此即使是最常用的类型也没有什么用处。现在的数据库管理员必须对多语言友好，这意味着他们必须知道如何使用许多不同的RDBMS和NoSQL数据库。</p><h2 id="什么是CQL"><a href="#什么是CQL" class="headerlink" title="什么是CQL?"></a>什么是CQL?</h2><p><a href="http://docs.datastax.com/en/cql/3.3/cql/cqlIntro.html" target="_blank" rel="noopener">Cassandra Query Language (CQL)</a> 是Cassandra DBMS的主要接口。使用CQL类似于使用SQL(结构化查询语言)。CQL和SQL共享一个由列和行组成的表的抽象概念。与SQL的主要区别在于，Cassandra不支持连接或子查询。相反，Cassandra强调了通过CQL的特性，比如在模式层次上指定的集合和集群。</p><p>CQL是与Cassandra互动的推荐方式。性能和简单的阅读和使用CQL是现代Cassandra对旧Cassandra api的优势。</p><p>详见 <a href="http://docs.datastax.com/en/cql/3.3/index.html" target="_blank" rel="noopener">CQL documentation</a>。</p><h2 id="如何与Cassandra交互"><a href="#如何与Cassandra交互" class="headerlink" title="如何与Cassandra交互?"></a>如何与Cassandra交互?</h2><p>与Cassandra互动的最基本的方式是使用CQL shell，cqlsh。使用cqlsh，您可以创建键空间和表、插入和查询表，以及更多。如果您喜欢图形化工具，您可以使用DevCenter。对于生产，数据中心提供了多种编程语言的驱动程序，因此CQL语句可以从客户端传递到集群和返回。</p><h2 id="如何把数据迁移到Cassnadra或者从Cassandra迁移数据"><a href="#如何把数据迁移到Cassnadra或者从Cassandra迁移数据" class="headerlink" title="如何把数据迁移到Cassnadra或者从Cassandra迁移数据?"></a>如何把数据迁移到Cassnadra或者从Cassandra迁移数据?</h2><p>使用CQL插入命令、CQL复制命令和CSV文件插入数据，或者使用sstableloader。但实际上，您需要考虑客户机应用程序如何查询这些表，并首先进行数据建模。关系和NoSQL之间的范式转换意味着，从RDBMS数据库到Cassandra的数据直接转移将注定失败。</p><h2 id="Cassandra还有什么其他的工具吗"><a href="#Cassandra还有什么其他的工具吗" class="headerlink" title="Cassandra还有什么其他的工具吗?"></a>Cassandra还有什么其他的工具吗?</h2><p>Cassandra自动安装了节点工具，这是Cassandra的一个有用的命令行管理工具。在默认情况下，还安装了一个负载压力和基本基准测试的工具—<code>cassandra-stress</code>。</p><h2 id="需要什么类型的硬件-云环境来运行Cassandra"><a href="#需要什么类型的硬件-云环境来运行Cassandra" class="headerlink" title="需要什么类型的硬件/云环境来运行Cassandra?"></a>需要什么类型的硬件/云环境来运行Cassandra?</h2><p>Cassandra的设计是在普通的商用硬件上运行。在云计算中，Cassandra适应了大多数的公共产品。</p><h2 id="Apache-Cassandra-3-0-新特性"><a href="#Apache-Cassandra-3-0-新特性" class="headerlink" title="Apache Cassandra 3.0 新特性"></a>Apache Cassandra 3.0 新特性</h2><h3 id="Cassandra-3-0-新特性"><a href="#Cassandra-3-0-新特性" class="headerlink" title="Cassandra 3.0 新特性"></a>Cassandra 3.0 新特性</h3><table><thead><tr><th><strong>存储引擎重构</strong></th><th>存储引擎已经被重构了。</th></tr></thead><tbody><tr><td><strong>物化视图</strong></td><td>物化视图处理了自动化的服务器端变性，在基础和视图数据之间保持一致。</td></tr><tr><td><strong>操作的改进</strong></td><td></td></tr><tr><td><strong>将MAX_WINDOW_SIZE_SECONDS添加到DTCS压缩管理</strong></td><td>允许DTCS压缩治理基于最大窗口大小而不是SSTable年龄。</td></tr><tr><td><strong>基于文件的提示存储和改进的重播</strong></td><td>提示现在存储在文件中，并且重播得到改进。</td></tr><tr><td><strong>垃圾收集器切换到 G1</strong></td><td><a href="http://docs.datastax.com/en/cassandra/3.0/cassandra/operations/opsTuneJVM.html" target="_blank" rel="noopener">Default garbage collector</a> is changed from Concurrent-Mark-Sweep (CMS) to G1. G1 performance is better for nodes with heap size of 4GB or greater.</td></tr><tr><td><strong>更改了CREATE TABLE压缩选项的语法</strong></td><td>Made the compression options more consistent for <code>CREATE TABLE</code>.</td></tr><tr><td><strong>添加nodetool命令强制重复阻止批处理日志</strong></td><td>BatchlogManager can force batchlog replay using nodetool.</td></tr><tr><td><strong>基于SSL的Nodetool</strong></td><td>Nodetool can connect using SSL like cqlsh.</td></tr><tr><td><strong>用于提示的nodetool工具选项</strong></td><td>Nodetool options <code>disablehintsfordc</code> and <code>enablehintsfordc</code>added. to selectively disable or enable hinted handoffs for a datacenter.</td></tr><tr><td><strong>nodetool stop</strong></td><td>Nodetool option added to stop compactions.</td></tr><tr><td><strong>其他值得注意的变化</strong></td><td></td></tr><tr><td><strong>需要Java 8</strong></td><td>Java 8 is now required.</td></tr><tr><td><strong>nodetool cfstats和nodetool cfhistograms重命名</strong></td><td>Renamed <code>nodetool cfstats</code> to <code>nodetool tablestats</code>. Renamed <code>nodetool cfhistograms</code> to <code>nodetool tablehistograms</code>.</td></tr><tr><td><strong>抛除Native protocol v1 and v2</strong></td><td>Native protocol v1 and v2 are dropped in Cassandra 3.0.</td></tr><tr><td><strong>DataStax AMI does not install Cassandra 3.0 or 3.x</strong></td><td>您可以在Amazon EC2上安装Cassandra 2.1和更早版本，使用DataSet AMI（Amazon Machine Image），如Cassandra 2.1的AMI文档中所述。要在Amazon EC2上安装Cassandra 3.0及更高版本，请在您的平台上使用受信任的AMI 该平台的安装方法。</td></tr></tbody></table><h1 id="理解架构"><a href="#理解架构" class="headerlink" title="理解架构"></a>理解架构</h1><h2 id="架构简介"><a href="#架构简介" class="headerlink" title="架构简介"></a>架构简介</h2><p>Cassandra旨在处理多个节点之间的大数据工作负载，无单点故障。</p><p>它的架构是基于这样的前提，即<strong>系统和硬件故障允许而且确实会发生</strong>。 Cassandra通过在同簇节点之间采用点对点分布式系统来解决故障问题，数据分布在群集中的所有节点之间。每个节点通过使用点对点Gossip通信协议频繁地跨群集交换关于自身和其他节点的状态信息。每个节点上顺序写入的commit log捕获写入操作以确保数据的持久性。然后将数据编入索引并写入内存结构，称为<code>memtable</code>，类似于回写缓存。每次内存结构都已满时，数据将写入SSTables数据文件中的磁盘。所有写入在整个集群中自动分区和复制。 Cassandra会使用一个名为compaction的过程定期整合SSTables，丢弃哪些已经被标记为遗弃的数据删除。为了确保集群中的所有数据保持一致，采用了各种修复机制。</p><p>Cassandra是一个分区行存储数据库，其中，行被组织成具有所需主键的表。 Cassandra的架构允许任何授权用户连接到任何数据中心的任何节点，并使用CQL语言访问数据。 为了易于使用，CQL使用与SQL类似的语法，并与表数据一起使用。 开发人员可以通过cqlsh，DevCenter访问CQL，并通过驱动程序访问应用程序语言。 通常，群集对于由许多不同的表组成的应用程序具有一个密钥空间。</p><p>客户端读或写请求可以发送到集群中的任何节点。 当客户端连接到具有请求的节点时，该节点用作该特定客户机操作的协调器。 协调器充当客户端应用程序和拥有正在请求的数据的节点之间的代理。 协调器根据集群的配置方式确定环中的哪些节点应该获取请求。</p><h3 id="键结构"><a href="#键结构" class="headerlink" title="键结构"></a>键结构</h3><ul><li><p>节点</p><p>存储数据的地方，这是Cassandra的基本基础设施。</p></li><li><p>数据中心</p><p>一组相关节点。数据中心可以是一个物理数据中心或虚拟数据中心。不同的工作负载应该使用单独的数据中心，无论是物理的还是虚拟的。复制是由数据中心设置的。使用单独的数据中心可以防止Cassandra的事务受到其他工作负载的影响，并将请求保持在较低的等待时间。根据复制因素，可以将数据写入多个数据中心。数据中心永远不能跨越物理位置。</p></li><li><p>集群</p><p>一个集群包含一个或多个数据中心。它可以跨越物理位置。</p></li><li><p>commit log</p><p>所有数据都首先写入提交日志，以保证持久性。在所有的数据都被刷新到s马厩后，它可以被归档、删除或回收。</p></li><li><p>SSTable</p><p>一个排序的字符串表(SSTable)是一个不可变的数据文件，Cassandra定期地写备忘录。SSTables只附加并存储在磁盘上，并为每一个Cassandra表维护。</p></li><li><p>CQL Table</p><p>由表行获取的有序列的集合。一个表由列组成，并有一个主键。</p></li></ul><h3 id="配置Cassandra的关键组件"><a href="#配置Cassandra的关键组件" class="headerlink" title="配置Cassandra的关键组件"></a>配置Cassandra的关键组件</h3><ul><li><a href="http://docs.datastax.com/en/cassandra/3.0/cassandra/architecture/archGossipAbout.html" target="_blank" rel="noopener">Gossip</a> 一个点对点通信协议，用于发现和共享关于Cassandra集群中其他节点的位置和状态信息。当节点重新启动时，每个节点都将在本地持久保存流言信息。</li><li><a href="http://docs.datastax.com/en/cassandra/3.0/cassandra/architecture/archPartitionerAbout.html" target="_blank" rel="noopener">Partitioner</a> 分区程序确定哪个节点将接收到一个数据的第一个副本，以及如何在集群中的其他节点上分发其他副本。每一行数据由主键惟一标识，这可能与它的分区键相同，但也可能包括其他集群列。分区程序是一个哈希函数，它从一行的主键派生一个令牌。分区程序使用令牌值来确定集群中的哪个节点接收该行的副本。<code>Murmur3Partitioner</code>是新Cassandra集群的默认分区策略，在几乎所有的情况下，新的集群都是正确的选择。您必须设置分区，并为每个节点分配一个<code>num_token</code>值。您分配的令牌的数量取决于系统的硬件功能。如果不使用虚拟节点(<code>vnode</code>)，则使用<code>initial_token</code>设置。</li><li><a href="http://docs.datastax.com/en/cassandra/3.0/cassandra/architecture/archDataDistributeReplication.html" target="_blank" rel="noopener">Replication factor</a> 跨集群的副本总数。一个复制因子1表示一个节点上的每一行只有一个副本。复制因子2表示每一行的两个副本，每个副本在一个不同的节点上。所有的副本都同等重要，没有主或主副本。您可以为每个数据中心定义复制因子。通常，您应该将复制策略设置为大于1，但不超过集群中的节点数量。</li><li><a href="http://docs.datastax.com/en/cassandra/3.0/cassandra/architecture/archDataDistributeReplication.html" target="_blank" rel="noopener">Replica placement strategy</a>  Cassandra在多个节点上存储数据(副本)，以确保可靠性和容错。复制策略决定将哪些节点放置在该节点上。数据的第一个副本只是第一个副本;它在任何意义上都不是惟一的。对于大多数部署来说， <a href="http://docs.datastax.com/en/cassandra/3.0/cassandra/architecture/archDataDistributeReplication.html#archDataDistributeReplication__networkToplogyStrategy-ph" target="_blank" rel="noopener">NetworkTopologyStrategy</a>是非常推荐的，因为在未来的扩展需要时，扩展到多个数据中心要容易得多。在创建一个keyspace时，您必须定义副本放置策略和您想要的副本数量。</li><li><a href="http://docs.datastax.com/en/cassandra/3.0/cassandra/architecture/archSnitchesAbout.html" target="_blank" rel="noopener">Snitch</a> Snitch将一组机器定义为数据中心和机架(拓扑)，复制策略用于放置副本。您必须在创建集群时配置一个Snitch。所有的snitches都使用动态的snitch层，它可以监控性能，并选择最佳的读取副本。默认情况下启用它，并建议在大多数部署中使用它。为cassandra中的每个节点配置动态的snitch阈值。yaml配置文件。默认的SimpleSnitch不识别数据中心或机架信息。将它用于单数据中心部署或公共云中的单一区域。生产的GossipingPropertyFileSnitch推荐。它定义了一个节点的数据中心和机架，并使用流言传播这些信息到其他节点。</li><li><a href="http://docs.datastax.com/en/cassandra/3.0/cassandra/configuration/configCassandra_yaml.html" target="_blank" rel="noopener">The cassandra.yaml configuration file</a> 用于设置集群的初始化属性、用于表的缓存参数、调优和资源利用率、超时设置、客户端连接、备份和安全性的主要配置文件。默认情况下，一个节点被配置为存储它管理的数据，存储在该目录中的一个目录中。<code>yaml</code>文件。在生产集群部署中，您可以将提交日志目录从<code>datafile-directory</code>更改为不同的磁盘驱动器。</li><li><a href="http://docs.datastax.com/en/cql/3.3/cql/cql_reference/cqlCreateTable.html#tabProp" target="_blank" rel="noopener">System keyspace table properties</a> 您可以通过编程或使用客户端应用程序，例如CQL，在每个键空间或每个表的基础上设置存储配置属性。</li></ul><h2 id="内部节点通信-gossip"><a href="#内部节点通信-gossip" class="headerlink" title="内部节点通信(gossip)"></a>内部节点通信(gossip)</h2><p>Gossip是一种点对点通信协议，其中节点周期性地交换关于他们自己和关于他们知道的其他节点的状态信息。 Gossip进程每秒运行一次，并与群集中最多三个其他节点交换状态消息。 节点交换有关自己和有关其他节点的关联节点的信息，所以所有节点都快速了解集群中的所有其他节点。Gossip消息具有与之相关联的版本，使得在 gossip交换期间，较旧的信息将被特定节点的最新状态覆盖。</p><p>为了防止gossip通信中的问题，请为群集中的所有节点使用相同的种子节点列表。 这是节点第一次启动时最关键的。 默认情况下，一个节点会记住它在随后的重新启动之间闲置的其他节点。 除了为加入群集的新节点引导gossip进程之外，种子节点的名称除外。 种子节点不是单点故障，在集群操作之外，除了节点的引导之外，它们也不具有任何其他特殊用途。</p><p><strong>注意</strong>：在多个数据中心集群中，包括种子列表中每个数据中心（复制组）的至少一个节点。 建议为每个数据中心指定多个单个种子节点进行容错。 否则，gossip必须在引导节点时与其他数据中心进行通信。由于增加了维护和减少了gossip性能，因此不推荐使用每个节点的种子节点。 gossip优化并不重要，但<strong>建议使用小型种子列表（每个数据中心约三个节点）</strong>。</p><h3 id="故障检测和恢复"><a href="#故障检测和恢复" class="headerlink" title="故障检测和恢复"></a>故障检测和恢复</h3><p>故障检测是一种用于从gossip状态和历史记录中，判断系统中的另一个节点关闭或已经恢复的方法。 Cassandra使用此信息避免将客户端请求尽可能地路由到不可达节点。 （Cassandra也可以通过<code>dynamic snitch</code>避免路由请求到活着的节点，但性能不佳。）</p><p>Gossip负责处理从其他节点直接跟踪状态（节点直接与其通话）和间接（节点在二手，三手等上进行通信）跟踪状态。 Cassandra使用权责发生制检查机制来计算一个考虑到网络性能，工作负载和历史条件的每个节点的阈值，而不是使用固定的阈值来标记故障节点。在gossip交流期间，每个节点都保持了来自集群中其他节点的gossip消息到达时间的滑动窗口。配置<code>phi_convict_threshold</code>属性调整故障检测器的灵敏度。较低的值增加了无响应节点被标记为关闭的可能性，而较高的值会降低导致节点故障的瞬态故障的可能性。在大多数情况下使用默认值，但是对于Amazon EC2（由于频繁发生的网络拥塞）而将其增加到10或12。在不稳定的网络环境（如EC2有时），将值提高到10或12有助于防止虚假故障。不推荐值高于12，低于5的值。</p><p>节点故障可能是由各种原因造成的，比如硬件故障和网络中断。节点中断通常是短暂的，但可以持续很长一段时间。因为节点中断很少表示永久离开集群，所以它不会自动导致从环上删除节点。其他节点将定期尝试重新建立与失败节点的联系，以确定它们是否恢复了。为了永久更改集群中的节点成员，管理员必须使用nodetool实用程序显式地添加或删除一个Cassandra集群中的节点。</p><p>当一个节点在停机后重新上线，它可能会错过它所维护的副本数据的写入。<code>Repair mechanisms</code>的存在是为了恢复丢失的数据，比如提示的手动修复和<code>nodetool repair</code>的手工修复。中断的长度将决定使用哪个修复机制来使数据保持一致。</p><h2 id="数据分发与复制"><a href="#数据分发与复制" class="headerlink" title="数据分发与复制"></a>数据分发与复制</h2><p>在Cassandra内部，数据分发和复制都在一起。数据由表组织，由主键标识，该键确定数据存储在哪个节点上。副本是行的副本。当第一次写入数据时，它也被称为副本。</p><p>影响复制的因素包括:</p><ul><li><a href="http://docs.datastax.com/en/cassandra/3.0/cassandra/architecture/archDataDistributeVnodesUsing.html" target="_blank" rel="noopener">Virtual nodes</a>: 将数据所有权分配给物理机器.</li><li><a href="http://docs.datastax.com/en/cassandra/3.0/cassandra/architecture/archPartitionerAbout.html" target="_blank" rel="noopener">Partitioner</a>: 在集群中给数据分区.</li><li><a href="http://docs.datastax.com/en/cassandra/3.0/cassandra/architecture/archDataDistributeReplication.html" target="_blank" rel="noopener">Replication strategy</a>: 确定每行数据的副本.</li><li><a href="http://docs.datastax.com/en/cassandra/3.0/cassandra/architecture/archSnitchesAbout.html" target="_blank" rel="noopener">Snitch</a>: 定义复制策略用于放置副本的拓扑信息.</li></ul><h3 id="Consistent-hashing-一致性哈希"><a href="#Consistent-hashing-一致性哈希" class="headerlink" title="Consistent hashing 一致性哈希"></a>Consistent hashing 一致性哈希</h3><p>一致性hash允许跨集群的数据分布，以便添加或删除节点时，重组能最小化。一致性hash分区数据基于分区键。(<em>有关分区键和主键的说明，请参阅Cassandra 2.2及更高版本的CQL中的数据建模示例。</em>)</p><p>例如, 有以下数据:</p><table><thead><tr><th>name</th><th>age</th><th>car</th><th>gender</th></tr></thead><tbody><tr><td>jim</td><td>36</td><td>camaro</td><td>M</td></tr><tr><td>carol</td><td>37</td><td>bmw</td><td>F</td></tr><tr><td>johnny</td><td>12</td><td></td><td>M</td></tr><tr><td>suzy</td><td>10</td><td></td><td>F</td></tr></tbody></table><p>Cassandra为每个分区键分配一个hash值：</p><table><thead><tr><th>Partition key</th><th>Murmur3 hash value</th></tr></thead><tbody><tr><td>jim</td><td>-2245462676723223822</td></tr><tr><td>carol</td><td>7723358927203680754</td></tr><tr><td>johnny</td><td>-6723372854036780875</td></tr><tr><td>suzy</td><td>1168604627387940318</td></tr></tbody></table><p>集群中的每个节点都使用hash值来管理一系列数据。</p><p>一个四个节点的集群中的hash值。<img src="http://docs.datastax.com/en/cassandra/3.0/cassandra/images/arc_hashValueRange.png" alt="img"></p><p>Cassandra根据分区键的值和节点管理的范围将数据放在每个节点上。 例如，在四节点集群中，本示例中的数据分布如下：</p><table><thead><tr><th>Node</th><th>Start range</th><th>End range</th><th>Partition key</th><th>Hash value</th></tr></thead><tbody><tr><td>A</td><td>-9223372036854775808</td><td>-4611686018427387904</td><td>johnny</td><td>-6723372854036780875</td></tr><tr><td>B</td><td>-4611686018427387903</td><td>-1</td><td>jim</td><td>-2245462676723223822</td></tr><tr><td>C</td><td>0</td><td>4611686018427387903</td><td>suzy</td><td>1168604627387940318</td></tr><tr><td>D</td><td>4611686018427387904</td><td>9223372036854775807</td><td>carol</td><td>7723358927203680754</td></tr></tbody></table><h3 id="Virtual-nodes-虚拟节点"><a href="#Virtual-nodes-虚拟节点" class="headerlink" title="Virtual nodes(虚拟节点)"></a>Virtual nodes(虚拟节点)</h3><p>虚拟节点，一般简称为Vnodes，以更细粒度的方式在节点之间分配数据，而不是使用计算的token可以轻松实现的。 Vnodes简化了Cassandra中的许多任务：</p><ul><li>Tokens将自动计算并分配给每个节点。</li><li>添加或删除节点时，会自动实现重新平衡群集。 当节点加入集群时，它承担来自集群中其他节点的数据的偶数部分的责任。 如果一个节点出现故障，则负载在集群中的其他节点之间均匀分布。</li><li>重建宕机节点会更快，因为它本身就已经包含了集群中其他节点的信息。</li><li>分配给集群中的每个机器的vnode的比例可以调节，因此可以在构建群集时使用更小和更大的计算机。</li></ul><p>更多信息，请参阅Cassandra 1.2中的<a href="https://www.datastax.com/dev/blog/virtual-nodes-in-cassandra-1-2" target="_blank" rel="noopener">虚拟节点</a>。 要将现有集群转换为vnodes，请参阅<a href="http://docs.datastax.com/en/cassandra/3.0/cassandra/configuration/configVnodesProduction.html" target="_blank" rel="noopener">启用现有生产集群上的虚拟节点</a>。</p><h3 id="如何通过集群分布数据（使用虚拟节点）"><a href="#如何通过集群分布数据（使用虚拟节点）" class="headerlink" title="如何通过集群分布数据（使用虚拟节点）"></a>如何通过集群分布数据（使用虚拟节点）</h3><p>在Cassandra 1.2之前，您必须为群集中的每个节点计算并分配单个token。 每个token根据其hash值确定节点在环中的位置及其部分数据。在Cassandra 1.2及更高版本中，每个节点都允许许多token。 新的范例称为虚拟节点（Vnodes）。 Vnodes允许每个节点拥有分布在整个集群中的大量小分区范围。 Vnodes还使用一致hash来分发数据，但使用它们不需要生成和分配token。</p><p>虚拟化 vs 单token 架构<img src="http://docs.datastax.com/en/cassandra/3.0/cassandra/images/arc_vnodes_compare.png" alt="img"></p><p>上半部分图：显示没有vnodes的群集。 在这个范例中，每个节点都被分配一个代表环中位置的token。 每个节点存储通过将分区密钥映射到从先前节点到其分配值的范围内的令牌值所确定的数据。 每个节点还包含集群中其他节点的每一行的副本。 例如，如果复制因子为3，范围E复制到节点5,6和1.请注意，节点在环空间中只拥有一个连续的分区范围。</p><p>下半部分图：显示带有vnodes的环。 在集群中，虚拟节点被随机选择并且不连续。 行的放置由属于每个节点的许多较小分区范围内的分区密钥的hash确定。</p><h3 id="数据复制"><a href="#数据复制" class="headerlink" title="数据复制"></a>数据复制</h3><p>Cassandra将副本存储在多个节点上，以确保可靠性和容错能力。 复制策略确定放置副本的节点。 集群中的副本总数称为复制因子。 复制因子为1表示集群中每行只有一个副本。 如果包含行的节点关闭，则无法检索该行。 复制因子2表示每行的两个副本，其中每个副本位于不同的节点上。 所有副本同样重要; 没有主副本。 作为一般规则，复制因子不应超过集群中的节点数。 但是，您可以增加复制因子，然后稍后添加所需数量的节点。</p><p>以下是两种可用的复制策略：</p><ul><li><code>SimpleStrategy</code>: 仅用于单个数据中心和一个机架， 如果您打算使用多个数据中心，请使用 <code>NetworkTopologyStrategy</code>。</li><li><code>NetworkTopologyStrategy</code>: 强烈推荐用于大多数部署，因为在将来的扩展需要的时候，它更容易扩展到多个数据中心。</li></ul><ul><li><p>SimpleStrategy</p><p>仅用于单个数据中心和一个机架。 SimpleStrategy将第一个副本放置在由分区器确定的节点上。 额外的副本被放置在环的顺时针的下一个节点上，而不考虑拓扑（机架或数据中心位置）。</p></li></ul><ul><li><p>NetworkTopologyStrategy</p><p>您有（或计划拥有）多个数据中心部署的群集时，请使用NetworkTopologyStrategy。此策略指定每个数据中心中需要多少个副本.NetworkTopologyStrategy将副本放在同一个数据中心中，方法是顺时针旋转环直到到达另一个机架中的第一个节点。 NetworkTopologyStrategy尝试将副本放在不同的机架上，因为同一机架（或类似的物理分组）中的节点由于电源，冷却或网络问题而经常同时发生故障。当决定在每个数据中心配置多少份副本时，考虑因素是（1）能够本地满足读取，而不会导致跨数据中心延迟，以及（2）故障情形。配置多个数据中心集群的两种最常见方法是：每个数据中心中的两个副本：此配置可以容许每个复制组中的单个节点发生故障，并且仍然允许本地读取在一个一致性级别。每个数据中心的三个副本：此配置每个复制组中的一个节点在<code>LOCAL_QUORUM</code>的强一致性级别或使用一致性级别ONE的每个数据中心的多个节点故障时可能会发生故障。不对称复制分组也是可能的。例如，您可以在一个数据中心中拥有三个副本，以提供实时应用程序请求，并在其他地方使用单个副本来运行分析。</p></li></ul><p>每个密钥空间定义复制策略，并在密钥空间创建期间设置复制策略。 要设置密钥空间，请参阅<a href="http://docs.datastax.com/en/cql/3.3/cql/cql_using/useCreateKeyspace.html" target="_blank" rel="noopener">创建密钥空间</a>。</p><p>有关复制策略选项的更多信息，请参阅<a href="http://docs.datastax.com/en/cassandra/3.0/cassandra/operations/opsChangeKSStrategy.html" target="_blank" rel="noopener">更改密钥空间复制策略</a>。</p><h2 id="分区器"><a href="#分区器" class="headerlink" title="分区器"></a>分区器</h2><p>分区器确定数据如何在集群中的节点（包括副本）上分布。 基本上，分区器是用于从其分区键（通常通过散列）导出表示行的令牌的函数。 然后通过令牌的值将每行数据分布在集群中。</p><p><code>Murmur3Partitioner</code>和<code>RandomPartitioner</code>都使用令牌来帮助将相等的数据分配给每个节点，并将数据从所有表格均匀地分布在整个环或其他分组（例如键空间）中。 即使表格使用不同的<a href="http://docs.datastax.com/en/glossary/doc/glossary/gloss_partition_key.html" target="_blank" rel="noopener">分区键</a>（例如用户名或最小化）也是如此。 此外，对集群的读取和写入请求也是均匀分布的，并且简化了负载平衡，因为散列范围的每个部分平均接收到相等数量的行。 有关更多详细信息，请参阅<a href="http://docs.datastax.com/en/cassandra/3.0/cassandra/architecture/archDataDistributeHashing.html" target="_blank" rel="noopener">一致散列</a>。</p><p>两个分区器之间的主要区别是每个分区器如何生成token hash。 <code>RandomPartitioner</code>使用比<code>Murmur3Partitioner</code>更长的生成加密哈希值。 Cassandra并不需要加密散列，所以使用<code>Murmur3Partitioner</code>可以提高3-5倍的性能。</p><p>Cassandra提供了可以在<a href="http://docs.datastax.com/en/cassandra/3.0/cassandra/configuration/configCassandra_yaml.html" target="_blank" rel="noopener">cassandra.yaml file</a>文件中设置的以下分区器。</p><ul><li><code>Murmur3Partitioner</code> (默认): 基于MurmurHash哈希值，统一分布整个群集中的数据。</li><li><code>RandomPartitioner</code>: 根据MD5哈希值，统一分布整个群集的数据。</li><li><code>ByteOrderedPartitioner</code>: 通过关键字节保持数据的有序分布。</li></ul><p><code>Murmur3Partitioner</code>是Cassandra 1.2及更高版本的新集群的默认分区策略，几乎在所有情况下都是新集群的正确选择。 但是，分区器不兼容，并且用一个分区器分区的数据不能轻易地转换为其他分区器。</p><p><strong>Note</strong>:如果使用虚拟节点（vnodes），则不需要计算令牌。 如果不使用vnodes，则必须计算要分配给<a href="http://docs.datastax.com/en/cassandra/3.0/cassandra/architecture/archPartitionerAbout.html#archPartitionerAbout__cassandrayaml" target="_blank" rel="noopener">cassandra.yaml</a> 文件中的 <a href="http://docs.datastax.com/en/cassandra/3.0/cassandra/configuration/configCassandra_yaml.html#configCassandra_yaml__initial_token" target="_blank" rel="noopener">initial_token</a> 参数的令牌。 请参阅生成令牌，并使用您正在使用的分区器类型的方法。</p><h3 id="Murmur3Partitioner"><a href="#Murmur3Partitioner" class="headerlink" title="Murmur3Partitioner"></a>Murmur3Partitioner</h3><p><code>Murmur3Partitioner</code>是默认分区器。 <code>Murmur3Partitioner</code>提供比<code>RandomPartitioner</code>更快的hash和改进的性能。 <code>Murmur3Partitioner</code>可以与<code>vnodes</code>一起使用。 但是，如果不使用vnodes，则必须按照生成token中的描述计算token。</p><p>将Murmur3Partitioner用于新集群; 您不能更改使用其他分区器的现有群集中的分区。 Murmur3Partitioner使用MurmurHash功能。 此散列函数创建分区密钥的64位哈希值。 哈希值的可能范围是  到 -1。</p><p>使用Murmur3Partitioner时，可以使用CQL查询中的令牌功能来浏览所有行。</p><h3 id="RandomPartitioner"><a href="#RandomPartitioner" class="headerlink" title="RandomPartitioner"></a>RandomPartitioner</h3><p><code>RandomPartitioner</code>是Cassandra 1.2之前的默认分区器。 它被包括用于向后兼容。 <code>RandomPartitioner</code>可以与虚拟节点（vnodes）一起使用。 但是，如果不使用vnodes，则必须按照生成令牌中所述计算令牌.<code>RandomPartitioner</code>使用行密钥的MD5哈希值在节点间均匀分布数据。 哈希值的可能范围为0到 -1。</p><p>使用<code>RandomPartitioner</code>时，可以使用CQL查询中的令牌函数来浏览所有行。</p><h3 id="ByteOrderedPartitioner"><a href="#ByteOrderedPartitioner" class="headerlink" title="ByteOrderedPartitioner"></a>ByteOrderedPartitioner</h3><p>Cassandra提供了<code>ByteOrderedPartitioner</code>进行有序分区。 它被包括用于向后兼容。 该分区器按照字节顺序排列行。 您可以通过查看分区密钥数据的实际值并使用密钥中的主要字符的十六进制表示来计算token。 例如，如果要按字母顺序分区行，则可以使用其十六进制表示41来分配A token。</p><p>使用有序的分区器可以通过主键进行有序扫描。 这意味着您可以扫描行，就像您将光标移动到传统索引一样。 例如，如果您的应用程序具有用户名作为分区键，则可以扫描名称位于Jake和Joe之间的用户的行。 这种类型的查询不可能使用随机分区的分区键，因为密钥按照它们的MD5哈希（不是顺序）的顺序存储。</p><p>尽管有能力对行进行范围扫描听起来像有序分区器的理想特征，但是有一些方法可以使用表索引来实现相同的功能。</p><p>不推荐使用有序的分区器，原因如下：</p><ul><li><p>负载均衡困难</p><p>负载平衡集群需要更多的管理开销。 有序分区器要求管理员根据分区密钥分发的估计值手动计算分区范围。 在实践中，这需要主动移动节点token，以适应数据一旦被加载的实际分布。</p></li></ul><ul><li><p>顺序写入容易引起过热节点</p><p>如果您的应用程序一次写入或更新顺序的行块，则写入不会分布在集群中; 他们都去一个节点。 对于处理时间戳数据的应用程序，这通常是一个问题。</p></li></ul><ul><li><p>多表的负载平衡不均衡</p><p>如果您的应用程序有多个表，那么这些表有可能具有不同的行键和不同的数据分布。 对于一个表平衡的有序分区器可能会导致同一集群中另一个表的热点和不均匀分布。</p></li></ul><h2 id="Snitches"><a href="#Snitches" class="headerlink" title="Snitches"></a>Snitches</h2><p>Snitch决定哪个数据中心和架子节点属于哪个。他们将网络拓扑告知Cassandra，以便有效地路由请求，并允许Cassandra通过将机器分组到数据中心和机架来分发副本。具体来说，复制策略将副本基于新snitch提供的信息。所有节点必须返回到相同的机架和数据中心。Cassandra最好不要在同一个机架上有多个副本(这并不一定是一个物理位置)。</p><p>注意：如果您更改snitches，您可能需要执行其他步骤，因为snitch会影响放置副本的位置。 请参阅切换线程。</p><h3 id="动态报告"><a href="#动态报告" class="headerlink" title="动态报告"></a>动态报告</h3><p>默认情况下，所有的snitches都使用一个动态的snitch层来监视读取延迟，并且在可能的情况下，将请求路由到执行较差的节点。动态的snitch是默认启用的，建议在大多数部署中使用。有关如何工作的信息，请参见Cassandra:过去、现在和未来的动态snitch。为每个节点配置动态的snitch阈值。yaml配置文件。</p><p>有关更多信息，请参见在故障检测和恢复中列出的属性。</p><h3 id="SimpleSnitch"><a href="#SimpleSnitch" class="headerlink" title="SimpleSnitch"></a>SimpleSnitch</h3><p>SimpleSnitch(默认)只用于单数据中心部署。它不承认数据中心或机架信息，只能在公共云中的单数据中心部署或单区使用。它将策略顺序视为接近性，它可以在禁用读修复时提高缓存位置。</p><p>使用SimpleSnitch，您可以定义keyspace来使用SimpleStrategy并指定一个复制因子。</p><h3 id="RackInferringSnitch"><a href="#RackInferringSnitch" class="headerlink" title="RackInferringSnitch"></a>RackInferringSnitch</h3><p>The RackInferringSnitch determines the proximity of nodes by rack and datacenter, which are assumed to correspond to the 3rd and 2nd octet of the node’s IP address, respectively. This snitch is best used as an example for writing a custom snitch class (unless this happens to match your deployment conventions).</p><p>RackInferringSnitch决定了通过机架和数据中心的临近节点，这些节点被假定分别对应于节点IP地址的第3和第2个数字。这个snitch最好用于编写一个定制的snitch类(除非这恰好符合您的部署约定)。</p><p><img src="http://docs.datastax.com/en/cassandra/3.0/cassandra/images/arc_rack_inferring_snitch_ips.png" alt="img"></p><h3 id="PropertyFileSnitch"><a href="#PropertyFileSnitch" class="headerlink" title="PropertyFileSnitch"></a>PropertyFileSnitch</h3><p>这个snitch决定了由机架和数据中心决定的距离。它使用位于cassandra拓扑中的网络详细信息。属性文件。当使用这个snitch时，您可以定义您的数据中心名称来做任何您想要的。确保数据中心名称与keyspace定义中数据中心的名称相关。集群中的每个节点都应该在cassandra拓扑中描述。属性文件，这个文件在集群中的每个节点上都应该是完全相同的。</p><h3 id="Procedure"><a href="#Procedure" class="headerlink" title="Procedure"></a>Procedure</h3><p>如果您有不一致的IPs和两个物理数据中心，每一个都有两个机架，还有一个用于复制分析数据的第三个逻辑数据中心，即cassandra拓扑。属性文件可能是这样的:注意:数据中心和机架名称区分大小写。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># datacenter One</span><br><span class="line"></span><br><span class="line">175.56.12.105=DC1:RAC1</span><br><span class="line">175.50.13.200=DC1:RAC1</span><br><span class="line">175.54.35.197=DC1:RAC1</span><br><span class="line"></span><br><span class="line">120.53.24.101=DC1:RAC2</span><br><span class="line">120.55.16.200=DC1:RAC2</span><br><span class="line">120.57.102.103=DC1:RAC2</span><br><span class="line"></span><br><span class="line"># datacenter Two</span><br><span class="line"></span><br><span class="line">110.56.12.120=DC2:RAC1</span><br><span class="line">110.50.13.201=DC2:RAC1</span><br><span class="line">110.54.35.184=DC2:RAC1</span><br><span class="line"></span><br><span class="line">50.33.23.120=DC2:RAC2</span><br><span class="line">50.45.14.220=DC2:RAC2</span><br><span class="line">50.17.10.203=DC2:RAC2</span><br><span class="line"></span><br><span class="line"># Analytics Replication Group</span><br><span class="line"></span><br><span class="line">172.106.12.120=DC3:RAC1</span><br><span class="line">172.106.12.121=DC3:RAC1</span><br><span class="line">172.106.12.122=DC3:RAC1</span><br><span class="line"></span><br><span class="line"># default for unknown nodes </span><br><span class="line">default =DC3:RAC1</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;关于本文档&quot;&gt;&lt;a href=&quot;#关于本文档&quot; class=&quot;headerlink&quot; title=&quot;关于本文档&quot;&gt;&lt;/a&gt;关于本文档&lt;/h2&gt;&lt;p&gt;欢迎来到DataStax提供的Cassandra文档。 为确保您在使用本文档时获得最佳体验，请花点时间查看使用Dat
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Google API 权威指南</title>
    <link href="http://luxiangdong.com/2018/05/03/google-api/"/>
    <id>http://luxiangdong.com/2018/05/03/google-api/</id>
    <published>2018-05-03T05:41:14.000Z</published>
    <updated>2018-05-03T05:45:10.605Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>这是网络API的一般设计指南。自2014年以来，它已在Google内部使用，是Google在设计Cloud API和其他Google API时所遵循的指南。本设计指南在此共享，以通知外部开发人员，并使我们所有人更容易合作。</p><p>Google Cloud Endpoints开发人员可能会发现本指南在设计gRPC API时特别有用，我们强烈建议此类开发人员使用这些设计原则。但是，我们不要求使用它。您可以使用Cloud Endpoints和gRPC，而无需遵循指南。</p><p>本指南适用于REST API和RPC API，特别关注gRPC API。 gRPC API使用Protocol Buffersto定义其API表面和API服务配置来配置其API服务，包括HTTP映射，日志记录和监视。 HTTP映射功能由Google API和云端点用于JSON / HTTP到协议缓冲区/ RPC转码的gRPC API使用。</p><p>本指南是生活文件，随着时间的推移，新的风格和设计模式得到采纳和批准。以这种精神，它永远不会是完整的，而且API设计的艺术和手艺将永远有足够的空间。</p><h2 id="本文档的使用约定"><a href="#本文档的使用约定" class="headerlink" title="本文档的使用约定"></a>本文档的使用约定</h2><p>要求等级关键字“MUST”，“MUST NOT”，“REQUIRED”，“SHALL”，“SHALL NOT”，“SHOULD”，“SHOULD NOT”，“RECOMMENDED”，“MAY”和“OPTIONAL” 文档将被解释为RFC 2119中所述。</p><p>在本文档中，使用粗体字体突出显示这些关键字。</p><h1 id="面向资源设计"><a href="#面向资源设计" class="headerlink" title="面向资源设计"></a>面向资源设计</h1><p>本指南的总目标是为了帮助开发者设计简单、易用和风格一致性的网络API。 At the same time, it also helps converging designs of socket-based RPC APIs with HTTP-based REST APIs.</p><p>传统上，people design RPC APIs in terms of API interfaces and methods, such as CORBA and Windows COM. As time goes by, more and more interfaces and methods are introduced. The end result can be an overwhelming number of interfaces and methods, each of them different from the others. Developers have to learn each one carefully in order to use it correctly, which can be both time consuming and error prone.</p><p>REST架构风格第一次出现是在2000年左右, 主要目的是为了让在HTTP/1.1协议上更有效的工作。 它的核心思想是定义那些可以使用少量操作方法来操作的命名资源。The resources and methods are known as <em>名词</em> and <em>动词</em> of APIs. With the HTTP protocol, the resource names naturally map to URLs, and methods naturally map to HTTP methods <code>POST</code>, <code>GET</code>, <code>PUT</code>, <code>PATCH</code>, and <code>DELETE</code>.</p><p>在互联网上，HTTP REST API最近取得了巨大的成功。在2010年，大约74％的公共网络API是HTTP REST API。</p><p>虽然HTTP REST API在互联网上非常受欢迎，但它们传输的数据量比传统的RPC API小。例如，美国高峰时段的互联网流量的大约一半是视频内容，很少有人会因为性能原因考虑使用REST API来传送这些内容。在数据中心内部，许多公司使用基于插座的RPC API来承载大多数网络流量，这可能比公共REST API高出数量级。</p><p>实际上，由于各种原因需要RPC API和HTTP REST API。理想情况下，API平台应为所有API提供最佳支持。本设计指南可帮助您设计和构建符合这一原则的API。它通过将资源导向的设计原理应用于通用API设计来实现，并且定义了许多常见的设计模式以提高可用性并降低复杂性。</p><p>注意：本设计指南解释了如何将REST原理应用于独立于编程语言，操作系统或网络协议的API设计。它不仅仅是创建REST API的指南。</p><h2 id="What-is-a-REST-API"><a href="#What-is-a-REST-API" class="headerlink" title="What is a REST API?"></a>What is a REST API?</h2><p>REST API被建模为可单独寻址的资源（API的名词）的集合。 资源通过其资源名称引用，并通过一小组方法（也称为动词或操作）进行操作。</p><p>REST Google API（也称为REST方法）的标准方法是列表，获取，创建，更新和删除。 自定义方法（也称为自定义动词或自定义操作）也可用于API设计人员的功能，这些功能不容易映射到诸如数据库事务之类的标准方法之一。</p><p>注意：自定义动词并不意味着创建自定义HTTP动词以支持自定义方法。 对于基于HTTP的API，它们只是映射到最合适的HTTP动词。</p><h2 id="设计流程"><a href="#设计流程" class="headerlink" title="设计流程"></a>设计流程</h2><p>《设计指南》建议参照以下步骤设计面向资源的APIs:</p><ul><li>确定API提供的资源类型；</li><li>确定资源之间的关系；</li><li>基于资源的类型和关系确定资源的命名方式；</li><li>决定资源模式；</li><li>给资源附上最小化的方法集。</li></ul><h2 id="Resources"><a href="#Resources" class="headerlink" title="Resources"></a>Resources</h2><p>一个面向资源的API 通常都是按资源层级来建模的， 各层级的节点被称为资源或者资源集合。 简单起见， 我们往往分别称之为资源或者集合。</p><ul><li>一个集合包含一组<strong>相同类型</strong>的资源。比如，一个用户的所有联系人就是一个资源集合。</li><li>一个资源会有一些状态，也可能拥有几个子资源。每个子资源都可以表示一个资源或者一个资源集合。 </li></ul><p>Gmail的API拥有一组用户资源，每个用户又拥有消息资源集合，线程资源集合，标签资源集合等，一个描述资源和多个设置资源等。</p><p>虽然存储系统和REST API之间存在一些概念上的一致性，但面向资源的API的服务并不一定是数据库，在解释资源和方法方面具有很大的灵活性。 例如，创建一个日历事件(resource)可以为参与者创建额外的事件，发送电子邮件邀请到出席者，预订会议室，以及更新视频会议日程。</p><h2 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h2><p>面向资源的API的关键特性是它强调资源(数据模型)，而不是在资源(功能)上执行的方法。一个典型的面向资源的API使用少量的方法公开大量资源。这些方法可以是标准方法或者自定义方法。在本文中， 标准方法有: <code>List</code>, <code>Get</code>, <code>Create</code>, <code>Update</code>, and <code>Delete</code>.</p><p>如果API的功能可以自然地映射到某一标准方法，那么该方法应该在API设计中使用。对于不能自然映射到标准方法的功能，可以使用自定义方法。自定义方法提供了与传统RPC API相同的设计自由度，这些api可用于实现常见的编程模式，如数据库事务或数据分析。</p><h2 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h2><p>下面几节介绍了如何将面向资源的API设计应用于大型服务的一些实际示例。</p><h3 id="Gmail-API"><a href="#Gmail-API" class="headerlink" title="Gmail API"></a>Gmail API</h3><p>Gmail API服务实现了Gmail API，并暴露了Gmail的大部分功能。它有以下资源模型:</p><ul><li>Gmail API 服务: <code>gmail.googleapis.com</code></li><li>users的API集合: <code>users/*</code>. 每个用户都拥有以下资源。A collection of messages: <code>users/*/messages/*</code>.A collection of threads: <code>users/*/threads/*</code>.A collection of labels: <code>users/*/labels/*</code>.A collection of change history: <code>users/*/history/*</code>.A resource representing the user profile: <code>users/*/profile</code>.A resource representing user settings: <code>users/*/settings</code>.</li></ul><h3 id="Google-Cloud-Pub-Sub-API"><a href="#Google-Cloud-Pub-Sub-API" class="headerlink" title="Google Cloud Pub/Sub API"></a>Google Cloud Pub/Sub API</h3><p><code>pubsub.googleapis.com</code>服务实现了Google Cloud的订阅发布API，定义了以下资源模型：</p><ul><li>API服务：<code>pubsub.googleapis.com</code></li><li>主题集合：<code>projects/*/topics/</code>*。</li><li>订阅集合：<code>projects/*/subscriptions/*</code>。</li></ul><p>注意：Pub / Sub API的其他实现可以选择不同的资源命名方案。</p><h1 id="资源命名"><a href="#资源命名" class="headerlink" title="资源命名"></a>资源命名</h1><p>在面向资源的api中，资源被命名为实体，资源名是它们的标识符。每个资源都有自己独特的资源名。资源名是由资源本身的ID、任何父资源的ID和它的API服务名组成的。我们将在下面章节研究资源ID，以及如何构造资源名。</p><p>gRPC api应该为资源名使用无模式的uri。它们通常遵循REST的URL约定，并且表现得很像网络文件路径。它们可以很容易地映射到REST url:请参阅标准方法部分以获得详细信息。</p><p><strong>集合</strong>是一种特殊类型的资源，它包含相同类型的子资源列表。例如，目录是文件资源的集合。集合的资源ID称为集合ID。</p><p>资源名称使用集合ID和资源ID进行分层组织，以正斜杠分隔。 如果一个资源包含一个子资源，子资源的名称是通过指定父资源名称后跟子资源的ID来形成的，再次用正斜杠分隔。</p><p>Example 1: 存储服务有一组 <code>buckets</code>，每个 <code>buckets</code>都有一个对象集合:</p><table><thead><tr><th>API Service Name</th><th>Collection ID</th><th>Resource ID</th><th>Collection ID</th><th>Resource ID</th></tr></thead><tbody><tr><td>//storage.googleapis.com</td><td>/buckets</td><td>/bucket-id</td><td>/objects</td><td>/object-id</td></tr></tbody></table><p>Example 2: 电子邮件服务有一组用户。 每个用户都有一个设置子资源，并且设置子资源有许多其他子资源，包括<code>customFrom</code>：</p><table><thead><tr><th>API Service Name</th><th>Collection ID</th><th>Resource ID</th><th>Resource ID</th><th>Resource ID</th></tr></thead><tbody><tr><td>//mail.googleapis.com</td><td>/users</td><td>/<a href="mailto:name@example.com" target="_blank" rel="noopener">name@example.com</a></td><td>/settings</td><td>/customFrom</td></tr></tbody></table><p>只要在资源层次结构中它们是唯一的，API生产者可以为资源和集合ID选择任何可接受的值。 您可以在下面找到更多有关选择适当的资源和集合ID的准则。</p><p>通过拆分资源名称，例如name.split（“/”）[n]，假设没有一个段包含任何正斜杠，可以获取各个集合ID和资源ID。</p><h2 id="完整的资源名称"><a href="#完整的资源名称" class="headerlink" title="完整的资源名称"></a>完整的资源名称</h2><p>由DNS兼容的API服务名称和资源路径组成的无方案URI。 资源路径也称为相对资源名称。 例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;//library.googleapis.com/shelves/shelf1/books/book2&quot;</span><br></pre></td></tr></table></figure><p>API服务名称用于客户端定位API服务端点; 它可能是内部服务的假DNS名称。 如果API服务名称从上下文中显而易见，则通常使用相对的资源名称。</p><h2 id="相对路径资源名称"><a href="#相对路径资源名称" class="headerlink" title="相对路径资源名称"></a>相对路径资源名称</h2><p>没有前导“/”的URI路径（path-noscheme）。 它标识API服务中的资源。 例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;shelves/shelf1/books/book2&quot;</span><br></pre></td></tr></table></figure><h2 id="资源ID"><a href="#资源ID" class="headerlink" title="资源ID"></a>资源ID</h2><p>识别其父资源中资源的非空URI段（segment-nz-nc），请参见上述示例。</p><p>资源名称中的尾随资源ID可能有多个URI段。 例如：</p><table><thead><tr><th>Collection ID</th><th>Resource ID</th></tr></thead><tbody><tr><td>files</td><td>/source/py/parser.py</td></tr></tbody></table><p>API服务应在可行时使用URL友好的资源ID。 资源ID必须清楚记录，无论客户端，服务器还是由客户端分配。 例如，文件名通常由客户机分配，而电子邮件消息ID通常由服务器分配。</p><h2 id="集合ID"><a href="#集合ID" class="headerlink" title="集合ID"></a>集合ID</h2><p>标识其父资源中的集合资源的非空URI段（segment-nz-nc），请参见上述示例。</p><p>因为集合ID通常出现在生成的客户端库中，所以它们必须符合以下要求：</p><ul><li><strong>Must</strong>是有效的C / C ++标识符。</li><li><strong>Must</strong>是复数形式与lowerCamel case。</li><li><strong>Must</strong>使用清晰简明的英文术语。</li><li>应避免或超出合格范围。 例如，<code>RowValue</code>优于<code>Value</code>。 应该避免以下条款，无需资格：ElementEntryInstanceItemObjectResourceTypeValue</li></ul><h2 id="资源名-vs-URL"><a href="#资源名-vs-URL" class="headerlink" title="资源名 vs URL"></a>资源名 vs URL</h2><p>虽然完整的资源名称与普通URL相似，但它们并不一样。 单一资源可以由不同版本的API和不同的API协议公开。 完整的资源名称不指定此类信息，因此必须将其映射到特定协议和API版本以供实际使用。</p><p>要通过REST API使用完整的资源名称，必须通过在服务名称之前添加HTTPS方案，在资源路径之前添加API主版本以及将URL转义为资源路径，将其转换为REST URL。 例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// calendar事件资源名称.</span><br><span class="line">&quot;//calendar.googleapis.com/users/john smith/events/123&quot;</span><br><span class="line"></span><br><span class="line">// 相应的HTTP URL.</span><br><span class="line">&quot;https://calendar.googleapis.com/v3/users/john%20smith/events/123&quot;</span><br></pre></td></tr></table></figure><h2 id="Resource-Name-as-String"><a href="#Resource-Name-as-String" class="headerlink" title="Resource Name as String"></a>Resource Name as String</h2><p>Google API必须使用字符串来表示资源名称，除非是向后兼容性问题。 资源名称应该像普通文件路径一样处理，并且不支持％-encoding。</p><p>对于资源定义，第一个字段应该是资源名称的字符串字段，它应该被叫作<code>name</code>.</p><p><strong>Note:</strong> 其他相关的name字段应该避免混淆，比如 <code>display_name</code>, <code>first_name</code>, <code>last_name</code>, <code>full_name</code>.</p><p>例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">service LibraryService &#123;</span><br><span class="line">  rpc GetBook(GetBookRequest) returns (Book) &#123;</span><br><span class="line">    option (google.api.http) = &#123;</span><br><span class="line">      get: &quot;/v1/&#123;name=shelves/*/books/*&#125;&quot;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">  rpc CreateBook(CreateBookRequest) returns (Book) &#123;</span><br><span class="line">    option (google.api.http) = &#123;</span><br><span class="line">      post: &quot;/v1/&#123;parent=shelves/*&#125;/books&quot;</span><br><span class="line">      body: &quot;book&quot;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message Book &#123;</span><br><span class="line">  // Resource name of the book. It must have the format of &quot;shelves/*/books/*&quot;.</span><br><span class="line">  // For example: &quot;shelves/shelf1/books/book2&quot;.</span><br><span class="line">  string name = 1;</span><br><span class="line"></span><br><span class="line">  // ... other properties</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message GetBookRequest &#123;</span><br><span class="line">  // Resource name of a book. For example: &quot;shelves/shelf1/books/book2&quot;.</span><br><span class="line">  string name = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message CreateBookRequest &#123;</span><br><span class="line">  // Resource name of the parent resource where to create the book.</span><br><span class="line">  // For example: &quot;shelves/shelf1&quot;.</span><br><span class="line">  string parent = 1;</span><br><span class="line">  // The Book resource to be created. Client must not set the `Book.name` field.</span><br><span class="line">  Book book = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Note:</strong> 为了资源名称的一致性，前导正斜杠<strong>不能</strong>被任何URL模板变量捕获。 例如，必须使用URL模板<code>&quot;/v1/{name=shelves/*/books/*}&quot;</code>来代替<code>&quot;/v1{name=/shelves/*/books/*}&quot;</code>。</p><h1 id="标准方法"><a href="#标准方法" class="headerlink" title="标准方法"></a>标准方法</h1><p>本章节来定义标准方法的概念，这些方法是： <code>List</code>, <code>Get</code>, <code>Create</code>, <code>Update</code>, and <code>Delete</code>. 标准方法降低复杂性并提高一致性。超过70% 的Google API方法都是标准方法 ， 这使得他们更加易于学习和使用。</p><p>下表介绍了如何将标准方法映射到HTTP方法：</p><table><thead><tr><th>Standard Method</th><th>HTTP Mapping</th><th>HTTP Request Body</th><th>HTTP Response Body</th></tr></thead><tbody><tr><td><a href="https://cloud.google.com/apis/design/standard_methods#list" target="_blank" rel="noopener"><code>List</code></a></td><td><code>GET &lt;collection URL&gt;</code></td><td>Empty</td><td>Resource* list</td></tr><tr><td><a href="https://cloud.google.com/apis/design/standard_methods#get" target="_blank" rel="noopener"><code>Get</code></a></td><td><code>GET &lt;resource URL&gt;</code></td><td>Empty</td><td>Resource*</td></tr><tr><td><a href="https://cloud.google.com/apis/design/standard_methods#create" target="_blank" rel="noopener"><code>Create</code></a></td><td><code>POST &lt;collection URL&gt;</code></td><td>Resource</td><td>Resource*</td></tr><tr><td><a href="https://cloud.google.com/apis/design/standard_methods#update" target="_blank" rel="noopener"><code>Update</code></a></td><td><code>PUT or PATCH &lt;resource URL&gt;</code></td><td>Resource</td><td>Resource*</td></tr><tr><td><a href="https://cloud.google.com/apis/design/standard_methods#delete" target="_blank" rel="noopener"><code>Delete</code></a></td><td><code>DELETE &lt;resource URL&gt;</code></td><td>Empty</td><td>Empty**</td></tr></tbody></table><p>*从 <code>List</code>, <code>Get</code>, <code>Create</code>和 <code>Update</code> 方法返回的资源可能包含部分数据，如果方法支持字段掩码，指定要返回的字段的子集。 在某些情况下，API平台本身支持所有方法的字段掩码。</p><p><code>Delete</code>方法的返回响应，并不是立即删除资源（例如更新标志或创建长时间运行的删除操作）的Delete方法返回的响应应该包含长时间运行的操作或修改的资源。</p><p>对于在单个API调用的时间范围内未完成的请求，标准方法也可能返回长时间运行的操作。</p><p>以下部分详细介绍了每种标准方法。 示例显示.proto文件中定义的方法，其中包含HTTP映射的特殊注释。 您可以在Google API资源库中找到使用标准方法的许多示例。</p><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p><code>List</code>方法将集合名称和零个或多个参数作为输入，并返回与输入匹配的资源列表。</p><p><code>List</code>通常用于搜索资源， <code>List</code>适合来自单个集合的数据，该集合的大小有限，而不是高速缓存。 对于更广泛的情况，应使用<strong>自定义</strong>的<code>Search</code>方法。</p><p>批处理获取（如采用多个资源ID并返回每个ID的对象）的方法应该被实现为自定义<code>BatchGet</code>方法而不是<code>List</code></p><p>。 但是，如果您已有一个已经存在的<code>List</code>方法提供相同的功能，则可以重新使用<code>List</code>方法。 如果您使用自定义<code>BatchGet</code>方法，则应将其映射到<code>HTTP GET</code>。</p><p>适用的常见模式：分页，结果排序。</p><p>适用的命名约定：过滤器字段，结果字段。</p><p>HTTP映射:</p><ul><li><code>List</code> 方法b必须使用HTTP的<code>GET</code>动词.</li><li>接收列出其资源的集合的名称的请求消息字段应映射到URL路径。 如果集合名称映射到URL路径，则URL模板的最后一个段（集合ID）必须是字面值。</li><li>所有剩余的请求消息字段应映射到URL查询参数。</li><li>没有请求body，API配置不能声明一个body子句。</li><li>响应body应包含资源列表以及可选元数据。</li></ul><p>以下代码示例定义了一个书本集合的标准<code>List</code>方法 :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// 列出给定的书架上的所有书本。</span><br><span class="line">rpc ListBooks(ListBooksRequest) returns (ListBooksResponse) &#123;</span><br><span class="line">  // List method maps to HTTP GET.</span><br><span class="line">  option (google.api.http) = &#123;</span><br><span class="line">    // The `parent` captures the parent resource name, such as &quot;shelves/shelf1&quot;.</span><br><span class="line">    get: &quot;/v1/&#123;parent=shelves/*&#125;/books&quot;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message ListBooksRequest &#123;</span><br><span class="line">  // The parent resource name, for example, &quot;shelves/shelf1&quot;.</span><br><span class="line">  string parent = 1;</span><br><span class="line"></span><br><span class="line">  // The maximum number of items to return.</span><br><span class="line">  int32 page_size = 2;</span><br><span class="line"></span><br><span class="line">  // The next_page_token value returned from a previous List request, if any.</span><br><span class="line">  string page_token = 3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message ListBooksResponse &#123;</span><br><span class="line">  // The field name should match the noun &quot;books&quot; in the method name.  There</span><br><span class="line">  // will be a maximum number of items returned based on the page_size field</span><br><span class="line">  // in the request.</span><br><span class="line">  repeated Book books = 1;</span><br><span class="line"></span><br><span class="line">  // Token to retrieve the next page of results, or empty if there are no</span><br><span class="line">  // more results in the list.</span><br><span class="line">  string next_page_token = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Get"><a href="#Get" class="headerlink" title="Get"></a>Get</h2><p> <code>Get</code> 方法将有一个资源名，零或多个参数，和资源的返回值说明。</p><p>HTTP mapping:</p><ul><li>The <code>Get</code> 方法使用HTTP的<code>Get</code>形式。</li><li>The request message field(s) receiving the resource name <strong>should</strong> map to the URL path.</li><li>All remaining request message fields <strong>shall</strong> map to the URL query parameters.</li><li>There is no request body; the API configuration <strong>must not</strong> declare a <code>body</code> clause.</li><li>The returned resource <strong>shall</strong> map to the entire response body.</li></ul><p>The following code example defines a standard <code>Get</code> method that gets a specified book:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// Gets the specified book.</span><br><span class="line">rpc GetBook(GetBookRequest) returns (Book) &#123;</span><br><span class="line">  // Get maps to HTTP GET. Resource name is mapped to the URL. No body.</span><br><span class="line">  option (google.api.http) = &#123;</span><br><span class="line">    // Note the URL template variable which captures the multi-segment resource</span><br><span class="line">    // name of the requested book, such as &quot;shelves/shelf1/books/book2&quot;</span><br><span class="line">    get: &quot;/v1/&#123;name=shelves/*/books/*&#125;&quot;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message GetBookRequest &#123;</span><br><span class="line">  // The field will contain name of the resource requested, for example:</span><br><span class="line">  // &quot;shelves/shelf1/books/book2&quot;</span><br><span class="line">  string name = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Create"><a href="#Create" class="headerlink" title="Create"></a>Create</h2><p> <code>Create</code> 方法拥有一组名称，一个资源，零个或多个参数，它在指定的集合中创建一个新资源，并返回新创建的资源。</p><p>如果API支持创建资源，则应该为可以创建的每种资源类型创建一个<code>Create</code>方法。</p><p>HTTP映射：</p><ul><li><code>Create</code>方法必须使用HTTP <code>POST</code>动词。</li><li>请求消息应该有一个字段<code>parent</code>，指定资源要创建的父资源名称。</li><li>所有剩余的请求消息字段应映射到URL查询参数。</li><li>请求可能包含名为<code>&lt;resource&gt;_id</code>的字段，以允许呼叫者选择客户端分配的ID。 该字段必须映射到URL查询参数。</li><li>包含资源的请求消息字段应映射到请求主体。 如果<code>body</code>的HTTP配置子句用于<code>Create</code>方法，则必须使用<code>body：&quot;&lt;resource_field&gt;&quot;</code>表单。</li><li>返回的资源将映射到整个响应体。</li></ul><p>如果<code>Create</code>方法支持客户端分配的资源名称并且资源已经存在，则该请求应该失败，并出现错误代码<code>google.rpc.Code.ALREADY_EXISTS</code>，或使用不同的服务器分配的资源名称，并且文档应清楚创建的资源名称 可能与传入的不同。</p><p>以下代码示例定义了一个标准的<code>Create</code>方法，该方法在父书架内创建一本书：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">rpc CreateBook(CreateBookRequest) returns (Book) &#123;</span><br><span class="line">  // Create maps to HTTP POST. URL path as the collection name.</span><br><span class="line">  // HTTP request body contains the resource.</span><br><span class="line">  option (google.api.http) = &#123;</span><br><span class="line">    // The `parent` captures the parent resource name, such as &quot;shelves/1&quot;.</span><br><span class="line">    post: &quot;/v1/&#123;parent=shelves/*&#125;/books&quot;</span><br><span class="line">    body: &quot;book&quot;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message CreateBookRequest &#123;</span><br><span class="line">  // The parent resource name where the book to be created.</span><br><span class="line">  string parent = 1;</span><br><span class="line"></span><br><span class="line">  // The book id to use for this book.</span><br><span class="line">  string book_id = 3;</span><br><span class="line"></span><br><span class="line">  // The book resource to create.</span><br><span class="line">  // The field name should match the Noun in the method name.</span><br><span class="line">  Book book = 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rpc CreateShelf(CreateShelfRequest) returns (Shelf) &#123;</span><br><span class="line">  option (google.api.http) = &#123;</span><br><span class="line">    post: &quot;/v1/shelves&quot;</span><br><span class="line">    body: &quot;shelf&quot;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message CreateShelfRequest &#123;</span><br><span class="line">  Shelf shelf = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h2><p><code>Update</code>方法接收包含资源和零个或多个参数的请求消息。 它更新指定的资源及其属性，并返回更新的资源。</p><p>可变资源属性应该由<code>Update</code>方法可变，除了包含资源名称或父属性。 <strong>重新命名或移动资源</strong>的任何功能不得在<code>Update</code>方法中发生，而应由自定义方法处理。</p><p>HTTP映射：</p><ul><li>标准<code>Update</code>方法应该支持部分资源更新，并使用名为<code>update_mask</code>的<code>FieldMask</code>字段的HTTP动词<code>PATCH</code>。</li><li>需要使用更高级的修补语义（如附加到重复字段）的<code>Update</code>方法应该通过自定义方法提供。</li><li>如果<code>Update</code>方法仅支持完全资源更新，则必须使用HTTP动词<code>PUT</code>。 但是，完全更新非常不鼓励，因为在添加新的资源字段时它具有向后的兼容性问题。</li><li>接收资源名称的消息字段必须映射到URL路径。 该字段可能在资源消息本身中。</li><li>包含资源的请求消息字段必须映射到请求主体。</li><li>所有剩余的请求消息字段必须映射到URL查询参数。</li><li>响应消息必须是更新的资源本身。</li></ul><p>如果API接受客户端分配的资源名称，则服务器可能允许客户端指定不存在的资源名称并创建新的资源。 否则，<code>Update</code>方法应该以不存在的资源名称失败。 如果它是唯一的错误条件，则应使用错误代码<code>NOT_FOUND</code>。</p><p>具有支持资源创建的<code>Update</code>方法的API还应提供<code>Create</code>方法。 理由是，如果<code>Update</code>方法是唯一的方法，它不清楚如何创建资源。</p><p>以下代码示例定义了更新指定书籍的标准<code>Update</code>方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">rpc UpdateBook(UpdateBookRequest) returns (Book) &#123;</span><br><span class="line">  // Update maps to HTTP PATCH. Resource name is mapped to a URL path.</span><br><span class="line">  // Resource is contained in the HTTP request body.</span><br><span class="line">  option (google.api.http) = &#123;</span><br><span class="line">    // Note the URL template variable which captures the resource name of the</span><br><span class="line">    // book to update.</span><br><span class="line">    patch: &quot;/v1/&#123;book.name=shelves/*/books/*&#125;&quot;</span><br><span class="line">    body: &quot;book&quot;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message UpdateBookRequest &#123;</span><br><span class="line">  // The book resource which replaces the resource on the server.</span><br><span class="line">  Book book = 1;</span><br><span class="line"></span><br><span class="line">  // The update mask applies to the resource. For the `FieldMask` definition,</span><br><span class="line">  // see https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#fieldmask</span><br><span class="line">  FieldMask update_mask = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h2><p> <code>Delete</code> 方法使用资源名称和零个或多个参数，并删除或调度以删除指定的资源。 <code>Delete</code>方法应该返回<code>google.protobuf.Empty</code>。</p><p>API不应该依赖于<code>Delete</code>方法返回的任何信息，因为它不能重复调用。</p><p>HTTP映射：</p><ul><li>Delete方法必须使用HTTP <code>DELETE</code>动词。</li><li>接收资源名称的请求消息字段应映射到URL路径。</li><li>所有剩余的请求消息字段应映射到URL查询参数。</li><li>没有请求机构 API配置不能声明一个<code>body</code>子句。</li><li>如果<code>Delete</code>方法立即删除资源，它应该返回一个空的响应。</li><li>如果<code>Delete</code>方法启动长时间运行的操作，则应返回长时间运行的操作。</li><li>如果<code>Delete</code>方法仅将资源标记为已删除，则应返回更新的资源。</li></ul><p>Calls to the <code>Delete</code> method should be <a href="http://tools.ietf.org/html/rfc2616#section-9.1.2" target="_blank" rel="noopener">idempotent</a> in effect, but do not need to yield the same response. Any number of<code>Delete</code> requests <strong>should</strong> result in a resource being (eventually) deleted, but only the first request should result in a success code. Subsequent requests should result in a <code>google.rpc.Code.NOT_FOUND</code>.</p><p>The following code example defines a standard <code>Delete</code> method that deletes a specified book:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">rpc DeleteBook(DeleteBookRequest) returns (google.protobuf.Empty) &#123;</span><br><span class="line">  // Delete maps to HTTP DELETE. Resource name maps to the URL path.</span><br><span class="line">  // There is no request body.</span><br><span class="line">  option (google.api.http) = &#123;</span><br><span class="line">    // Note the URL template variable capturing the multi-segment name of the</span><br><span class="line">    // book resource to be deleted, such as &quot;shelves/shelf1/books/book2&quot;</span><br><span class="line">    delete: &quot;/v1/&#123;name=shelves/*/books/*&#125;&quot;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message DeleteBookRequest &#123;</span><br><span class="line">  // The resource name of the book to be deleted, for example:</span><br><span class="line">  // &quot;shelves/shelf1/books/book2&quot;</span><br><span class="line">  string name = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="自定义方法"><a href="#自定义方法" class="headerlink" title="自定义方法"></a>自定义方法</h1><p>本章节我们将讨论如何使用自定义方法来设计API。</p><p>除了5种标准方法之外，定制方法是指API方法。 它们只能用于<strong>不能通过标准方法表达的功能</strong>。 一般情况下，API设计人员应该在可行时选择使用自定义方法的标准方法。 标准方法有大多数开发人员熟悉的更简单和定义明确的语义，因此它们易于使用，并且容易出错。 标准方法的另一个优点是API平台对标准方法（如计费，错误处理，日志记录和监视）有更好的理解和支持。</p><p>自定义方法可以与资源，集合或服务相关联。 它可能需要任意的请求并返回任意的响应，并且还支持流请求和响应。</p><p>自定义方法名称必须遵循<a href="https://cloud.google.com/apis/design/naming_convention#method_names" target="_blank" rel="noopener">方法命名约定</a>.</p><h2 id="HTTP-mapping"><a href="#HTTP-mapping" class="headerlink" title="HTTP mapping"></a>HTTP mapping</h2><p>对于自定义方法，他们应该使用以下通用HTTP映射：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://service.name/v1/some/resource/name:customVerb</span><br></pre></td></tr></table></figure><p>使用<code>：</code>而不是<code>/</code>将资源名称中的自定义动词分开的原因是可以支持任意路径。 例如，取消删除文件可以映射到 <code>POST /files/a/long/file/name:undelete</code></p><p>选择HTTP映射时应适用以下准则：</p><ul><li>自定义方法应该使用HTTP <code>POST</code>动词，因为它具有最灵活的语义。</li><li>自定义方法不应该使用HTTP <code>PATCH</code>，但可能使用其他HTTP动词。在这种情况下，方法必须遵循该动词的标准HTTP语义。</li><li>值得注意的是，使用HTTP <code>GET</code>的自定义方法必须是幂等的，没有副作用。例如，在资源上实现特殊视图的自定义方法应该使用HTTP <code>GET</code>。</li><li>接收与自定义方法相关联的资源或集合的资源名称的请求消息字段应映射到URL路径。</li><li>URL路径必须以后缀为自定义动词的冒号结尾。</li><li>如果用于自定义方法的HTTP动词允许HTTP请求体（<code>POST</code>，<code>PUT</code>，<code>PATCH</code>或自定义HTTP动词），则此类自定义方法的HTTP配置必须使用<code>body：&quot;*&quot;</code>子句和所有其余请求消息字段应映射到HTTP请求体。</li><li>如果用于自定义方法的HTTP动词不接受HTTP请求体（<code>GET</code>，<code>DELETE</code>），则此类方法的HTTP配置根本不能使用<code>body</code>子句，所有剩余的请求消息字段都应映射到URL查询参数。</li></ul><p><strong>WARNING</strong>: If a service implements multiple APIs, the API producer <strong>must</strong> carefully create the service configuration to avoid custom verb conflicts between APIs.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// This is a service level custom method.</span><br><span class="line">rpc Watch(WatchRequest) returns (WatchResponse) &#123;</span><br><span class="line">  // Custom method maps to HTTP POST. All request parameters go into body.</span><br><span class="line">  option (google.api.http) = &#123;</span><br><span class="line">    post: &quot;/v1:watch&quot;</span><br><span class="line">    body: &quot;*&quot;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// This is a collection level custom method.</span><br><span class="line">rpc ClearEvents(ClearEventsRequest) returns (ClearEventsResponse) &#123;</span><br><span class="line">  option (google.api.http) = &#123;</span><br><span class="line">    post: &quot;/v3/events:clear&quot;</span><br><span class="line">    body: &quot;*&quot;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// This is a resource level custom method.</span><br><span class="line">rpc CancelEvent(CancelEventRequest) returns (CancelEventResponse) &#123;</span><br><span class="line">  option (google.api.http) = &#123;</span><br><span class="line">    post: &quot;/v3/&#123;name=events/*&#125;:cancel&quot;</span><br><span class="line">    body: &quot;*&quot;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// This is a batch get custom method.</span><br><span class="line">rpc BatchGetEvents(BatchGetEventsRequest) returns (BatchGetEventsResponse) &#123;</span><br><span class="line">  // The batch get method maps to HTTP GET verb.</span><br><span class="line">  option (google.api.http) = &#123;</span><br><span class="line">    get: &quot;/v3/events:batchGet&quot;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="用例"><a href="#用例" class="headerlink" title="用例"></a>用例</h2><p>其他一些使用自定义方法可能是正确选择的情况：</p><ul><li><strong>重启虚拟机.</strong> 设计备选方案可能是“重新启动收集重新引导资源”，其感觉不成比例地复杂，或者“虚拟机具有客户端可以从RUNNING更新到RESTARTING”的可变状态，这将打开关于哪些其他状态转换是可能的问题。 此外，重新启动是一个众所周知的概念，可以很好地转换为直观满足开发人员期望的自定义方法。</li><li><strong>邮件发送.</strong> 创建电子邮件不一定会发送（可以暂存于草稿）。 与设计的替代方案（将消息移动到“发件箱”集合）相比，自定义方法具有API用户更易于发现的优点，并更直接地模拟概念。</li><li><strong>激励员工.</strong> 如果实现是一个标准更新，客户端将不得不复制管理激励过程的公司政策，以确保激励在相同的职业阶梯中发生正确的水平。</li><li><strong>批量方法.</strong> 对于性能关键方法，提供自定义批处理方法以减少每个请求开销可能是有用的。 例如，<code>accounts.locations.batchGet</code>。</li></ul><p>标准方法比自定义方法更合适的几个例子：</p><ul><li>使用不同的查询参数查询资源（使用标准<code>list</code>过滤的标准列表方法）。</li><li>简单的资源属性更改（使用具有字段掩码的标准<code>update</code>方法）。</li><li>关闭通知（使用标准<code>delete</code>方法）。</li></ul><h2 id="通用的自定义方法"><a href="#通用的自定义方法" class="headerlink" title="通用的自定义方法"></a>通用的自定义方法</h2><p>常用或有用的自定义方法名称的策略列表如下。 API设计人员在引入自己的API之前应该考虑这些名称，以便于跨API的一致性。</p><table><thead><tr><th>方法名称</th><th>自定义谓语</th><th>HTTP 谓语</th><th>注释</th></tr></thead><tbody><tr><td>Cancel</td><td><code>:cancel</code></td><td><code>POST</code></td><td>取消未完成的操作（构建，计算等）。</td></tr><tr><td>BatchGet<plural noun=""></plural></td><td><code>:batchGet</code></td><td><code>GET</code></td><td>批量获取多个资源。 （详见列表的说明）</td></tr><tr><td>Move</td><td><code>:move</code></td><td><code>POST</code></td><td>将资源从一个父项移动到另一个父项。</td></tr><tr><td>Search</td><td><code>:search</code></td><td><code>GET</code></td><td>用于获取不符合List语义的数据的List的替代方法。</td></tr><tr><td>Undelete</td><td><code>:undelete</code></td><td><code>POST</code></td><td>还原以前删除的资源。 推荐的保留期为30天。</td></tr></tbody></table><h1 id="标准字段"><a href="#标准字段" class="headerlink" title="标准字段"></a>标准字段</h1><p>本节介绍在需要类似概念时应使用的一组标准消息字段定义。 这将确保相同的概念在不同的API中具有相同的名称和语义。</p><table><thead><tr><th>名称</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td><code>name</code></td><td><code>string</code></td><td><code>name</code> 字段应包含相对资源名称。</td></tr><tr><td><code>parent</code></td><td><code>string</code></td><td>对于资源定义和<code>List</code>/<code>Create</code>请求，<code>parent</code>字段应包含父相对资源名称。</td></tr><tr><td><code>create_time</code></td><td><a href="https://github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto" target="_blank" rel="noopener"><code>Timestamp</code></a></td><td>实体的创建时间戳。</td></tr><tr><td><code>update_time</code></td><td><a href="https://github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto" target="_blank" rel="noopener"><code>Timestamp</code></a></td><td>实体的最后更新时间戳。 注意：执行<code>create</code>/ <code>patch</code> /<code>delete</code>操作时<code>update_time</code>被更新。</td></tr><tr><td><code>delete_time</code></td><td><a href="https://github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto" target="_blank" rel="noopener"><code>Timestamp</code></a></td><td>实体的删除时间戳记，只有当它支持保留时。</td></tr><tr><td><code>time_zone</code></td><td><code>string</code></td><td>时区名称。 它应该是IANA TZ名称，例如“America / Los_Angeles”。 有关详细信息，请参阅<a href="https://en.wikipedia.org/wiki/List_of_tz_database_time_zones" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/List_of_tz_database_time_zones</a>。</td></tr><tr><td><code>region_code</code></td><td><code>string</code></td><td>位置的Unicode国家/地区代码（CLDR），例如“US”和“419”。 有关详细信息，请参阅<a href="http://www.unicode.org/reports/tr35/#unicode_region_subtag" target="_blank" rel="noopener">http://www.unicode.org/reports/tr35/#unicode_region_subtag</a>。</td></tr><tr><td><code>language_code</code></td><td><code>string</code></td><td>BCP-47语言代码，如“en-US”或“sr-Latn”。 有关详细信息，请参阅<a href="http://www.unicode.org/reports/tr35/#Unicode_locale_identifier" target="_blank" rel="noopener">http://www.unicode.org/reports/tr35/#Unicode_locale_identifier</a>。</td></tr><tr><td><code>display_name</code></td><td><code>string</code></td><td>实体的显示名称。</td></tr><tr><td><code>title</code></td><td><code>string</code></td><td>实体的正式名称，如公司名称。 它应该被视为<code>display_name</code>的正式版本。</td></tr><tr><td><code>description</code></td><td><code>string</code></td><td>实体的一个或多个文本描述段落。</td></tr><tr><td><code>filter</code></td><td><code>string</code></td><td>List方法的标准过滤器参数。</td></tr><tr><td><code>query</code></td><td><code>string</code></td><td>如果应用于搜索方法（即：搜索），则与<code>filter</code>相同(ie <a href="https://cloud.google.com/apis/design/custom_methods#common_custom_methods" target="_blank" rel="noopener"><code>:search</code></a>)</td></tr><tr><td><code>page_token</code></td><td><code>string</code></td><td>列表请求中的分页令牌。</td></tr><tr><td><code>page_size</code></td><td><code>int32</code></td><td>列表请求中的分页大小。</td></tr><tr><td><code>total_size</code></td><td><code>int32</code></td><td>列表中的项目总数，不管分页。</td></tr><tr><td><code>next_page_token</code></td><td><code>string</code></td><td>List响应中的下一个分页令牌。 它应该用作<code>page_token</code>作为以下请求。 一个空值意味着没有更多的结果。</td></tr><tr><td><code>order_by</code></td><td><code>string</code></td><td>指定列表请求的结果顺序。</td></tr><tr><td><code>request_id</code></td><td><code>string</code></td><td>用于检测重复请求的唯一字符串ID。</td></tr><tr><td><code>resume_token</code></td><td><code>string</code></td><td>用于恢复流请求的不透明令牌。</td></tr><tr><td><code>labels</code></td><td><code>map&lt;string,string&gt;</code></td><td>表示云资源标签。</td></tr><tr><td><code>deleted</code></td><td><code>bool</code></td><td>如果一个资源允许取消删除行为，它必须有一个已<code>deleted</code>的字段，指示资源被删除。</td></tr><tr><td><code>show_deleted</code></td><td><code>bool</code></td><td>如果资源允许取消删除行为，则相应的列表方法必须具有<code>show_deleted</code>字段，以便客户端可以发现已删除的资源。</td></tr><tr><td><code>update_mask</code></td><td><a href="https://github.com/google/protobuf/blob/master/src/google/protobuf/field_mask.proto" target="_blank" rel="noopener"><code>FieldMask</code></a></td><td>它用于<code>Update</code>请求消息，用于对资源执行部分更新。</td></tr><tr><td><code>validate_only</code></td><td><code>bool</code></td><td>如果为true，表示给定的请求只能被验证，而不是执行。</td></tr></tbody></table><h1 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h1><p>本章概述了Google API错误模型以及开发人员如何正确生成和处理错误的一般指导。</p><p>Google API使用简单的协议无关错误模型，可让我们在不同的API，API协议（如gRPC或HTTP）以及错误上下文（例如异步，批处理或工作流错误）中公开一致的体验。</p><h2 id="错误模型"><a href="#错误模型" class="headerlink" title="错误模型"></a>错误模型</h2><p>错误模型由<code>google.rpc.Status</code>在逻辑上定义，当发生API错误时，它的一个实例返回给客户端。 以下代码片段显示了错误模型的总体设计：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package google.rpc;</span><br><span class="line"></span><br><span class="line">message Status &#123;</span><br><span class="line">  // A simple error code that can be easily handled by the client. The</span><br><span class="line">  // actual error code is defined by `google.rpc.Code`.</span><br><span class="line">  int32 code = 1;</span><br><span class="line"></span><br><span class="line">  // A developer-facing human-readable error message in English. It should</span><br><span class="line">  // both explain the error and offer an actionable resolution to it.</span><br><span class="line">  string message = 2;</span><br><span class="line"></span><br><span class="line">  // Additional error information that the client code can use to handle</span><br><span class="line">  // the error, such as retry delay or a help link.</span><br><span class="line">  repeated google.protobuf.Any details = 3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于大多数Google API都使用面向资源的API设计，所以错误处理遵循相同的设计原则，通过使用一小批具有大量资源的标准错误。 例如，服务器不是定义不同种类的“未找到”错误，而是使用一个标准的<code>google.rpc.Code.NOT_FOUND</code>错误代码，告诉客户端没有找到哪个特定的资源。 较小的状态空间减少了文档的复杂性，在客户端库中提供了更好的惯用映射，并降低了客户端逻辑复杂性，同时不限制包含可操作信息。</p><h2 id="错误码"><a href="#错误码" class="headerlink" title="错误码"></a>错误码</h2><p>Google API必须使用<code>google.rpc.Code</code>定义的规范错误代码。 单独的API应避免定义其他错误代码，因为开发人员不太可能编写逻辑来处理大量的错误代码。 作为参考，每个API调用平均处理3个错误代码意味着大多数应用程序逻辑只是用于错误处理，这不是一个好的开发者体验。</p><h2 id="错误消息"><a href="#错误消息" class="headerlink" title="错误消息"></a>错误消息</h2><p>错误消息可以帮助用户轻松快速地了解和解决API错误。 一般来说，在编写错误消息时，请考虑以下准则：</p><ul><li>不要以为用户是API的专家用户。 用户可以是客户开发人员，操作人员，IT人员或应用程序的最终用户。</li><li>不要以为用户了解您的服务实现或熟悉错误的上下文（如日志分析）。</li><li>如果可能，应构建错误消息，以便技术用户（但不一定是API的开发人员）可以对错误进行响应并进行更正。</li><li>保留错误消息简短。 如果需要，请提供一个链接，让困惑的读者可以提出问题，提供反馈或获取不完全符合错误信息的更多信息。 否则，使用详细信息字段来展开。</li></ul><h2 id="错误详情"><a href="#错误详情" class="headerlink" title="错误详情"></a>错误详情</h2><p>Google API为错误详细信息定义了一组标准错误有效载荷，您可以在<a href="https://github.com/googleapis/googleapis/blob/master/google/rpc/error_details.proto" target="_blank" rel="noopener">google/rpc/error_details.proto</a>中找到。这些涵盖了API错误最常见的需求，例如配额失败和无效参数。像错误代码一样，错误细节应尽可能使用这些标准有效载荷。</p><p>只有在可以帮助应用程序代码来处理错误的情况下，才应引入附加的错误详细信息类型。如果错误信息只能由人类处理，请依赖于错误消息内容，让开发人员手动处理错误信息，而不是引入新的错误详细信息类型。请注意，如果引入了其他错误详细信息类型，则必须明确注册它们。</p><p>以下是一些示例<code>error_details</code>的有效载荷：</p><ul><li><code>RetryInfo</code>描述当客户端可以重试失败的请求时，可能会在<code>Code.UNAVAILABLE</code>或<code>Code.ABORTED</code>上返回</li><li><code>QuotaFailure</code>描述配额检查如何失败，可能会在<code>Code.RESOURCE_EXHAUSTED</code>上返回</li><li><code>BadRequest</code>描述客户端请求中的违规行为，可以在<code>Code.INVALID_ARGUMENT</code>上返回</li></ul><h2 id="HTTP映射"><a href="#HTTP映射" class="headerlink" title="HTTP映射"></a>HTTP映射</h2><p>虽然proto3消息具有本地化的JSON编码，但Google的API平台使用以下JSON表示形式进行直接的HTTP-JSON错误响应，以允许向后兼容性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;error&quot;: &#123;</span><br><span class="line">    &quot;code&quot;: 401,</span><br><span class="line">    &quot;message&quot;: &quot;Request had invalid credentials.&quot;,</span><br><span class="line">    &quot;status&quot;: &quot;UNAUTHENTICATED&quot;,</span><br><span class="line">    &quot;details&quot;: [&#123;</span><br><span class="line">      &quot;@type&quot;: &quot;type.googleapis.com/google.rpc.RetryInfo&quot;,</span><br><span class="line">      ...</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>字段</th><th>描述</th></tr></thead><tbody><tr><td><code>error</code></td><td>额外的层面是为了向后兼容Google API客户端库。 它还使JSON表示对人类更加可读。</td></tr><tr><td><code>code</code></td><td><code>Status.code</code>的HTTP状态代码映射</td></tr><tr><td><code>message</code></td><td>对应 <code>Status.message</code></td></tr><tr><td><code>status</code></td><td>对应 <code>Status.code</code></td></tr><tr><td><code>details</code></td><td>对应 <code>Status.details</code></td></tr></tbody></table><h2 id="RPC映射"><a href="#RPC映射" class="headerlink" title="RPC映射"></a>RPC映射</h2><p>不同的RPC协议以不同的方式映射错误模型。 对于<code>gRPC</code>，错误模型由生成的代码和每种支持的语言的运行时库本机支持。 您可以在gRPC的API文档中找到更多内容（例如，请参阅gRPC Java的<code>io.grpc.Status</code>）。</p><h2 id="客户端库映射"><a href="#客户端库映射" class="headerlink" title="客户端库映射"></a>客户端库映射</h2><p>Google客户端库可能会选择以不同的语言来表现错误，以符合既定习惯。 例如，<code>google-cloud-go</code>库将返回一个实现与<code>google.rpc.Status</code>相同的界面的错误，而<code>google-cloud-java</code>会引发一个异常。</p><h2 id="本地化错误提示"><a href="#本地化错误提示" class="headerlink" title="本地化错误提示"></a>本地化错误提示</h2><p><code>google.rpc.Status</code>中的<code>message</code>字段是面向开发人员的，必须是英文。</p><p>如果需要面向用户的错误消息，请使用<code>google.rpc.LocalizedMessage</code>作为您的详细信息字段。 虽然<code>google.rpc.LocalizedMessage</code>中的邮件字段可以进行本地化，但请确保<code>google.rpc.Status</code>中的邮件字段为英文。</p><p>默认情况下，API服务应使用经过身份验证的用户的区域设置或HTTP <code>Accept-Language</code>标头来确定本地化的语言。</p><h2 id="错误处理机制"><a href="#错误处理机制" class="headerlink" title="错误处理机制"></a>错误处理机制</h2><p>以下是包含<code>google.rpc.Code</code>中定义的所有gRPC错误代码的表格，以及其原因的简短说明。 要处理错误，您可以检查返回的状态代码的描述，并相应地修改您的呼叫。</p><table><thead><tr><th>HTTP</th><th>RPC</th><th>描述</th></tr></thead><tbody><tr><td>200</td><td><code>OK</code></td><td>正常.</td></tr><tr><td>400</td><td><code>INVALID_ARGUMENT</code></td><td>客户端指定了无效参数，检查错误信息和错误详细信息以获取更多信息。</td></tr><tr><td>400</td><td><code>FAILED_PRECONDITION</code></td><td>请求无法在当前系统状态下执行，如删除非空目录。</td></tr><tr><td>400</td><td><code>OUT_OF_RANGE</code></td><td>过界，客户端需要指明无效范围。</td></tr><tr><td>401</td><td><code>UNAUTHENTICATED</code></td><td>由于缺失、无效或过期的OAuth token，请求未通过身份验证。</td></tr><tr><td>403</td><td><code>PERMISSION_DENIED</code></td><td>客户端没有足够的权限。这可能是因为OAuth token没有正确的范围，客户端没有权限，还没有为客户端项目启用API。</td></tr><tr><td>404</td><td><code>NOT_FOUND</code></td><td>指定资源没有被发现，或者该请求被未公开的原因拒绝，例如白名单。</td></tr><tr><td>409</td><td><code>ABORTED</code></td><td>并发冲突，如读 - 修改 - 写冲突。</td></tr><tr><td>409</td><td><code>ALREADY_EXISTS</code></td><td>客户端尝试创建的资源已经存在。</td></tr><tr><td>429</td><td><code>RESOURCE_EXHAUSTED</code></td><td>资源配额或者达到限制速率，客户端应该查找google.rpc.QuotaFailure错误详细信息以获取更多信息。</td></tr><tr><td>499</td><td><code>CANCELLED</code></td><td>请求被客户取消。</td></tr><tr><td>500</td><td><code>DATA_LOSS</code></td><td>不可恢复的数据丢失或数据损坏。 客户端应该向用户报告错误。</td></tr><tr><td>500</td><td><code>UNKNOWN</code></td><td>未知的服务器错误。 通常是服务器错误。</td></tr><tr><td>500</td><td><code>INTERNAL</code></td><td>内部服务器错误。 通常是服务器错误。</td></tr><tr><td>501</td><td><code>NOT_IMPLEMENTED</code></td><td>API方法未由服务器实现。</td></tr><tr><td>503</td><td><code>UNAVAILABLE</code></td><td>服务不可用，一般是服务器宕机所致。</td></tr><tr><td>504</td><td><code>DEADLINE_EXCEEDED</code></td><td>请求超期，如果重复发生，请考虑减少请求的复杂性。</td></tr></tbody></table><h3 id="错误重试"><a href="#错误重试" class="headerlink" title="错误重试"></a>错误重试</h3><p>客户端应该重新尝试500、503和504的错误，并使用指数级的恢复。 最小延迟应为1秒，除非另有说明。对于429错误，客户端可能会重试至少30秒的延迟。 对于所有其他错误，重试可能不适用 - 首先确保您的请求是幂等的，并查看错误消息以获得指导。</p><h3 id="错误传播"><a href="#错误传播" class="headerlink" title="错误传播"></a>错误传播</h3><p>如果您的API服务依赖于其他服务，则不应盲目地将这些服务中的错误传播给您的客户。 翻译错误时，我们建议如下：</p><ul><li>隐藏实施细节和机密信息。</li><li>调整对错误负责的一方。 例如，从其他服务接收INVALID_ARGUMENT错误的服务器应将INTERNAL传播到自己的调用者。</li></ul><h2 id="如何生成错误提示"><a href="#如何生成错误提示" class="headerlink" title="如何生成错误提示"></a>如何生成错误提示</h2><p>如果您是服务器开发人员，您应该产生足够的信息来帮助客户开发人员了解并解决问题。 同时，您必须了解用户数据的安全性和隐私性，并避免在错误消息和错误详细信息中披露敏感信息，因为错误经常被记录并可能被其他人访问。 例如，诸如“客户端IP地址不在白名单128.0.0.0/8”之类的错误消息暴露了有关服务器端策略的信息，用户可能无法访问这些信息。</p><p>为了产生正确的错误，您首先需要熟悉google.rpc.Code，为每个错误条件选择最合适的错误代码。 服务器应用程序可以并行检查多个错误条件，并返回第一个。</p><p>下表列出了每个错误代码和一个良好的错误消息的示例。</p><table><thead><tr><th>HTTP</th><th>RPC</th><th>Example Error Message</th></tr></thead><tbody><tr><td>400</td><td><code>INVALID_ARGUMENT</code></td><td>Request field x.y.z is xxx, expected one of [yyy, zzz].</td></tr><tr><td>400</td><td><code>FAILED_PRECONDITION</code></td><td>Resource xxx is a non-empty directory, so it cannot be deleted.</td></tr><tr><td>400</td><td><code>OUT_OF_RANGE</code></td><td>Parameter ‘age’ is out of range [0, 125].</td></tr><tr><td>401</td><td><code>UNAUTHENTICATED</code></td><td>Invalid authentication credentials.</td></tr><tr><td>403</td><td><code>PERMISSION_DENIED</code></td><td>Permission ‘xxx’ denied on file ‘yyy’.</td></tr><tr><td>404</td><td><code>NOT_FOUND</code></td><td>Resource ‘xxx’ not found.</td></tr><tr><td>409</td><td><code>ABORTED</code></td><td>Couldn’t acquire lock on resource ‘xxx’.</td></tr><tr><td>409</td><td><code>ALREADY_EXISTS</code></td><td>Resource ‘xxx’ already exists.</td></tr><tr><td>429</td><td><code>RESOURCE_EXHAUSTED</code></td><td>Quota limit ‘xxx’ exceeded.</td></tr><tr><td>499</td><td><code>CANCELLED</code></td><td>Request cancelled by the client.</td></tr><tr><td>500</td><td><code>DATA_LOSS</code></td><td>See note.</td></tr><tr><td>500</td><td><code>UNKNOWN</code></td><td>See note.</td></tr><tr><td>500</td><td><code>INTERNAL</code></td><td>See note.</td></tr><tr><td>501</td><td><code>NOT_IMPLEMENTED</code></td><td>Method ‘xxx’ not implemented.</td></tr><tr><td>503</td><td><code>UNAVAILABLE</code></td><td>See note.</td></tr><tr><td>504</td><td><code>DEADLINE_EXCEEDED</code></td><td>See note.</td></tr></tbody></table><p><strong>NOTE</strong>:由于客户端无法修复服务器错误，因此无法生成其他错误详细信息。 为了避免在错误条件下泄漏敏感信息，建议不要生成任何错误消息，只生成<code>google.rpc.DebugInfo</code>错误详细信息。 <code>DebugInfo</code>是专门为服务器端日志记录而设计的，不能发送给客户端。</p><p><code>google.rpc</code>软件包定义了一组标准错误有效载荷，它们优先于自定义错误有效载荷。 下表列出了每个错误代码及其匹配的标准错误有效载荷（如果适用）。</p><table><thead><tr><th>HTTP</th><th>RPC</th><th>Recommended Error Detail</th></tr></thead><tbody><tr><td>400</td><td><code>INVALID_ARGUMENT</code></td><td><code>google.rpc.BadRequest</code></td></tr><tr><td>400</td><td><code>FAILED_PRECONDITION</code></td><td><code>google.rpc.PreconditionFailure</code></td></tr><tr><td>400</td><td><code>OUT_OF_RANGE</code></td><td><code>google.rpc.BadRequest</code></td></tr><tr><td>401</td><td><code>UNAUTHENTICATED</code></td><td></td></tr><tr><td>403</td><td><code>PERMISSION_DENIED</code></td><td></td></tr><tr><td>404</td><td><code>NOT_FOUND</code></td><td><code>google.rpc.ResourceInfo</code></td></tr><tr><td>409</td><td><code>ABORTED</code></td><td></td></tr><tr><td>409</td><td><code>ALREADY_EXISTS</code></td><td><code>google.rpc.ResourceInfo</code></td></tr><tr><td>429</td><td><code>RESOURCE_EXHAUSTED</code></td><td><code>google.rpc.QuotaFailure</code></td></tr><tr><td>499</td><td><code>CANCELLED</code></td><td></td></tr><tr><td>500</td><td><code>DATA_LOSS</code></td><td></td></tr><tr><td>500</td><td><code>UNKNOWN</code></td><td></td></tr><tr><td>500</td><td><code>INTERNAL</code></td><td></td></tr><tr><td>501</td><td><code>NOT_IMPLEMENTED</code></td><td></td></tr><tr><td>503</td><td><code>UNAVAILABLE</code></td><td></td></tr><tr><td>504</td><td><code>DEADLINE_EXCEEDED</code></td></tr></tbody></table><h1 id="命名约定"><a href="#命名约定" class="headerlink" title="命名约定"></a>命名约定</h1><p>为了在许多API和长时间内提供一致的开发人员体验，API使用的所有名称应为：</p><ul><li>简单</li><li>直觉</li><li>一致</li></ul><p>这包括接口，资源，集合，方法和消息的名称。</p><p>由于许多开发人员不是英文母语人士，因此这些命名约定的目标之一是确保大多数开发人员能够轻松了解API。 它通过鼓励在命名方法和资源时使用简单，一致和小的词汇表来实现。</p><ul><li>API中使用的名称应该是正确的美国英语。例如，license（而不是licence），color（而不是colour）。</li><li>可以简单地使用常用的简短形式或长字的缩写。例如，API优于应用程序编程接口。</li><li>尽可能使用直观，熟悉的术语。例如，当描述删除（和销毁）资源时，删除是优先于擦除。</li><li>对同一概念使用相同的名称或术语，包括跨API共享的概念。</li><li>避免名称重载。为不同的概念使用不同的名称。</li><li>避免在API和Google API的更大生态系统的上下文中含有不明确的通用名称。他们可能会导致对API概念的误解。相反，请选择准确描述API概念的特定名称。这对于定义一阶API元素（例如资源）的名称尤其重要。没有明确的名称列表来避免，因为每个名字都必须在其他名称的上下文中进行评估。实例，信息和服务是过去有问题的名称的示例。所选择的名称应该清楚地描述API概念（例如：什么的实例），并将其与其他相关概念区分开（例如：“alert”是指规则，信号还是通知？）。</li><li>仔细考虑使用可能与常用编程语言中的关键字冲突的名称。可以使用这些名称，但在API审查期间可能会触发额外的审查。谨慎和谨慎地使用它们。</li></ul><h2 id="产品名称"><a href="#产品名称" class="headerlink" title="产品名称"></a>产品名称</h2><p>产品名称指的是API的产品营销名称，如<em>Google Calendar API</em>。 API，UI，文档，服务条款，结算单，商业合同等一贯使用产品名称。</p><p>Google API必须使用从Google开始的产品名称，除非它们以不同的品牌提供，例如Gmail，Nest，YouTube。 一般来说，产品名称应由产品和营销团队决定。</p><p>下表显示了所有相关API名称及其一致性的示例。 有关各自名称及其约定的更多详细信息，请参阅本页面。</p><table><thead><tr><th>API Name</th><th>Example</th></tr></thead><tbody><tr><td><strong>Product Name</strong></td><td>Google <strong>Calendar</strong> API</td></tr><tr><td><strong>Service Name</strong></td><td><code>calendar.googleapis.com</code></td></tr><tr><td><strong>Package Name</strong></td><td><code>google.calendar.v3</code></td></tr><tr><td><strong>Interface Name</strong></td><td><code>google.calendar.v3.CalendarService</code></td></tr><tr><td><strong>Source Directory</strong></td><td><code>//google/calendar/v3</code></td></tr><tr><td><strong>API Name</strong></td><td><code>calendar</code></td></tr></tbody></table><h2 id="服务名称"><a href="#服务名称" class="headerlink" title="服务名称"></a>服务名称</h2><p>服务名称应该是可以解析为一个或多个网络地址的语法有效的DNS名称（根据RFC 1035）。 公开Google API的服务名称遵循以下格式：<code>xxx.googleapis.com</code>。 例如，Google日历的服务名称是<code>calendar.googleapis.com</code>。</p><p>如果一个API由几个服务组成，那么它们应该以一种帮助可发现性的方式命名。 一种方法是使服务名称共享公共前缀。 例如，服务<code>build.googleapis.com</code>和<code>buildresults.googleapis.com</code>都是Google Build API的一部分。</p><h2 id="包名称"><a href="#包名称" class="headerlink" title="包名称"></a>包名称</h2><p>在API <code>.proto</code>文件中声明的软件包名称应与产品和服务名称一致。 具有版本的API的软件包名称必须以版本结尾。 例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// Google Calendar API</span><br><span class="line">package google.calendar.v3;</span><br></pre></td></tr></table></figure><p>与Google Watcher API等服务无直接关联的抽象API应使用与产品名称一致的原包名称：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// Google Watcher API</span><br><span class="line">package google.watcher.v1;</span><br></pre></td></tr></table></figure><p>API <code>.proto</code>文件中指定的Java程序包名称必须与标准Java程序包名称前缀（<code>com.</code>，<code>edu.</code>，<code>net.</code>等）的原始程序包名称相匹配。 例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">package google.calendar.v3;</span><br><span class="line"></span><br><span class="line">// Specifies Java package name, using the standard prefix &quot;com.&quot;</span><br><span class="line">option java_package = &quot;com.google.calendar.v3&quot;;</span><br></pre></td></tr></table></figure><h2 id="集合IDs"><a href="#集合IDs" class="headerlink" title="集合IDs"></a>集合IDs</h2><p>集合ID应使用复数形式和<code>lowerCamelCase</code>，以及美式英文拼写和语义。 例如：<code>events</code>，<code>children</code>或<code>deletedEvents</code>。</p><h2 id="接口命名"><a href="#接口命名" class="headerlink" title="接口命名"></a>接口命名</h2><p>为了避免与服务名称（如<code>pubsub.googleapis.com</code>）混淆，术语接口名称是指在<code>.proto</code>文件中定义<code>service</code>时使用的名称：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Library is the interface name.</span><br><span class="line">service Library &#123;</span><br><span class="line">  rpc ListBooks(...) returns (...);</span><br><span class="line">  rpc ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>您可以将服务名称视为对一组API的实际实现的参考，而接口则引用API的抽象定义。</p><p>接口名称应该使用直观的名词，如Calendar或Blob。 该名称不应与编程语言及其运行时库（例如File）中任何已建立的概念冲突。</p><p>在少见的情况下，接口名会与API中的另一个名称冲突，应使用后缀（例如<code>Api</code>或<code>Service</code>）来消除歧义。</p><h2 id="方法命名"><a href="#方法命名" class="headerlink" title="方法命名"></a>方法命名</h2><p>在IDL规范中，服务可以定义一个或多个与集合和资源上的方法相对应的RPC方法。方法名应该遵循上驼峰上的VerbNoun的命名惯例，在这个例子中，名词通常是资源类型。</p><table><thead><tr><th></th><th>名词</th><th>方法名称</th><th>请求消息</th><th>响应消息</th></tr></thead><tbody><tr><td><code>List</code></td><td><code>Book</code></td><td><code>ListBooks</code></td><td><code>ListBooksRequest</code></td><td><code>ListBooksResponse</code></td></tr><tr><td><code>Get</code></td><td><code>Book</code></td><td><code>GetBook</code></td><td><code>GetBookRequest</code></td><td><code>Book</code></td></tr><tr><td><code>Create</code></td><td><code>Book</code></td><td><code>CreateBook</code></td><td><code>CreateBookRequest</code></td><td><code>Book</code></td></tr><tr><td><code>Update</code></td><td><code>Book</code></td><td><code>UpdateBook</code></td><td><code>UpdateBookRequest</code></td><td><code>Book</code></td></tr><tr><td><code>Rename</code></td><td><code>Book</code></td><td><code>RenameBook</code></td><td><code>RenameBookRequest</code></td><td><code>RenameBookResponse</code></td></tr><tr><td><code>Delete</code></td><td><code>Book</code></td><td><code>DeleteBook</code></td><td><code>DeleteBookRequest</code></td><td><code>google.protobuf.Empty</code></td></tr></tbody></table><p>方法名的动词部分应使用命令式语气，即用于要求或命令，而不是用于提问的指示性语气。</p><p>当动词提出关于API中的子资源的问题时，这很容易混淆，这通常以指示性语气表达。 例如，订购API来创建一本书，这显然是<code>CreateBook</code>（强制性语气），但是要求API关于图书发行者的状态可能会使用指示性的语气，例如<code>IsBookPublisherApproved</code>或<code>NeedsPublisherApproval</code>。 要在这样的情况下保持紧张的语气，依靠诸如“check”（<code>CheckBookPublisherApproved</code>）和“validate”（<code>ValidateBookPublisher</code>）等命令。</p><h2 id="消息命名"><a href="#消息命名" class="headerlink" title="消息命名"></a>消息命名</h2><p>RPC方法的请求和响应消息应分别以后缀为Request和Response的方法名命名，除非方法请求或响应类型为：</p><ul><li>一个空信息（使用<code>google.protobuf.Empty</code>），</li><li>资源类型，或</li><li>表示操作的资源</li></ul><p>这通常适用于在标准方法<code>Get</code>, <code>Create</code>, <code>Update</code>, 或 <code>Delete</code>中使用的请求或响应。</p><h2 id="枚举命名"><a href="#枚举命名" class="headerlink" title="枚举命名"></a>枚举命名</h2><p>枚举类型必须使用UpperCamelCase名称。</p><p>枚举值必须使用CAPITALIZED_NAMES_WITH_UNDERSCORES。 每个枚举值必须以分号结尾，而不能以逗号结尾。 第一个值应该命名为ENUM_TYPE_UNSPECIFIED，因为当枚举值未被明确指定时返回。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enum FooBar &#123;</span><br><span class="line">  // The first value represents the default and must be == 0.</span><br><span class="line">  FOO_BAR_UNSPECIFIED = 0;</span><br><span class="line">  FIRST_VALUE = 1;</span><br><span class="line">  SECOND_VALUE = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字段命名"><a href="#字段命名" class="headerlink" title="字段命名"></a>字段命名</h2><p><code>.proto</code>文件中的字段定义必须使用<code>lower_case_underscore_separated_names</code>。 这些名称将映射到每种编程语言的生成代码中的本机命名约定。</p><p>字段名称应避免介词（例如“for”，“during”，“at”），例如：</p><ul><li><code>reason_for_error</code>应该是<code>error_reason</code></li><li><code>cpu_usage_at_time_of_failure</code>应该是<code>fail_time_cpu_usage</code></li></ul><p>字段名称也应避免使用后置正式形容词（名词之后的修饰符），例如：</p><ul><li><code>items_collected</code>应该是<code>collect_items</code></li><li><code>objects_imported</code>应该是<code>import_objects</code></li></ul><h3 id="复数字段的命名"><a href="#复数字段的命名" class="headerlink" title="复数字段的命名"></a>复数字段的命名</h3><p>API中的复数字段必须使用适当的复数形式。 这符合现有Google API的惯例，也是外部开发人员的常用惯例。</p><h3 id="时间和时间段"><a href="#时间和时间段" class="headerlink" title="时间和时间段"></a>时间和时间段</h3><p>为了表示一个时间点独立于任何时区或日历，应该使用<code>google.protobuf.Timestamp</code>，并且字段名称应以<code>time</code></p><p>结尾，如<code>start_time</code>和<code>end_time</code>。</p><p>如果时间是指一个活动，则字段名称应该具有verb_time的形式，如<code>create_time</code>，<code>update_time</code>。 避免使用过去时的动词，如<code>created_time</code>或<code>last_updated_time</code>。</p><p>代表两个时间点之间的时间间隔，与时间无关，如“日”或“月”，应该使用<code>google.protobuf.Duration</code>等概念。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">message FlightRecord &#123;</span><br><span class="line">  google.protobuf.Timestamp takeoff_time = 1;</span><br><span class="line">  google.protobuf.Duration flight_duration = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果由于遗留或兼容性原因（包括挂钟时间，持续时间，推迟和延迟），必须使用整数类型表示与时间相关的字段，则字段名称必须具有以下格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xxx_&#123;time|duration|delay|latency&#125;_&#123;seconds|millis|micros|nanos&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">message Email &#123;</span><br><span class="line">  int64 send_time_millis = 1;</span><br><span class="line">  int64 receive_time_millis = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果您必须使用字符串类型代表传统或兼容性原因的时间戳，则字段名称不应包含任何单位后缀。 字符串表示应使用RFC 3339格式，例如“2014-07-30T10:43:17Z”。</p><h3 id="时间和日期"><a href="#时间和日期" class="headerlink" title="时间和日期"></a>时间和日期</h3><p>对于独立于时区和时间的日期，应使用<code>google.type.Date</code>，并且应该使用后缀<code>_date</code>。 如果日期必须用字符串表示，那么它应该是ISO 8601日期格式YYYY-MM-DD，例如。2014年7月30日。</p><p>对于独立于时区和日期的时间段，应使用<code>google.type.TimeOfDay</code>，并应使用后缀<code>_time</code>。 如果一天中的时间必须以字符串形式表示，那么它应该是ISO 8601 24小时制格式HH:MM:SS [.FFF]，例如。14:55:01.672。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">message StoreOpening &#123;</span><br><span class="line">  google.type.Date opening_date = 1;</span><br><span class="line">  google.type.TimeOfDay opening_time = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数量表示"><a href="#数量表示" class="headerlink" title="数量表示"></a>数量表示</h3><p>以整数类型表示的数量必须包括测量单位。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xxx_&#123;bytes|width_pixels|meters&#125;</span><br></pre></td></tr></table></figure><p>如果数量是许多项，则该字段应该具有后缀<code>_count</code>，例如<code>node_count</code>。</p><h3 id="列表过滤字段"><a href="#列表过滤字段" class="headerlink" title="列表过滤字段"></a>列表过滤字段</h3><p>如果API支持对<code>List</code>方法返回的资源进行过滤，则包含过滤器表达式的字段应该命名为<code>filter</code>。 例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">message ListBooksRequest &#123;</span><br><span class="line">  // The parent resource name.</span><br><span class="line">  string parent = 1;</span><br><span class="line"></span><br><span class="line">  // The filter expression.</span><br><span class="line">  string filter = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="List的响应"><a href="#List的响应" class="headerlink" title="List的响应"></a>List的响应</h3><p>列表方法的响应消息中包含资源 <code>List</code> 的字段名称必须是资源名称本身的复数形式。 例如，一个方法<code>CalendarApi.ListEvents()</code>必须定义一个响应消息<code>ListEventsResponse</code>，其中一个称为<code>events</code>的重复字段用于返回的资源列表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">service CalendarApi &#123;</span><br><span class="line">  rpc ListEvents(ListEventsRequest) returns (ListEventsResponse) &#123;</span><br><span class="line">    option (google.api.http) = &#123;</span><br><span class="line">      get: &quot;/v3/&#123;parent=calendars/*&#125;/events&quot;;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message ListEventsRequest &#123;</span><br><span class="line">  string parent = 1;</span><br><span class="line">  int32 page_size = 2;</span><br><span class="line">  string page_token = 3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message ListEventsResponse &#123;</span><br><span class="line">  repeated Event events = 1;</span><br><span class="line">  string next_page_token = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="驼峰写法"><a href="#驼峰写法" class="headerlink" title="驼峰写法"></a>驼峰写法</h2><p>除了字段名称和枚举值之外，<code>.proto</code>文件中的所有定义都必须使用由<code>Google Java Style</code>定义的大写的驼峰写法名称。</p><h2 id="名称缩写"><a href="#名称缩写" class="headerlink" title="名称缩写"></a>名称缩写</h2><p>对于软件开发人员（如配置和规范）中众所周知的缩写，缩写应用于API定义，而不是完整的拼写。 这将使源代码易于阅读和写入。 在正式文件中，应使用完整的拼写。 例子：</p><ul><li>配置（配置）</li><li>id（标识符）</li><li>规格（规格）</li><li>统计（统计）</li></ul><h1 id="通用设计模式"><a href="#通用设计模式" class="headerlink" title="通用设计模式"></a>通用设计模式</h1><h2 id="空响应"><a href="#空响应" class="headerlink" title="空响应"></a>空响应</h2><p>标准的<code>Delete</code>方法必须返回<code>google.protobuf.Empty</code>才能实现全局一致性。 它还可以防止客户端依赖于重试期间不可用的其他元数据。 对于自定义方法，它们必须具有自己的<code>XxxResponse</code>消息，即使它们是空的，因为它们的功能很可能随着时间的推移而增长，并且需要返回附加数据。</p><h2 id="表示范围"><a href="#表示范围" class="headerlink" title="表示范围"></a>表示范围</h2><p>表示范围的字段应使用具有命名约定[start_xxx，end_xxx]的半开间隔，例如<code>[start_key，end_key]</code>或<code>[start_time，end_time]</code>。 半开间隔语义通常由C ++ STL库和Java标准库使用。 API应避免使用其他方式表示范围，例如<code>(index, count)</code>或 <code>[first, last]</code>。</p><h2 id="资源标签"><a href="#资源标签" class="headerlink" title="资源标签"></a>资源标签</h2><p>在面向资源的API中，资源模式由API定义。 为了让客户端将少量的简单元数据附加到资源（例如，将虚拟机资源标记为数据库服务器），API应使用<code>google.api.LabelDescriptor</code>中描述的资源标签设计模式。</p><p>为此，API设计应该在资源定义中添加一个字段<code>map&lt;string，string&gt;</code>标签。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">message Book &#123;</span><br><span class="line">  string name = 1;</span><br><span class="line">  map&lt;string, string&gt; labels = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="长运行操作"><a href="#长运行操作" class="headerlink" title="长运行操作"></a>长运行操作</h2><p>如果API方法通常需要很长时间才能完成，则可以设计为将长运行操作资源返回给客户端，客户端可以使用该资源来跟踪进度并接收结果。该操作定义了一个标准接口来处理长时间运行的操作。单个API不能为长时间运行的操作定义自己的接口，以避免不一致。</p><p>操作资源必须作为响应消息直接返回，并且操作的任何直接后果应反映在API中。例如，创建资源时，该资源应该出现在LIST和GET方法中，尽管资源应该指示它尚未准备好使用。当操作完成时，如果方法不长时间运行，<code>Operation.response</code>字段应包含直接返回的消息。</p><p>操作可以使用<code>Operation.metadata</code>字段提供有关其进度的信息。即使初始实现不填充<code>metadata</code>字段，API也应该定义该元数据的消息。</p><h2 id="列表分页"><a href="#列表分页" class="headerlink" title="列表分页"></a>列表分页</h2><p>列表形式的集合应该支持分页，即使结果通常很小。</p><p><strong>理由</strong>：尽管添加了对现有API的分页支持纯粹是从API表面的角度来添加的，但这是一种使用方式上的改变，不知道已经转变为分页形式的已有客户端将错误地假设它们收到了完整的列表结果，而它们只接收第一个页面。</p><p>为了在<code>List</code>方法中支持分页（返回列表结果页），API应该遵循以下原则：</p><ul><li>在<code>List</code>方法的请求消息中定义一个<code>page_token</code>字段。客户端使用此字段请求列表结果的指定页面。</li><li>在<code>List</code>方法的请求消息中定义一个<code>int32</code>字段<code>page_size</code>。客户端使用此字段指定要由服务器返回的最大结果数。服务器可以进一步约束在单个页面中返回的最大结果数量。如果<code>page_size</code>为<code>0</code>，则服务器将决定要返回的结果数。</li><li>在<code>List</code>方法的响应消息中定义一个字符串字段<code>next_page_token</code>。此字段表示检索下一页结果的分页令牌。如果值为<code>&quot;&quot;</code>，则表示该请求没有进一步的结果。</li></ul><p>要检索下一页结果，客户端应在随后的<code>List</code>方法调用（请求消息的<code>page_token</code>字段）中传递响应的<code>next_page_token</code>的值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">rpc ListBooks(ListBooksRequest) returns (ListBooksResponse);</span><br><span class="line"></span><br><span class="line">message ListBooksRequest &#123;</span><br><span class="line">  string name = 1;</span><br><span class="line">  int32 page_size = 2;</span><br><span class="line">  string page_token = 3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message ListBooksResponse &#123;</span><br><span class="line">  repeated Book books = 1;</span><br><span class="line">  string next_page_token = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当客户端传递除了页面token之外查询参数时，如果查询参数与页面token不一致，则服务必须对请求失败。</p><p>页面token内容应该是一个网络安全的<code>base64编码协议</code>buffer。 这允许内容发展而没有兼容性问题。 如果页面token包含潜在的敏感信息，则该信息应该被加密。 服务必须防止篡改页面token通过以下方法之一暴露无意的数据：</p><ul><li>需要根据后续请求分配查询参数。</li><li>仅在页面token中引用服务器端会话状态。</li><li>对页面token中的查询参数进行加密和签名，并在每次调用时重新验证和重新授权这些参数。</li></ul><p>分页的实现还可以提供名为<code>total_size</code>的<code>int32</code>字段中的项目总数。</p><h2 id="列表子集合"><a href="#列表子集合" class="headerlink" title="列表子集合"></a>列表子集合</h2><p>有时，一个API需要让一个客户端<code>List/Search</code>跨子集。 例如，图书馆API有一个书架集合，每个书架都有一组书籍，客户想要在所有货架上搜索一本书。 在这种情况下，建议在子集合中使用标准<code>List</code>，并为父集合指定通配符集合<code>&quot;-&quot;</code>。 对于图书馆API示例，我们可以使用以下REST API请求：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET https://library.googleapis.com/v1/shelves/-/books?filter=xxx</span><br></pre></td></tr></table></figure><p>NOTE: 选择<code>&quot;-&quot;</code>而不是<code>&quot;*&quot;</code>的原因是为了避免URL转义的需要。</p><h2 id="从子集获取唯一资源"><a href="#从子集获取唯一资源" class="headerlink" title="从子集获取唯一资源"></a>从子集获取唯一资源</h2><p>有时，子集合中的资源具有在其父集合内是唯一的标识符。 在这种情况下，允许<code>Get</code>在不知道哪个父集合包含它的情况下检索该资源可能是有用的。 在这种情况下，建议使用资源上的标准<code>Get</code>，并为资源唯一的所有父集合指定通配符集合<code>&quot;-&quot;</code>。 例如，在图书馆API中，我们可以使用以下REST API请求，如果该书在所有书架上的所有书籍中都是唯一的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET https://library.googleapis.com/v1/shelves/-/books/&#123;id&#125;</span><br></pre></td></tr></table></figure><p>对此调用的响应中的资源名称必须使用资源的规范名称，每个父集合使用实际的父集合标识符而不是<code>&quot;-&quot;</code>。 例如，上面的请求应该返回一个名为<code>shelves/shelf713/books/book8141</code>，而不是<code>shelves/-/books/book8141</code>的资源。</p><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>如果API方法允许客户端为列表结果指定排序顺序，请求消息应包含一个字段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string order_by = ...;</span><br></pre></td></tr></table></figure><p>字符串值应遵循SQL语法：逗号分隔的字段列表。 例如：<code>&quot;foo,bar&quot;</code>。 默认排序顺序为升序。 要指定字段的降序，后缀<code>&quot;desc&quot;</code>应附加到字段名称。 例如：<code>&quot;foo desc,bar&quot;</code>。</p><p>冗余的空格字符在语法上是微不足道的。 <code>&quot;foo,bar desc&quot;</code>和<code>&quot;foo,bar desc&quot;</code>相当。</p><h2 id="请求验证"><a href="#请求验证" class="headerlink" title="请求验证"></a>请求验证</h2><p>如果API方法有副作用，并且需要验证请求而不引起这种副作用，请求消息应包含一个字段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool validate_only = ...;</span><br></pre></td></tr></table></figure><p>如果这个字段被设置为true，服务器就不能执行任何副作用，并且只执行与完整请求一致的特定于实现的验证。</p><p>如果验证成功，则必须返回<code>google.rpc.Code.OK</code>，并且使用相同请求消息的任何完整请求不应返回<code>google.rpc.Code.INVALID_ARGUMENT</code>。 请注意，由于其他错误（如<code>google.rpc.Code.ALREADY_EXISTS</code>）或由于竞争条件，请求可能仍然失败。</p><h2 id="请求幂等"><a href="#请求幂等" class="headerlink" title="请求幂等"></a>请求幂等</h2><p>对于网络API，特权API方法是非常优先的，因为它们可以在网络故障后安全地重试。 然而，一些API方法不能轻易地是幂等的，例如创建资源，并且需要避免不必要的重复。 对于这种用例，请求消息应包含一个唯一的ID，如UUID，服务器将使用它来检测重复，并确保只处理该请求一次。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// A unique request ID for server to detect duplicated requests.</span><br><span class="line">// This field **should** be named as `request_id`.</span><br><span class="line">string request_id = ...;</span><br></pre></td></tr></table></figure><p>如果检测到重复请求，则服务器应返回以前成功请求的响应，因为客户端很可能没有收到先前的响应。</p><h2 id="枚举默认值"><a href="#枚举默认值" class="headerlink" title="枚举默认值"></a>枚举默认值</h2><p>每个枚举定义必须以<code>0</code>值条目开始，当没有明确指定枚举值时，它将被使用。 API必须记录如何处理<code>0</code>值。</p><p>如果有一个常见的默认行为，那么应该使用枚举值<code>0</code>，并且API应该记录预期的行为。</p><p>如果没有常见的默认行为，则枚举值<code>0</code>应该命名为<code>ENUM_TYPE_UNSPECIFIED</code>，并且在使用时应该被拒绝，错误为<code>INVALID_ARGUMENT</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">enum Isolation &#123;</span><br><span class="line">  // Not specified.</span><br><span class="line">  ISOLATION_UNSPECIFIED = 0;</span><br><span class="line">  // Reads from a snapshot. Collisions occur if all reads and writes cannot be</span><br><span class="line">  // logically serialized with concurrent transactions.</span><br><span class="line">  SERIALIZABLE = 1;</span><br><span class="line">  // Reads from a snapshot. Collisions occur if concurrent transactions write</span><br><span class="line">  // to the same rows.</span><br><span class="line">  SNAPSHOT = 2;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// When unspecified, the server will use an isolation level of SNAPSHOT or</span><br><span class="line">// better.</span><br><span class="line">Isolation level = 1;</span><br></pre></td></tr></table></figure><p>An idiomatic name <strong>may</strong> be used for the <code>0</code> value. For example, <code>google.rpc.Code.OK</code> is the idiomatic way of specifying the absence of an error code. In this case, <code>OK</code> is semantically equivalent to <code>UNSPECIFIED</code> in the context of the enum type.</p><p>In cases where an intrinsically sensible and safe default exists, that value <strong>may</strong> be used for the ‘0’ value. For example, <code>BASIC</code> is the ‘0’ value in the <a href="https://cloud.google.com/apis/design/design_patterns#resource_view" target="_blank" rel="noopener">Resource View</a> enum.</p><p>一个惯用名称可以用于<code>0</code>值。 例如，<code>google.rpc.Code.OK</code>是指定缺少错误代码的惯用方式。 在这种情况下，<code>OK</code>在语义上类似于<code>UNSPECIFIED</code>。</p><p>在存在内在敏感和安全默认值的情况下，该值可用于<code>&#39;0&#39;</code>值。 例如，<code>BASIC</code>是<code>Resource View</code>枚举中的<code>&#39;0&#39;</code>值。</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>在某些API设计中，有必要为某些数据格式定义简单的语法，例如可接受的文本输入。 为了在API之间提供一致的开发人员体验并减少学习曲线，API设计人员必须使用ISO 14977 Extended Backus-Naur Form（EBNF）语法来定义此类语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Production  = name &quot;=&quot; [ Expression ] &quot;;&quot; ;</span><br><span class="line">Expression  = Alternative &#123; &quot;|&quot; Alternative &#125; ;</span><br><span class="line">Alternative = Term &#123; Term &#125; ;</span><br><span class="line">Term        = name | TOKEN | Group | Option | Repetition ;</span><br><span class="line">Group       = &quot;(&quot; Expression &quot;)&quot; ;</span><br><span class="line">Option      = &quot;[&quot; Expression &quot;]&quot; ;</span><br><span class="line">Repetition  = &quot;&#123;&quot; Expression &quot;&#125;&quot; ;</span><br></pre></td></tr></table></figure><p>NOTE: <code>TOKEN</code> 表示在语法之外定义的终端。</p><h2 id="整形类型"><a href="#整形类型" class="headerlink" title="整形类型"></a>整形类型</h2><p>在API设计中，不应使用无符号整数类型，例如<code>uint32</code>和<code>fixed32</code>，因为一些重要的编程语言和系统不能很好地支持它们，例如Java，JavaScript和OpenAPI。 而且它们更有可能导致溢出错误。 另一个问题是，不同的API很可能对同一件事情使用不匹配的有符号和无符号类型。</p><p>当带符号的整数类型用于负值不重要的事物（如大小或超时）时，值<code>-1</code>（且仅为<code>-1</code>）可用于指示特殊含义，例如文件结尾（EOF），无限大 超时，无限制配额限制或未知年龄。 必须清楚记录这些用法以避免混淆。 如果API生成器不是非常明显的话，API生成器还应记录隐式默认值<code>0</code>的行为。</p><h2 id="子集响应"><a href="#子集响应" class="headerlink" title="子集响应"></a>子集响应</h2><p>有时API客户端只需要响应消息中的特定数据子集。 为了支持这种用例，一些API平台为部分响应提供本地支持。 Google API Platform通过响应字段掩码支持它。 对于任何REST API调用，都有一个隐式的系统查询参数<code>$ fields</code>，它是一个<code>google.protobuf.FieldMask</code>值的JSON表示形式。 响应消息将被发送回客户端之前被<code>$fields</code>过滤。 API平台为所有API方法自动处理此逻辑。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET https://library.googleapis.com/v1/shelves?$fields=name</span><br></pre></td></tr></table></figure><h2 id="资源视图"><a href="#资源视图" class="headerlink" title="资源视图"></a>资源视图</h2><p>为了减少网络流量，允许客户端限制服务器在其响应中返回的资源的哪些部分是有用的，返回资源的视图，而不是完整的资源表示。 通过向方法请求中添加参数来实现API中的资源视图支持，该参数允许客户端在响应中指定要接收的资源的哪个视图。</p><p>参数：</p><ul><li>应该是枚举类型</li><li>必须命名视图</li></ul><p>枚举的每个值定义资源的哪些部分（哪些字段）将在服务器的响应中返回。 正是为每个视图值返回的值是实现定义的，应在API文档中指定。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package google.example.library.v1;</span><br><span class="line"></span><br><span class="line">service Library &#123;</span><br><span class="line">  rpc ListBooks(ListBooksRequest) returns (ListBooksResponse) &#123;</span><br><span class="line">    option (google.api.http) = &#123;</span><br><span class="line">      get: &quot;/v1/&#123;name=shelves/*&#125;/books&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">enum BookView &#123;</span><br><span class="line">  // 服务器响应只包括作者，标题，ISBN和独特的书籍ID。</span><br><span class="line">  // The default value.</span><br><span class="line">  BASIC = 0;</span><br><span class="line"></span><br><span class="line">  // 本书的完整表示在服务器响应中返回，</span><br><span class="line">  // 包括书的内容。</span><br><span class="line">  FULL = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message ListBooksRequest &#123;</span><br><span class="line">  string name = 1;</span><br><span class="line"></span><br><span class="line">  // 指定应该返回图书资源的哪些部分</span><br><span class="line">  BookView view = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This construct will be mapped to URLs such as:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET https://library.googleapis.com/v1/shelves/shelf1/books?view=BASIC</span><br></pre></td></tr></table></figure><p>You can find out more about defining methods, requests, and responses in the <a href="https://cloud.google.com/apis/design/standard_methods" target="_blank" rel="noopener">Standard Methods</a> chapter of this Design Guide.</p><h2 id="ETags"><a href="#ETags" class="headerlink" title="ETags"></a>ETags</h2><p>ETag是一个不透明的标识符，允许客户端进行条件请求。 为了支持ETag，API应在资源定义中包含一个字符串字段<code>etag</code>，其语义必须与ETag的常用用法相匹配。 通常，<code>etag</code>包含由服务器计算的资源的指纹。 有关详细信息，请参阅维基百科和RFC 7232。</p><p>ETags可以强或弱验证，其中弱验证的ETag以W /为前缀。 在这种情况下，强验证意味着具有相同ETag的两个资源具有字节/字节相同的内容和相同的额外字段（即Content-Type）。 这意味着强烈验证的ETag允许缓存部分响应，以便稍后进行组合。</p><p>相反，具有相同弱验证的ETag值的资源意味着表示在语义上是等效的，但不一定是字节的字节相同，因此不适合于字节范围请求的响应缓存。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// This is a strong ETag, including the quotes.</span><br><span class="line">&quot;1a2f3e4d5b6c7c&quot;</span><br><span class="line">// This is a weak ETag, including the prefix and quotes.</span><br><span class="line">W/&quot;1a2b3c4d5ef&quot;</span><br></pre></td></tr></table></figure><h2 id="输出字段"><a href="#输出字段" class="headerlink" title="输出字段"></a>输出字段</h2><p>API可能希望区分由客户端提供的字段作为输入和仅在服务器上在特定资源的输出上返回的字段。 对于仅输出的字段，必须记录字段属性。</p><p>请注意，如果客户端在请求中设置了仅输出字段，或者客户端指定了仅输出域的<code>google.protobuf.FieldMask</code>，则服务器必须接受请求而不会出错。 这意味着服务器必须忽略仅输出字段的存在及其任何指示。 这个建议的原因是因为客户端通常会将服务器返回的资源重用为另一个请求输入，例如 一个检索到的书将在UPDATE方法中被再次使用。 如果仅输出字段验证，那么这将在客户端添加额外的工作以清除仅输出字段。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">message Book &#123;</span><br><span class="line">  string name = 1;</span><br><span class="line">  // Output only.</span><br><span class="line">  Timestamp create_time = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h1><p>本节提供了将内联文档添加到API的准则。 大多数API还将具有概述，教程和更高级别的参考文档，这些文档超出了本“设计指南”的范围。 有关API，资源和方法命名的信息，请参阅<a href="https://cloud.google.com/apis/design/naming_convention" target="_blank" rel="noopener">命名约定</a>。</p><h2 id="评论格式"><a href="#评论格式" class="headerlink" title="评论格式"></a>评论格式</h2><p>Add comments to your <code>.proto</code> file using the usual Protocol Buffers <code>//</code> comment format.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Creates a shelf in the library, and returns the new Shelf.</span><br><span class="line">rpc CreateShelf(CreateShelfRequest) returns (Shelf) &#123;</span><br><span class="line">  option (google.api.http) = &#123; post: &quot;/v1/shelves&quot; body: &quot;shelf&quot; &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="服务配置中的注释"><a href="#服务配置中的注释" class="headerlink" title="服务配置中的注释"></a>服务配置中的注释</h2><p>作为将文档注释添加到<code>.proto</code>文件的替代方法，您可以在其YAML服务配置文件中添加内联文档到您的API。 如果两个文件中都记录了相同的元素，则该文件中的文档将优先于<code>.proto</code>中的文档。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">documentation:</span><br><span class="line">  summary: Gets and lists social activities</span><br><span class="line">  overview: A simple example service that lets you get and list possible social activities</span><br><span class="line">  rules:</span><br><span class="line">  - selector: google.social.Social.GetActivity</span><br><span class="line">    description: Gets a social activity. If the activity does not exist, returns Code.NOT_FOUND.</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>如果您有多个服务使用相同的<code>.proto</code>文件并希望提供特定于服务的文档，则可能需要使用此方法。 YAML文档规则还可以为API描述添加更详细的概述。 但是，一般来说，添加文档注释到<code>.proto</code>是首选的。</p><p>与<code>.proto</code>注释一样，您可以使用Markdown在YAML文件注释中提供其他格式。</p><h2 id="API描述"><a href="#API描述" class="headerlink" title="API描述"></a>API描述</h2><p>The API description is a phrase starting with an active verb that describes what you can do with the API. In your <code>.proto</code>file, an API description is added as a comment to the corresponding <code>service</code>, as in the following example:</p><p>API描述是一个从活动动词开始的短语，用于描述您可以使用API做什么。 在<code>.proto</code>文件中，API描述作为注释添加到相应的服务中，如下例所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Manages books and shelves in a simple digital library.</span><br><span class="line">service LibraryService &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是一些更为示例的API说明：</p><ul><li>与世界各地的朋友分享更新，照片，视频等。</li><li>访问云托管的机器学习服务，可以轻松构建响应数据流的智能应用程序。</li></ul><h2 id="资源描述"><a href="#资源描述" class="headerlink" title="资源描述"></a>资源描述</h2><p>资源描述是描述资源代表什么的部分句子。 如果您需要添加更多的细节，请使用其他句子。 在<code>.proto</code>文件中，将资源描述作为注释添加到相应的消息类型中，如以下示例所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// A book resource in the Library API.</span><br><span class="line">message Book &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是一些示例资源描述：</p><ul><li>用户的待办事项列表中的任务。 每个任务都有一个独特的优先级。</li><li>用户日历上的事件。</li></ul><h2 id="现场和参数说明"><a href="#现场和参数说明" class="headerlink" title="现场和参数说明"></a>现场和参数说明</h2><p>描述字段或参数定义的名词短语，如以下示例所示：</p><ul><li>本系列中的主题数量。</li><li>纬度和经度坐标的精确度，以米为单位。必须是非负数。</li><li>管理是否为本系列中的提交资源返回附件URL值的标志。 <code>serial.insert</code>的默认值为<code>true</code>。</li><li>投票信息的容器。仅当投票信息被记录时才存在。</li><li>目前尚未使用或已弃用。</li></ul><p>现场和参数说明</p><ul><li>必须明确描述边界（即清楚有效和什么是无效的）请记住，工程师将尽力破坏任何服务，并且无法读取底层代码来澄清任何不清楚的信息。）</li><li>必须指定任何默认值或默认行为;换句话说，如果没有提供值，服务器将会做什么。</li><li>如果它是字符串，例如名称或路径，则描述语法和列出允许的字符以及任何所需的编码。例如：</li><li>集合中的1-255个字符[A-a0-9]</li><li>从RFC 2332约定开始的有效URL路径字符串。最大长度为500个字符。</li><li>应尽可能提供示例值。</li><li>如果需要字段值，仅输入，仅输出，则必须在字段描述开头记录。默认情况下，所有字段和参数都是可选的。例如：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">message Table &#123;</span><br><span class="line">  // Required. The resource name of the table.</span><br><span class="line">  string name = 1;</span><br><span class="line">  // Input only. Whether to dry run the table creation.</span><br><span class="line">  bool dryrun = 2;</span><br><span class="line">  // Output only. The timestamp when the table was created. Assigned by</span><br><span class="line">  // the server.</span><br><span class="line">  Timestamp create_time = 3;</span><br><span class="line">  // The display name of the table.</span><br><span class="line">  string display_name = 4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法描述"><a href="#方法描述" class="headerlink" title="方法描述"></a>方法描述</h2><p>一个方法描述是一个句子，指出方法有什么影响以及它所运行的资源。 它通常以第三人称现在时态动词（即以“s结尾的动词”）开始。 如果您需要添加更多的细节，请使用其他句子。 这里有些例子：</p><ul><li>列出已验证用户的日历事件。</li><li>使用请求中包含的数据更新日历事件。</li><li>从经过身份验证的用户的位置记录中删除位置记录。</li><li>使用请求中包含的数据创建或更新已验证用户的位置记录中的位置记录。 如果位置资源已经存在相同的时间戳值，则提供的数据将覆盖现有数据。</li></ul><h2 id="API描述的大纲"><a href="#API描述的大纲" class="headerlink" title="API描述的大纲"></a>API描述的大纲</h2><p>确保每个描述简单但完整，并且没有关于API的其他信息的用户可以理解。在大多数情况下，还有更多的是要重申明显的;例如，<code>serial.insert</code>方法的描述不应该只是说“插入一个系列”。 - 虽然你的命名应该是信息丰富的，但大多数读者都在阅读你的描述，因为他们需要比名字本身提供更多的信息。如果您不清楚说明中还有什么要说的话，请尝试回答以下所有相关问题：</p><ul><li>它是什么？</li><li>如果成功，该怎么办？如果失败，该怎么办？什么会导致失败，怎么办？</li><li>这是幂等吗？</li><li>什么是单位？ （示例：米，度，像素）</li><li>它接受哪些价值观？范围包括还是排他？</li><li>有什么副作用？</li><li>你如何使用它？</li><li>常见的错误是什么？</li><li>它总是存在吗？ （例如：“投票信息的容器”，只有在记录投票信息时才存在。）</li><li>它是否有默认设置？</li></ul><h2 id="约定"><a href="#约定" class="headerlink" title="约定"></a>约定</h2><p>本节列出了文本描述和文档的一些用法约定。 例如，在谈论标识符时使用“ID”（全部大写），而不是“Id”或“id”。 在引用该数据格式时使用“JSON”而不是“Json”或“json”。 以<code>代码字体</code>显示所有字段/参数名称。 将文字字符串值放在<code>代码字体</code>和引号中。</p><ul><li>ID</li><li>JSON</li><li>RPC</li><li>REST</li><li><code>property_name</code> or <code>&quot;string_literal&quot;</code></li><li><code>true</code> / <code>false</code></li></ul><h2 id="语言风格"><a href="#语言风格" class="headerlink" title="语言风格"></a>语言风格</h2><p>在我们的命名约定中，我们建议在编写文档注释时使用简单，一致的词汇和风格。 那些不会说英语的读者应该可以理解这个意见，所以要避免行话，俚语，复杂的隐喻，流行文化的引用或其他不容易理解的内容。 使用友好，专业的风格，直接与开发人员阅读您的评论，并尽可能简明扼要。 请记住，大多数读者想要了解如何使用API做某事，不要阅读文档！</p><h1 id="Protocol-Buffers-v3"><a href="#Protocol-Buffers-v3" class="headerlink" title="Protocol Buffers v3"></a>Protocol Buffers v3</h1><p>本章将讨论如何使用协议缓冲区与API设计。为了简化开发人员的体验并提高运行时效率，gRPC API应使用协议缓冲区版本3（proto3）进行API定义。</p><p>协议缓冲区是一种用于定义数据结构模式和编程接口的简单的语言中立和平台中立的界面定义语言（IDL）。它支持二进制和文本线格式，并且可以在不同平台上使用许多不同的线路协议。</p><p>Proto3是Protocol Buffers的最新版本，并且包括<code>proto2</code>的以下更改：</p><ul><li>现场存在，也称为hasField，不适用于原始字段。未定义的原始字段具有语言定义的默认值。消息字段的存在仍然可用，可以使用编译器生成的<code>hasFieldmethod</code>或与null进行比较或由实现定义的<code>sentinel</code>值进行测试。</li><li>字段的用户定义的默认值不再可用。</li><li>枚举定义必须以枚举值零开始。</li><li>必填字段不再可用。</li><li>扩展程序已不再可用。使用<code>google.protobuf.Any</code>代替。由于后向和运行时兼容性的原因，专门针对<code>google/protobuf/descriptor.proto</code>授予异常。</li><li>删除组语法。</li></ul><p>删除这些功能的原因是使API设计更简单，更稳定，性能更高。例如，在记录消息之前，通常需要过滤某些字段，例如删除敏感信息。如果这些字段是必需的，这是不可能的。</p><p>有关详细信息，请参阅协议缓冲区。</p><h1 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h1><p>本章提供了联网API的版本控制指南。由于一个API服务可以提供多个API接口，所以API版本控制策略适用于API接口级别，而不是在API服务级别。为了方便起见，术语API指的是以下部分中的API接口。</p><p>网络API应该使用语义版本控制。给定版本号<code>MAJOR.MINOR.PATCH</code>，增加：</p><ol><li><code>MAJOR</code>版本当您进行不兼容的API更改时，</li><li>当您以向后兼容的方式添加功能时，<code>MINOR</code>版本，</li><li>当您制作向后兼容的错误修复时，<code>PATCH</code>版本。</li></ol><p>不同的规则适用于根据API版本指定主版本号：</p><ul><li>对于API的版本1（v1），其主要版本号应以原包名称编码，例如<code>google.pubsub.v1</code>。如果软件包包含稳定的类型和不希望有突发性更改的接口，例如<code>google.protobuf</code>和<code>google.longrunning</code>，则主包可能会从主包中省略。</li><li>对于除v1以外的所有版本的API，主版本号必须以原包名称编码。例如，<code>google.pubsub.v2</code>。</li></ul><p>对于前GA版本（如alpha和beta），建议在版本号后附加一个后缀。后缀应包含预发行版本名称（例如alpha，beta）和可选的预发行版本号。</p><p>版本进度示例：</p><table><thead><tr><th>Version</th><th>Proto Package</th><th>Description</th></tr></thead><tbody><tr><td>v1alpha</td><td>v1alpha1</td><td>The v1 alpha release.</td></tr><tr><td>v1beta1</td><td>v1beta1</td><td>The v1 beta 1 release.</td></tr><tr><td>v1beta2</td><td>v1beta2</td><td>The second beta release of v1.</td></tr><tr><td>v1test</td><td>v1test</td><td>An internal test release with dummy data.</td></tr><tr><td>v1</td><td>v1</td><td>The v1 major version, general availability.</td></tr><tr><td>v1.1beta1</td><td>v1p1beta1</td><td>The first beta release for minor changes to v1.</td></tr><tr><td>v1.1</td><td>v1</td><td>The minor update to v1.1 release.</td></tr><tr><td>v2beta1</td><td>v2beta1</td><td>The v2 beta 1 release.</td></tr><tr><td>v2</td><td>v2</td><td>The v2 major version, general availability.</td></tr></tbody></table><p>次要和补丁编号应反映在API配置和文档中，它们不能以原包名称编码。</p><p><strong>NOTE:</strong> Google API Platform本来不支持小版本和补丁版本。对于每个主要的API版本，只有一组文档和客户端库。 API所有者需要通过API文档和发行说明手动记录它们。</p><p>API的新主要版本不能取决于同一个API的以前的主要版本。 API可能依赖于其他API，以了解与这些API相关联的依赖性和稳定性风险。稳定的API版本必须仅依赖于其他API的最新稳定版本。</p><p>在一段时间内，同一API的不同版本必须能够在单个客户端应用程序中同时工作。这是为了帮助客户顺利地从旧版本过渡到较新版本的API。</p><p>较旧的API版本应在其弃用期结束后才能删除。</p><p>许多API共享的常见且稳定的数据类型（如日期和时间）应在单独的原包中定义。如果有必要进行突破性更改，则必须引入新的类型名称或包含新主版本的软件包名称。</p><h2 id="向后兼容"><a href="#向后兼容" class="headerlink" title="向后兼容"></a>向后兼容</h2><p>确定什么被视为向后兼容的变化可能是困难的。</p><p>以下列表是快速参考起始点，但如果您有任何疑问，请参阅专用的兼容性部分了解更多详细信息。</p><h3 id="向后兼容（不间断）更改"><a href="#向后兼容（不间断）更改" class="headerlink" title="向后兼容（不间断）更改"></a>向后兼容（不间断）更改</h3><ul><li>向API服务添加API接口</li><li>将方法添加到API接口</li><li>向方法添加HTTP绑定</li><li>将字段添加到请求消息</li><li>将字段添加到响应消息</li><li>将值添加到枚举</li><li>添加仅输出资源字段</li></ul><h3 id="向后不兼容（断开）更改"><a href="#向后不兼容（断开）更改" class="headerlink" title="向后不兼容（断开）更改"></a>向后不兼容（断开）更改</h3><ul><li>删除或重命名服务，接口，字段，方法或枚举值</li><li>更改HTTP绑定</li><li>更改字段的类型</li><li>更改资源名称格式</li><li>更改现有请求的可见行为</li><li>更改HTTP定义中的URL格式</li><li>向资源消息添加读/写字段Compatibility</li></ul><p>此页面提供了有关<code>Versioningsection</code>中给出的破坏和不间断更改列表的更详细说明。</p><p>这并不总是完全清楚什么是破坏（不相容）的变化。这里的指导应被视为指示性的，而不是每一个可能的变化的综合清单。</p><p>这里列出的规则只涉及客户兼容性。预期API生产者在部署方面了解自己的要求，包括实施细节的变化。</p><p>一般的目标是客户端不应该被更新到新的小版本或补丁的服务中断。正在考虑的种种破坏是：</p><ul><li>源兼容性：针对1.0编写的代码无法针对1.1进行编译</li><li>二进制兼容性：针对1.0无法针对1.1客户端库进行链接/运行的代码编译。 （精确细节取决于客户端平台;在不同情况下有不同的变体）</li><li>电线兼容性：针对1.0无法与1.1服务器进行通信的应用程序</li><li>语义兼容性：一切都运行，但产生意想不到或令人惊讶的结果</li></ul><p>换句话说：老客户应该可以在同一个主要版本号的较新的服务器上工作，当他们想要更新到一个新的小版本（例如，利用一个新功能）时，他们应该能够这么容易</p><p>除了基于协议的理论考虑之外，由于存在涉及生成的代码和手写代码的客户端库，所以存在实际的考虑。通过生成新版本的客户端库并确保其测试仍然通过，尽可能地测试您正在考虑的更改。</p><p>下面的讨论将原始消息分为三类：</p><ul><li>请求消息（如<code>GetBookRequest</code>）</li><li>响应消息（如<code>ListBooksResponse</code>）</li><li>资源消息（例如<code>Book</code>，并包括在其他资源消息中使用的任何消息）</li></ul><p>这些类别具有不同的规则，因为请求消息仅从客户端发送到服务器，响应消息仅从服务器发送到客户端，但通常资源消息都以两种方式发送。特别地，可以更新的资源需要根据读取/修改/写入周期来考虑。</p><h2 id="向后兼容（不间断）更改-1"><a href="#向后兼容（不间断）更改-1" class="headerlink" title="向后兼容（不间断）更改"></a>向后兼容（不间断）更改</h2><h3 id="向API服务定义添加API接口"><a href="#向API服务定义添加API接口" class="headerlink" title="向API服务定义添加API接口"></a>向API服务定义添加API接口</h3><p>从协议的角度来看，这是永远安全的。 唯一需要注意的是，客户端库可能已经在手写代码中使用了您的新API接口名称。 如果您的新界面与现有界面完全正交，则不太可能; 如果它是现有界面的简化版本，那么更有可能导致冲突。</p><h3 id="向API接口添加方法"><a href="#向API接口添加方法" class="headerlink" title="向API接口添加方法"></a>向API接口添加方法</h3><p>除非您添加与客户端库中已经生成的方法冲突的方法，否则这应该是正常的。</p><p>（可能会破坏的例子）：如果您有GetFoo方法，则C＃代码生成器将已经创建了GetFoo和GetFooAsync方法。因此，在API接口中添加GetFooAsync方法将是从客户端库角度出发的一个突破性变化。）</p><h3 id="向方法添加HTTP绑定"><a href="#向方法添加HTTP绑定" class="headerlink" title="向方法添加HTTP绑定"></a>向方法添加HTTP绑定</h3><p>假设绑定没有引入任何歧义，使得服务器响应以前将拒绝的URL是安全的。当将现有操作应用于新的资源名称模式时，可以这样做。</p><h3 id="向请求消息添加字段"><a href="#向请求消息添加字段" class="headerlink" title="向请求消息添加字段"></a>向请求消息添加字段</h3><p>添加请求字段可以是不间断的，只要不指定该字段的客户端将在新版本中与旧版本相同。</p><p>最为明显的例子就是分页：如果API的v1.0不包含分页，则不能添加到v1.1中，除非默认的page_size被视为无限（通常是一个坏主意）。否则，希望从单个请求获得完整结果的v1.0客户端可能会收到截断的结果，而不知道该集合包含更多资源。</p><h3 id="向响应消息添加一个字段"><a href="#向响应消息添加一个字段" class="headerlink" title="向响应消息添加一个字段"></a>向响应消息添加一个字段</h3><p>只要不改变其他响应字段的行为，就可以扩展不是资源的响应消息（例如ListBooksResponse），而不会破坏客户端。以前在响应中填充的任何字段应该继续使用相同的语义填充，即使这引入了冗余。</p><p>例如，1.0中的查询响应可能具有contains_duplicate的布尔字段，以指示由于重复而省略了一些结果。在1.1中，我们可能会在duplicate_count字段中提供更详细的信息。即使从1.1角度来看它是多余的，但是containsduplicates字段仍然必须填充。</p><h3 id="向枚举中添加一个值"><a href="#向枚举中添加一个值" class="headerlink" title="向枚举中添加一个值"></a>向枚举中添加一个值</h3><p>仅在请求消息中使用的枚举可以自由扩展，以包含新元素。例如，使用资源视图模式，可以在新的次要版本中添加新视图。客户端从来不需要收到这个枚举，所以他们不需要知道他们不在乎的价值观。</p><p>对于资源消息和响应消息，默认假设是客户端应该处理它们不知道的枚举值。然而，API生产者应该意识到，编写应用程序来正确处理新的枚举元素可能很困难。 API所有者应该在遇到未知的枚举值时记录预期的客户端行为。</p><p>Proto3允许客户端收到他们不知道的值并保留消息维持相同的值，所以这不会中断读取/修改/写入周期。 JSON格式允许在值“未知”的位置发送数字值，但服务器通常不会知道客户端是否真正了解特定值。因此，JSON客户端可能会意识到他们已经收到以前对他们未知的值，但他们只会看到名称或号码 - 他们不会同时知道这两个。在读取/修改/写入周期中将相同的值返回给服务器不应修改该字段，因为服务器应该了解这两种形式。</p><h3 id="添加仅输出资源字段"><a href="#添加仅输出资源字段" class="headerlink" title="添加仅输出资源字段"></a>添加仅输出资源字段</h3><p>可以添加仅由服务器提供的资源实体中的字段。 服务器可以验证请求中的任何客户端提供的值是否有效，但是如果该值被省略则不能失败。</p><h2 id="向后不兼容（断开）更改-1"><a href="#向后不兼容（断开）更改-1" class="headerlink" title="向后不兼容（断开）更改"></a>向后不兼容（断开）更改</h2><h3 id="删除或重命名服务，字段，方法或枚举值"><a href="#删除或重命名服务，字段，方法或枚举值" class="headerlink" title="删除或重命名服务，字段，方法或枚举值"></a>删除或重命名服务，字段，方法或枚举值</h3><p>从根本上说，如果客户端代码可以引用某些东西，那么删除或重命名它是一个突破性的变化，并且必须导致主要的版本增加。 引用旧名称的代码将导致某些语言（如C＃和Java）的编译时出现故障，并可能导致其他语言的执行时间故障或数据丢失。 线格式的兼容性在这里是无关紧要的。</p><h3 id="更改HTTP绑定"><a href="#更改HTTP绑定" class="headerlink" title="更改HTTP绑定"></a>更改HTTP绑定</h3><p>这里的“更改”实际上是“删除和添加”。例如，如果您确定您真的希望支持PATCH，但您发布的版本支持PUT，或者您使用错误的自定义动词名称，则可以添加新的绑定，但是由于所有相同的原因，您不能删除旧的绑定因为删除服务方法是一个突破性的变化。</p><h3 id="更改字段的类型"><a href="#更改字段的类型" class="headerlink" title="更改字段的类型"></a>更改字段的类型</h3><p>即使新类型与线格式兼容，这可能会改变客户端库的生成代码，因此必须导致主版本的增加。对于编译的静态类型的语言，这可以很容易地引入编译时错误。</p><h3 id="更改资源名称格式"><a href="#更改资源名称格式" class="headerlink" title="更改资源名称格式"></a>更改资源名称格式</h3><p>资源不能更改其名称 - 这意味着无法更改集合名称。</p><p>与大多数突破性更改不同，这也影响主要版本：如果客户端可以期望使用v2.0访问在v1.0中创建的资源，反之亦然，则应在两个版本中使用相同的资源名称。</p><p>更精巧的是，有效的资源名称集合也不应该改变，原因如下：</p><ul><li>如果它变得更加限制，以前成功的请求现在将失败。</li><li>如果它比以前记录的限制较少，那么根据以前的文档做出假设的客户可能会被打破。客户端很有可能在其他地方存储资源名称，方式可能对允许的字符集和名称的长度敏感。或者，客户端可能会执行自己的资源名称验证来跟踪文档。 （例如，亚马逊给客户带来了许多警告，并且在开始允许更长的EC2资源ID时有迁移期）。</li></ul><p>请注意，这样的更改只能在原型文档中可见。因此，当检查CL为破损时，审查非评论变更是不够的。</p><h3 id="改变现有请求的可见行为"><a href="#改变现有请求的可见行为" class="headerlink" title="改变现有请求的可见行为"></a>改变现有请求的可见行为</h3><p>客户端通常依赖于API行为和语义，即使没有明确支持或记录此类行为。因此，在大多数情况下，更改API数据的行为或语义将被视为消费者的打破。如果行为不是加密隐藏的，那么你应该假设用户已经发现了它，并且会依赖它。例如，用户具有反向设计的AWS EC2资源标识符。</p><p>加密分页令牌也是一个好主意（即使数据不感兴趣），以防止用户创建自己的令牌，并在令牌行为发生变化时可能被破坏。</p><h3 id="更改HTTP定义中的URL格式"><a href="#更改HTTP定义中的URL格式" class="headerlink" title="更改HTTP定义中的URL格式"></a>更改HTTP定义中的URL格式</h3><p>在这里有两种更改可以考虑，超出以上列出的资源名称变化：</p><ul><li>自定义方法名称：虽然不是资源名称的一部分，但自定义方法名称是REST客户端发布的URL的一部分。更改自定义方法名称不应该破坏gRPC客户端，但是公共API必须假定它们具有REST客户端。</li><li>资源参数名称：从v1 / shelf / {shelf} / books / {book} tov1 / shelves / {shelf_id} / books / {book_id}改变不会影响替换的资源名称，但可能会影响代码生成。</li></ul><h3 id="向资源消息添加读-写字段"><a href="#向资源消息添加读-写字段" class="headerlink" title="向资源消息添加读/写字段"></a>向资源消息添加读/写字段</h3><p>客户端经常会执行读/写/写操作。大多数客户不会为他们不知道的领域提供价值，特别是proto3不支持这一点。您可以指定消息类型（而不是基本类型）的任何缺失字段意味着更新不会应用于这些字段，但这使得更难于从实体中显式删除这样的字段值。原始类型（包括字符串和字节）根本不能以这种方式处理，因为在明确指定int32字段为0并且根本不指定之前，proto3没有区别。</p><p>如果使用字段掩码执行所有更新，这不是问题，因为客户端不会隐式覆盖其不知道的字段。然而，这将是一个不寻常的API决定：大多数API允许“全部资源”更新。</p><h1 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h1><p>API服务通常使用<code>.proto</code>文件来定义API表面和<code>.yaml</code>文件来配置API服务。</p><p>每个API服务必须在API存储库中具有包含其定义文件和构建脚本的API目录。</p><p>API目录应具有以下标准布局：</p><ul><li>API目录</li><li>存储库先决条件</li><li><code>BUILD</code> - 构建文件。</li><li><code>METADATA</code> - 构建元数据文件。</li><li><code>OWNERS</code> - API目录所有者。</li><li>配置文件</li><li><code>{service} .yaml</code> - 基准服务配置文件，它是<code>google.api.Service</code> proto消息的YAML表示形式。</li><li><code>prod.yaml</code> - prod delta服务配置文件。</li><li><code>staging.yaml</code> - 分段delta服务配置文件。</li><li><code>test.yaml</code> - 测试增量服务配置文件。</li><li><code>local.yaml</code> - 本地delta服务配置文件。</li><li>文档文件</li><li><code>README.md</code> - 主要的自述文件。应包含一般生产概况，技术说明等。</li><li><code>doc/*</code> - 技术文档文件。他们应该是Markdown格式。</li><li>接口定义</li><li><code>v[0-9]*/*</code> - 每个这样的目录都包含主要版本的API，主要是原始文件和构建脚本。</li><li><code>{subapi}/v[0-9]*/*</code>- 每个<code>{subapi}</code>目录包含子API的接口定义。每个子API可能有自己独立的主要版本。</li><li><code>type/*-</code>包含不同API，不同版本的同一API之间或API与服务实现之间共享的类型的proto文件。类型<code>/*</code>下的类型定义在发布后不应该有破坏性的更改。</li></ul><h1 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h1><p>应使用proto3 IDL在<code>.proto</code>文件中定义<code>gRPC API</code>。</p><p>文件结构必须在较低级别和较不重要的项目之前提出更高级别和更重要的定义。 在每个原始文件中，适用的部分应按以下顺序：</p><ul><li>如果需要，版权和许可证通知。</li><li>按照该顺序的Proto语法，包，选项和导入语句。</li><li>API概述文档，为文件的其余部分准备读者。</li><li>API原始服务定义，按重要性降序排列。</li><li>资源消息定义。 父资源必须在其子资源之前定义。</li><li>RPC请求和响应消息定义，按照相应的方法顺序。 每个请求消息必须在其相应的响应消息之前（如果有）。</li></ul><p>如果单个原始文件包含整个API表面，则应以API命名：</p><table><thead><tr><th>API</th><th>Proto</th></tr></thead><tbody><tr><td><code>Library</code></td><td><code>library.proto</code></td></tr><tr><td><code>Calendar</code></td><td><code>calendar.proto</code></td></tr></tbody></table><p>Large.proto文件可能会分成多个文件。 服务，资源消息和请求/响应消息应根据需要移动到单独的文件中。</p><p>我们推荐每个服务一个文件及其相应的请求和响应。 考虑命名此文件<code>&lt;enclosed service name&gt;.proto</code>。 对于只有资源的原始文件，请考虑将该文件命名为<code>resources.proto</code>。</p><h2 id="原文件名称"><a href="#原文件名称" class="headerlink" title="原文件名称"></a>原文件名称</h2><p>Proto文件名应该使用lower_case_underscore_separated_names，并且必须使用扩展名<code>.proto</code>。 例如：<code>service controller.proto</code>。</p><h2 id="Proto选项"><a href="#Proto选项" class="headerlink" title="Proto选项"></a>Proto选项</h2><p>为了在不同的API之间生成一致的客户端库，API开发人员必须在<code>.proto</code>文件中使用一致的原始选项。 符合本指南的API定义必须使用以下文件级原始选项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">syntax = &quot;proto3&quot;;</span><br><span class="line"></span><br><span class="line">//包名应以公司名称开头，以</span><br><span class="line">//主要版本。</span><br><span class="line">package google.abc.xyz.v1;</span><br><span class="line"></span><br><span class="line">//此选项指定要在C＃代码中使用的命名空间。 这是默认值</span><br><span class="line">//到PascalCased版本的proto包，这是很好的</span><br><span class="line">//包名称由单字段组成。</span><br><span class="line">//例如，一个名为“google.shopping.pets.v1”的包将使用C＃</span><br><span class="line">//“Google.Shopping.Pets.V1”的命名空间。</span><br><span class="line">//但是，如果程序包名称的任何段由多个单词组成，</span><br><span class="line">//这个选项需要被指定，以避免只有第一个字</span><br><span class="line">//大写。 例如，Google Pet Store API可能具有包名称</span><br><span class="line">//“google.shopping.petstore.v1”，这意味着C＃的命名空间</span><br><span class="line">//“Google.Shopping.Petstore.V1”。 相反，应该使用该选项</span><br><span class="line">//正确地将其大小写为“Google.Shopping.PetStore.V1”。</span><br><span class="line">//有关C＃/。NET大小写规则的更多详细信息，请参阅[框架设计]</span><br><span class="line">//指南]（https://msdn.microsoft.com/en-us/library/ms229043）。</span><br><span class="line">option csharp_namespace = &quot;Google.Abc.Xyz.V1&quot;;</span><br><span class="line"></span><br><span class="line">//此选项让proto编译器在程序包中生成Java代码</span><br><span class="line">//名称（见下文），而不是外部类。 它创建一个更简单</span><br><span class="line">//通过减少一级名称嵌套的开发人员体验</span><br><span class="line">//与大多数不支持外部类的编程语言一致。</span><br><span class="line">option java_multiple_files = true;</span><br><span class="line"></span><br><span class="line">// Java外部类名应该是UpperCamelCase中的文件名。 这个</span><br><span class="line">//类只用于保存原始描述符，所以开发人员不需要</span><br><span class="line">//直接使用它</span><br><span class="line">option java_outer_classname = &quot;XyzProto&quot;;</span><br><span class="line"></span><br><span class="line">// The Java package name must be proto package name with proper prefix.</span><br><span class="line">option java_package = &quot;com.google.abc.xyz.v1&quot;;</span><br><span class="line"></span><br><span class="line">//从包中生成的Objective-C符号的合理前缀。</span><br><span class="line">//应该至少有3个字符长，全部大写和约定</span><br><span class="line">//是使用包名称的缩写。 有点短，但是</span><br><span class="line">//希望足够独特，不会与可能出现的事情冲突</span><br><span class="line">// 未来。 &apos;GPB&apos;保留给协议缓冲区实现本身。</span><br><span class="line">option objc_class_prefix = &quot;GABCX&quot;;</span><br></pre></td></tr></table></figure><h2 id="词汇表"><a href="#词汇表" class="headerlink" title="词汇表"></a>词汇表</h2><h3 id="联网API"><a href="#联网API" class="headerlink" title="联网API"></a>联网API</h3><ul><li>应用程序编程通过计算机网络运行的接口。它们使用包括HTTP在内的网络协议进行通信，并且经常由不同的组织生成，而不是消费它们。</li></ul><h3 id="Google-API"><a href="#Google-API" class="headerlink" title="Google API"></a>Google API</h3><ul><li>由Google服务公开的网络API。他们大多数托管在googleapis.com域上。它不包括其他类型的API，如客户端库和SDK。</li></ul><h3 id="API接口"><a href="#API接口" class="headerlink" title="API接口"></a>API接口</h3><ul><li>协议缓冲区服务定义。它通常映射到大多数编程语言中的接口。 API接口可以由任何数量的API服务来实现。</li></ul><h3 id="API版本"><a href="#API版本" class="headerlink" title="API版本"></a>API版本</h3><ul><li>API接口的版本或一组API接口，如果它们一起定义。 API版本通常由字符串（例如“v1”）表示，并呈现在API请求和协议缓冲区包名称中。</li></ul><h3 id="API方法"><a href="#API方法" class="headerlink" title="API方法"></a>API方法</h3><ul><li>API接口内的单独操作。它通过rpc定义在协议缓冲区中表示，并且通常在大多数编程语言中映射到API接口中的函数。</li></ul><h3 id="API请求"><a href="#API请求" class="headerlink" title="API请求"></a>API请求</h3><ul><li>单一调用API方法。它经常用作计费，记录，监控和速率限制的单位。</li></ul><h3 id="API服务"><a href="#API服务" class="headerlink" title="API服务"></a>API服务</h3><ul><li>在一个或多个网络端点上暴露的一个或多个API接口的部署实现。 API服务由其与RFC 1035 DNS兼容的服务名称（如calendar.googleapis.com）标识。</li></ul><h3 id="API端点"><a href="#API端点" class="headerlink" title="API端点"></a>API端点</h3><ul><li>指的是API服务用于服务实际API请求的网络地址，例如pubsub.googleapis.com和content-pubsub.googleapis.com。</li></ul><h3 id="API产品"><a href="#API产品" class="headerlink" title="API产品"></a>API产品</h3><ul><li>API服务加相关组件，如服务条款，文档，客户端库和服务支持，作为产品集体呈现给客户。例如Google Calendar API。注意：人们有时将API产品简称为API。</li></ul><h3 id="API服务定义"><a href="#API服务定义" class="headerlink" title="API服务定义"></a>API服务定义</h3><ul><li>用于定义API服务的API接口定义（.proto文件）和API服务配置（.yaml文件）的组合。</li></ul><h3 id="API消费者"><a href="#API消费者" class="headerlink" title="API消费者"></a>API消费者</h3><ul><li>消费API服务的实体。对于Google API，通常是拥有客户端应用程序或服务器资源的Google项目。</li></ul><h3 id="API制作人"><a href="#API制作人" class="headerlink" title="API制作人"></a>API制作人</h3><ul><li>实体生成API服务。对于Google API，它通常是拥有API服务的Google项目。</li></ul><h3 id="API后端"><a href="#API后端" class="headerlink" title="API后端"></a>API后端</h3><ul><li>一组服务器以及实现API服务业务逻辑的相关基础架构。单个API后端服务器通常称为API服务器。</li></ul><h3 id="API前端"><a href="#API前端" class="headerlink" title="API前端"></a>API前端</h3><ul><li>一组服务器和相关基础架构，可跨API服务提供通用功能，例如负载平衡和身份验证。单个API前端服务器通常称为API代理。注意：API前端和API后端可能彼此相邻或彼此远离运行。在某些情况下，它们可以编译成单个应用程序二进制文件，并在单个进程中运行。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;这是网络API的一般设计指南。自2014年以来，它已在Google内部使用，是Google在设计Cloud API和其他Google API
      
    
    </summary>
    
    
  </entry>
  
</feed>
